СТРУКТУРНАЯ ПАРАДИГМА
Дейкстра -> ЛЮБОЙ алг можно выразить через 3 способа выбора команд:
    линейное exe
    ветвление по усл
    exe цикла при exe условия
    #рекомендовал использовать only их
Никлаус Вирт -> Алгоритмы + Структуры данных = Программы
возможность записать подпрограмму в v ПРИНАДЛЕЖ даже asm

ИНКАПСУЛЯЦИЯ
# защита инварианта
# Любая программная сущность, обладающая нетривиальным состоянием, должна быть превращена в замкнутую систему, которую можно только перевести из одного корректного состояния в другое.(чтобы его нельзя было сломать)
    * все что касается obj - внутри одной архитектурной границы(упаковка данных и поведения в единый компонент)
    #все что касается класса пакуется в один модуль
    #между классами четкие границы
    * четкое разделение интерфейса и реализации
        * КАЖДЫЙ obj должен иметь свой pi - таким чтобы не было необходимости лезть в реализацию или использовать его неподходящим образом
        #ВСЕ КЛАССЫ имеют интерфейс
        * в этом помогает сокрытие данных
            код не может пересечь границу о которой не знает, и получить данные к которым нет доступа

СОКРЫТИЕ РЕАЛИЗАЦИИ В РЕЛЯЦИОННЫХ БД
#] СУЩ бд, используемая несколькими программами, к реализации которых нет доступа
    создаем
        набор хранимых процедур, компонуем в схему Interface
        для каждой программы создаем по пользователю и разрешаем доступ только к этой схеме
    #теперь сущность с нетривиальным поведением закрыта интерфейсом

АЛЬТЕРНАТИВА СОКРЫТИЯ В PYTHON
    * _
    * Документировать only интерфейс, ВСЕ что НЕ_ИМЕЕТ доков - реализация
    * Отделять интерфейс через code-conventions
        __all__
    * Сделать code-convention строгими
        # автоматические проверки -> нарушение приравнивается к ошибке и ломает сборку

#базовыи класс определяет fx которая должна быть общеи для ∀ производных

объекты предоставляют интерфейсы. if объект предоставляет интерфейс -> интерфейс специфицирует поведение объекта.
классы реализуют интерфейсы. if класс реализует интерфейс -> его экземпляры предоставляют данный интерфейс
Экземпляры предоставляют интерфейсы которые их классы реализуют, & могут напрямую предоставлять дополнительные интерфейсы не реализованные в классе.
классы обычно не предоставляют интерфейсы которые они реализуют
#можно обобщить это до фабрик - можно создать callable производящий obj предоставляющие интерфейсы ~ фабрика реализует интерфейсы.

ПОЛИМОРФИЗМ
# Страуструп -> один интерфейс - мн-во реализаций
# пользователь интерфейса не будет знать о реализации ничего
    поменялась ли она

ПОЛИМОРФИЗМ ЗА ПРЕДЕЛАМИ ООП
# Erlang СОДЕРЖ фичу behaviour
    # код делится на модули, имя модуля можно исп как v ->
        # вызов fx из модуля:
            foobar:function()
            или
            Module = foobar
            Module:function()
            # behavior нужен для уверенности что модуль ИМЕЕТ определенные fx
                # в модуле использующем другие модули с помощью behavior_info задаются требования к модулям-v, в свою очередь модули с помощью декларации behaviour обязуются реализовать это поведение
                #es:
                    # модуль gen_server позволяет создать сервер в отдельном процессе, выполняющий запросы других процессов, gen_server СОДЕРЖ ВСЮ логику запросов других процессов
                        # но обработка запросов делается реализацией поведения gen_server, и пока другие модули реализуют его правильно(пусть там пустые заглушки) - gen_server плевать как обрабатываются эти запросы и более того, обрабатывающий модуль можно сменить на лету

НАСЛЕДОВАНИЕ
#позволяет объединить переиспользование кода с полиморфизмом

SINGLE RESPONSIBILITY
# где и как должны пролегать границы между классами(интерфейс, реализация