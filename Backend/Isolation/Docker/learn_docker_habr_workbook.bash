контейнеризация делает apps
	безопаснее
	облегчает развертывание
	улучшает возможности масштабирования
МЕХАНИЗМЫ DOCKER
	docker
	#платформа разработки, развертывания, запуска apps в контейнерах
	#~Docker Platform
	#позволяет упаковывать код и зависимости в контейнеры
	
	Docker Engine
	#клиент-серверное app.
	#делится на:
		Docker Community Edition(CE)
		# во многом основан на Open Source инструментах
		# бесплатен
		
		Docker Enterprise
		# содерж доп возможности поддержки, управления и безопасности сис-м
	
	Docker Client
	#основное ср-во взаимодействия с docker
	#использует API Docker для отправки комманд Docker daemon
	Docker CLI
	#интерфейс к Docker Client
	
	Docker daemon
	#демон сервера docker, ожидающий запросов с использованием Docker API
	#управляет образами, контейнерами, сетями, томами
	
	Docker Volumes
	#наиболее предпочтительный механизм постоянного хранения данных приложений(потребляемых/генерируемых)
	
	Docker Registry
	#реестр, хранения образов

	Docker Repository
	#репозиторий образов контейнеров
	#набор образов с одинаковыми именами и разными тегами
	#es:
		репозиторий 'Python' содержит Python:3.7-slim
	#в реестр можно отправить целый репозиторий или отдельный образ
	
	Тег
	#идентификатор образа


МАСШТАБИРОВАНИЕ DOCKER
#термины относящиеся к одновременному использованию нескольких контейнеров
	
	Docker Networking
	# сетевые механизмы docker
	# https://docs.docker.com/engine/tutorials/networkingcontainers/
	# https://www.oreilly.com/learning/what-is-docker-networking/
	# позволяют организовать связь между контейнерами, размещенными на одном или разных хостах
	
	
	DOCKER COMPOSE
	#Инструент упрощающий развертывание apps, для работы которых требуется несколь контейнеров
	#позволяет exe команды из `docker-compose.yml`, нужно число раз
	#имеет cli
	#должен ставиться с docker
	
	Docker Swarm
	#решение для управления контейнерными развертываниями
	#https://docs.docker.com/get-started/#recap-and-cheat-sheet
	#редко кому нужен
	
	Оркестрация контейнеров
	#развертывание контейнеров
	
	Docker Services
	#различные части распределенного app, контейнеры в проде
	#в пределах сервиса exe only один образ, но сервис определяет как он exe
		какие порты использовать
		сколько экземпляров/реплик должно exe для обеспечения необходимой вычислительной мощьности
		...
	#масштабирование сервисов предусматривает ИЗМ числа контейнеров благодаря чему сервис получает необходимое число вычислительных ресурсов
	#позволяют масштабировать контейнеры в пределах нескольких демонов Docker - благодаря чему СУЩ Docker Swarm
	
контейнер
#переносим(легче вм)
#имеет api
	порты которые можно открыывать
	cli
#выполняющийся экземпляр образа


образ контейнера 
#набор инструкций для его создания(в mem?)
#содерж слои:
	образ базовой ос:ro
	#~базовый образ ос~исходный слой/слои образа~родительский
	код приложения:rw

СЛОИ ОБРАЗА
#файлы описывающие дельту между состояниями образа
#при загруки из репозитория скачиваются только отсутствующие слои - они общие для разных образов
#при первом использовании FROM docker загрузит слои определяемые образом
#изменяемый слой всегда самый верхний, остальные ro
#docker использует стратегию копирования при записи - if слой в образе СУЩ на пред уровне, и какому-либо слою нужно читать из него -> используется СУЩ файл, if файл в слое нужно модифицировать - он копируется в верхний слой
	#подробности:https://docs.docker.com/v17.09/engine/userguide/storagedriver/imagesandcontainers/
#создаются
	FROM
	RUN
	COPY
	ADD


Alpine
#популярные легковесные образы ос
#RUN apk
	#!=apk, Alpine Linux package manager
	


pipenv
	https://stackoverflow.com/questions/46503947/how-to-get-pipenv-running-in-docker

Dockerfile
#набор инструкций создания образа
#в основном ставит пакеты(очевидно что должен предоставляться нижележащим слоем)
	alpine -> apk
	python -> pip, wheel, conda
	other pl -> их пакетные менеджеры
	
#содерж описание слоев и порядок их добавления в образ:
	описание базового образа ос
	промежуточный слой зависимостей
	слой данных для изменения/программы
#должен начинаться с
	FROM|ARG..FROM
#syntax:
	INSTRUCTION args
#commands:
	СОЗДАЮЩИЕ СЛОИ
		FROM
		#создает слой в итоговом образе
		#задает базовый образ
		#минимально необходимый набор Dockerfile
		#тег образа - опционален, при отсутствии - используется свежайший образ
		#es:
			FROM ubuntu:18.04
			
		RUN
		#создает слой в итоговом образе(с фиксированным состоянием)
		#выполняет команду и создает образ
		#используется для установки в контейнер пакетов
		#!ОДНА КОМАНДА -> + ОДИН ОБРАЗ
		#es:
			RUN apk update && apk upgrade #обновить пакеты ИЗ базового образа
			RUN apk add bash #добавить bash


		COPY
		#создает слой в итоговом образе
		#копирует в контейнер файлы & dirs из локального контекста(директории сборки)
		#создает директории при их !СУЩ
		
		ADD
		#копирует файлы & dirs в контейнер, может распаковывать локальные .tar
		#похожа на COPY, но ВКЛЮЧ доп применения
			добавление в контейнер файлов загруженных из удаленных источников
			распаковка локальных .tar
		#не рекомендована к использованию(?файлы нельзя будет снести, и это ?менее понятно)
		#es:
			#копирование удаленного файла в контейнер(плохая практика - после создания их будет не удалить)
			ADD https://raw.githubusercontent.com/discdiver/pachy-vid/master/sample_vids/vid1.mp4 /my_app_directory
	
	ОПИСЫВАЮЩИЕ МЕТАДАННЫЕ

		LABEL
		#описывает метаданные, es:
			создатель
			мейтенер
			...
		#не замедляют создание образа
		#details:https://docs.docker.com/config/labels-custom-metadata/

	НАСТРОЙКИ
		ARG
		#задание переменных(by default) для передачи Docker при сборке образа, может быть передана из cli
		#в отличие от v устанавливаемых ENV - ARG variables недоступны при exe контейнера
		#могут использоваться для задания default vals для env-vars из cli при сборке, а те будут доступны при exe контейнера
			#details: https://vsupalov.com/docker-build-time-env-values/
		#es:
			ARG my_var=my_default_value
			
			
		ENTRYPOINT
		#предоставляет команду с args для вызова при выполнении контейнера
		#args не переопределяются из cli, вместо этого они добавляются
		#es:
			docker run <image_name> bash
			...
			ENTRYPOINT ["python", "./app/my_script.py", "my_var"]
			...
				>> python ./app/my_script.py my_var
		#применимость
			при каждом запуске нужно exe одну команду
			контейнер используется как app
		#предпочтительо использовать exec-форму записи
		
		ENV
		#установка переменных среды
		#по сути используется как константы в Dockerfile
	
	ВЫПОЛНЕНИЕ КОМАНД ПРИ ИСПОЛНЕНИИ КОНТЕЙНЕРА
	#выполнить команду, напр открыть порт
		
		CMD
		#описывает команду для exe после запуска контейнера
		#args мб переопределены при запуске контейнера
		#!файл может содержать только одну CMD команду
			#при наличии нескольких CMD используется только последняя
		#мб не содержать указания исполняемого файла при условии что указан ENTRYPOINT(обе в EXEC форме)
		#переопределяется args переданными с docker run
		#не exe при сборке
		#if
			нужно передавать args при запуске
		
		WORKDIR
		#задать рабочую dir для следующей иструкции
			COPY
			ADD
			RUN
			CMD
			ENTRYPOINT
		#предпочтительнее использования cd
		#создает директории при отсутствии
		#можно исп несколько WORKDIR
			при использовании относительных путей - меняют путь относительно предыдущей
		
		EXPOSE
		#указывает на необходимость открыть порт
		#es:
			EXPOSE 8000
		
		VOLUME
		#создает точку монтирования для работы с постоянных хранилищем(том для хранения данных)
	
	
ПЕРЕНОС СТРОКИ
	\

ФОРМЫ ЗАПИСИ RUN И СХОЖИХ ИСТРУКЦИЙ(CMD, ENTRYPOINT)

	exec-форма
	#использует синтаксис ~ json arrays(double quotes)
	#es:
		RUN ["<executable>", "<arg_0>", "<arg_1>"]
	
	shell
	#es:
		RUN apk update && apk upgrade && apk add bash


	
docker
	run image_name
	#создает контейнер из образа и запускает его
	#агрументы - переопределяют args CMD

	build
	# создать образ используя Dockerfile в .
		-f
		#указать Dockerfile
		
Docker Hub
#крупнейшее хранилище образов
#default

предшественники
LXC

libcontainer
#"самописная" замена LXC

контейнер использует ядро хоста для менеджмента mem и процессов


OpenVZ использует очень похожий подход, но сложнее в использовании и не имеет столь широкой базы готовых контейнеров


ПРЕИМУЩЕСТВА

    воспроизводимость окружения, чтобы не случилось так, что разработчик говорит, что у него всё работает, а при разворачивании на сервере всё ломается из-за того, что разработчик забыл описать в требованиях какую-то зависимость.

	изолированость окружения, чтобы не случилось так, что для работы одному проекту нужна версия 1 какого-то инструмента, а другому проекту — версия 2, а одновременно на одну машину эти версии не становятся.

	поддержка чистоты на хост-машине, чтобы не случилось так, что для проекта нужно установить с десяток зависимостей, которые потом нужно долго и нудно выковыривать из системы, контейнер удаляется в одну команду, не зависимо от того, насколько глубоко пакеты в нём интегрированы в систему

	замена пакетному менеджеру(?), чтобы не случилось так, что для вашего дистрибутива или для вашего пакетного менеджера нет готовых бинарников нужного пакета, можно просто поднять его в докере и не морочить себе голову с курением мануалов (на самом деле этот пункт — лишь забавный побочный эффект от других преимуществ докера)
    
	простота разворачивания, чтобы можно было проще настраивать инструменты непрерывного развертывания


НЕДОСТАТКИ

1. Докер практически исключительно для кода, не для данных. Данные надо держать где-то снаружи, и потом пробрасывать внутрь контейнеров папки/диски/луны/чотамувас для тех данных, которые должны пережить рестарт контейнера. Не, ну если надо на локалхосте поставить какого-нибудь монстра, два часа потыкать в него и снести — можно и внутри данные хранить. В тестовых контейнерах опять же можно. Но на проде так делать не надо.
2. Вводя докер, вы переходите на коммуникации через tcp/ip. Монолитный nginx + php-fpm + mysql на сокетах может работать раза в два быстрее, чем то же самое, но в отдельных контейнерах по локальному tcp/ip. Потому что сокет он в разделяемой общей памяти и без копирования, а по сети данные минимум трижды копируются при упаковке/распаковке пакетов.
3. Вводя докер, вы вводите серьёзные зависимости непонятно от кого. Ну, точнее, следите, чьи именно репы вы используете. Они могут что-нибудь сломать в очередном апдейте (бывало и много раз), или вообще запихать какую-нибудь гадость (не слышал, но...).