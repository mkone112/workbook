BAD PRACTICE
	большие коммиты
		большие потери при revert
		сложно писать msg
		...
пуш
коммит
#атомарное изменение файлов
#фиксация
#снимок состояния
code review
PVCS
#распределенные vcs постепенно замещают централизованные
github
#использует git
#соц сеть для разрабов
КАЖД репозиторий имеет
  wiki
  issue tracking system
  возможность code review
можно создать свой repo и fork'нуться от чужого
git опции
  -С
  #сменить папку репозитория
  -c параметр-val
  #изменение параметров конфигурации
  -p
  #прокручивать весь вывод с помощью less
git комманды
  add
  #добавить файлы/папки в repo
  am
  #применить ВСЕ патчи из email
  archive
  #создать архив файлов
  bisect
  #бинарный поиск коммита
  branch
  #управление ветками проекта
	#создать новую branch
		git branch <branc_name>
  bundle
  #перемещение obj и ссылок в архиве
  checkout
  #переключение между ветками
  cherry-pick
  #внести изменения в сущ коммиты
  #перенести в master только определенные коммиты
  push
  #коммит на удаленный сервер
	git push origin
	#отправить изменения на сервер
  log
  #список коммитов
  clean
  #удалить все неотслеживаемые
  clone
  #создать копию удаленного репозитория в папку(видимо локальную)
  #создает каталог с именем repo, копирует туда(check out) рабочую копию последней версии(включ last commit) и каталог .git
  #поддерживает
	http(s)
	git
	<user@server>:/(ssh)
  commit
  #сохранить изменения в репозитории
  diff
  #посмотреть изменения между коммитами
  #содержимое index и рабочего каталога => вывод содержимого lastcommit?
  fetch
  #скачать удаленный репозиторий
  init
  #создать репозиторий
  merge
  #объединить(слить) две ветви
  #ветвь с которой было произведено слияние м.б. удалена
  #файлы удаленные в feature branch - удаляются в master при слиянии
	  #слить изменения из <name> в текущую ветвь
  pull
  #интегрировать удаленный repo с локальным
  tag?
  worktree
  #управление деревьями разработки
git аргументы

git позволяет
  просмотреть изм и откатиться не на любой момент разработки, а позволяет перемещаться между коммитами, КАЖД коммит поддерживает комменты
  позволяет отправить все изменения(включая все коммиты) на удаленный сервер
  координально отличается от других СКВ вроде
	CVS, Subversion, Bazaar, Perforce, etc
	#относятся к информации как к списку файлов и патчей к ним
git почти ~ mercurial

git поддерживает
	разграничение доступа
GIT CONFIGS
	Win
	  Program Files
	  users/<user_name>
	  ProgramData
	Linux
	  /etc/gitconfig
	  #содерж val общие для ∀ users сис-мы & ∀ их реп
	  #устанавливается
	  	git config --system
КАЖД проект СОДЕРЖ одну branch по умолчанию
КАЖД новый файл/папку нужно добавлять вручную
git branch -a
	#* активная вервь - при переключении - реально меняет содержимое папок
pull request
#предлагает изменения, а не вносит их
git init->add->commit->file changed->changes not staged for commited"->add->Changes to be commited
staged - подготовленные
git следит за файлами, но не commit'ит автоматом
отличия централизованных/распределенных скв
	централизованные
		КАЖД клиент выкачивает репу целиком
git
	скорость
	простота дизайна
	простота использования
	полная распределенность
	поддержка нелинейности(тысячи параллельных веток)
	работа с проектами любой сложности/размера
	создает копии ВСЕХ измененных файлов, а на остальные просто ссылается
	большинство операций локальны - лишены лага и простоев
каждое изменение сохраняется с SHA-1 хешем для гарантии целостности данных(~хеш таблиц)
SHA-1
#хеш
#основа git(выявление изменений/повреждений/... данных)
#механизм
#строка из 40 hex чисел вычисляющаяся на основе содержимого файла/структуры каталогов(24b9da6552252987aa493b52f8696cd6d3b00373)
#хеши встречаются в git повсеместно
данные в git в основном только добавляются => сложно совершить неотменяемую операцию
#данные можно потерять только пока они не зафиксированы = > можно не бояться экспериментировать не боясь серьезных проблем
почти все операции локальны
СОСТОЯНИЯ
	файлы в git могут находиться в 3х состояниях
	commited(зафиксированное)<-
		<-changes to be commited, staged
		#изменены и отмечены для включения в next commit
			<-modified
				<-untracked
add
#modified -> staged to be commited
#добавить слепок в index(проиндексировать файл)
#не создает файлы
reset
#staged to be commited -> modified
СТАДИИ
#есть куча хороших схем в гугле
	======working_directory===========================================================*==staging_area(м.б. пропущен)===*========.git dir(repo)============
	[untracked]<-git reset|delete file ; git add->[unmodified]-> <edit> -> [modified] <-?;->(stage?)->[staged]<-?;commit->[git dir]<-?;push->[remote repo]
ТРИ СОСТОЯНИЯ
#основные
		Commited(зафиксированные)
		#файл в бд
		modified
		staged
		#изменены и отмечены для включ в next commit


	#области(секции)
		WorkingDir
		#snapshot (обычно последний) версии проекта распакованный из .git
		StagingArea
		#файл хранящий информацию о next commit
		.git(Repository)
		#хранилище метаданных и базы obj проекта, основной компонент Git
		#копируется при клонировании
		#сжатая бд
	#операции
			Stage Fixes: Working -> Staging
			Commit:		 Staging -> .git(repo)
			Checkout:	 .git	 -> Working
no add|add -> reset -> commit >> "pathspec <...> did not match any file(s) knowns to git"
change to be commited -> modification - modified
working directory
#рабочий каталог
#извлеченная из бд копия одной из версий проекта(обычно последняя)
добавлять файлы по отдельности - нет необходимости
отслеживаемые файлы - под версионным контролем(те что были в last snapshot)
папка git вроде всегда находится в корне проекта
#хранит метаданные(?)(локальный репозиторий) и бд объектов проекта
git в отличие от других VCS хранит данные в виде слепка фс(а не отдельные файлы)
	V1[file_0,file1] -> V2[file_0*,file1]
нельзя напрямую добавлять данные находящиеся вне repo
staged можно пропустить указав в commit конкретный файл
non modified -> commit -> nothing to commit
в gui - отмена коммита выполняет коммит обратный отменяемому
git не дает коммитить без message -> принудительно открывается vim;commit не происходит без
	message/staged/file specified
git поддерживает re
	файлы можно указывать напр так : *.txt
staged затрагивает лишь файл .git/index и не влияет на структуру папок - что совершенно ожидаемо
#staged area=index
#может быть полностью пропущен
#содержит информацию о том что должно войти в next commit
при копировании repo копируется вся папка .git(без соседних файлов)
if файл в working dir(рабочая версия)= файлу в git -> файл commited(зафиксирован)
if версия файла есть в git -> она зафиксирована
if файл в working dir изменен и добавлен в stage area -> файл подготовлен
if файл изменен, но не подготовлен -> файл changed
очевидно что файлы не добавленные в staged/commit -> не часть репозитория(проверить?)
git умеет работать с репами svn
git позволяет работать с несколькими репами параллельно в рамках одного проекта
git config
#утилита
#настройка(просмотр и установка параметров)(в том числе внешнего вида)
#некоторые ключи могут встречаться в нескольких конфигах -> видимо есть приоритеты
	git config --list
	#список настроек
	#q - выход
	git config --system
	#устанавливает /etc/gitconfig:val общие ∀ users
snapshot - слепок(состояние на конктретный момент времени)

###
	git add <file>
	<modified file>
	<commit> #file before editing #состояние на момент add

.gitignore
	comments    #
	стандартные Glob шаблоны
	#упрощенные re используемые командными интерпритаторами
		.../
		#указывает каталог
		*
		#ПОСЛЕД символов
		?
		#один символ
		[abc]
		#один из символов
		[0-9]
		#один символ из интервала
		#работает с числами с большим числом разрядов?
		#работает с символами?
	  ПРИМЕРЫ
		#исключить все файлы *.a, но индексировать lib.a
			*.a
			!lib.a
		#игнорировать файл TODO
			/TODO
			#~TODO
		#игнорировать содержимое каталога
			build/
		#игнорировать все *.txt в doc/
			doc/**/*.txt
каждый коммент на отдельной строке
	<command> #comment > err
.gitignore тоже можно вносить в .gitignore -> но я не думаю что это имеет особый смысл т.к. напр при переносе список исключаемых файлов не будет перемещен
SMARTGIT
	remove repo
	#только отключает repo от smartgit(~atom project) файловая сис-ма не затрагивается
	dark in journal - in remote repo
	#может редактировать commit msg

можно добавить тег к коммиту и создать из него branch
офф руководство: рекомендуется использовать git из оболочки в составе mSysGit вместо powershell, т.к. некоторые примеры могут работать некорректно в ps

РАБОТА С МЕТКАМИ?
ПСЕВДОНИМЫ?
ПРОТОКОЛЫ?
УСТАНОВКА GIT НА СЕРВЕР?
ГЕНЕРАЦИЯ ОТКРЫТОГО SSH КЛЮЧА?
УМНЫЙ HTTP?
GitWeb?
GitLab?
Git-хостинг?
Распределенный рабочий процесс?
Scripting GitHub?
Инструменты Git?
	Выбор ревизии?
	Интерактивное индексирование?
	Прибережение и очистка?
	Подпись результатов работы?
	Исправление истории?
	Продвинутое слияние?
	Rerere?
	Обнаружение ошибок?
	Подмодули?
	Создание пакетов?
	Замена?
	Хранилище учетных данных?
конфигурация Git?
атрибуты git?
git hooks?
Git-Enforced Policy?
Git как клиент?
Миграция на git?
объекты git?
ссылки в git?
pack-файлы?
спецификации ссылок?
протоколы передачи данных?
уход за репозиторием и восстановление данных?
переменные среды?
встраивание git в приложения?
	Libgit2?
	JGit?
	go-git?
	Dulwich?
Команды git?
	настройка и конфигурация?
	Клонирование и создание реп?
	работа с помощью email?
	внешние сис-мы?
	Администрирование?
	Низкоуровневые команды?
git имеет сильную обратную совместимость
использование git упрощается
ИЗМЕНЕНИЯ В GIT
HTTP протокол для сетевых Git транзакций(для упрощения большинство примеров в книге переделаны из SSH на HTTP)
модель ветвлений - киллер фича git
отличие git от пакета?
git может использовать bin search для нахождения багов/правки истории/инспекции кода/...
перехватывающие скрипты
#применяют|поощряют заданную политику
проекты из других CVS м.б. сконвертированны в git
git может работать в связке с другими CVS
git имеет obj модель
CVS - записывает изменения в файл/набор файлов
можно узнать
	какие были изменения
	кто их внес
	кто поставил задачу
суть git - при проблемах - всегда можно все исправить без дополнительных усилий
локальные скв
#хранят записи о всех изменениях в файлах тем самым осуществляя контроль ревизий
	RCS
	#распространяется с компами(mac?)
	#хранит наборы патчей(различий версий)
централизованные cvs
#поддерживает командную разработку
#цскв
	CVS
	Subversion(SVN)
	Perforce
#сервер содержит все версии файлов
#по сравнению с локальными скв
		каждый разраб в определенной степени знает чем заняты другие
		админы имеют полный контроль за доступом(обслуживание одного сервера проще чем группы локальных машин)
#недостатки
		единая точка отказа
распределенные скв
#рскв
	Git
	Mercurial
	Bazaar
	Darcs
#клиенты скачивают весь реп, а не отдельные файлы/версии/снапшоты
#многие рскв могут одновременно взаимодействовать с неск удаленными репами => можно работать с различными группами людей, применяя несколько подходов в разработке, напр:
	иерархические модели
	#что невозможно в цскв
КРАТКАЯ ИСТОРИЯ GIT
#родился в хаосе и спорах
#ядро Linux c 1991-2002 разрабатывалось передачей патчей/архивов, в 2002 проект перешел на BitKeeper
#в 2005 отношения между сообществом разработчиков ядра и компанией выпустившей BitKeeper прекратились -> сообщество с Линусом разработало замену учев опыт использования Bit Keeper
#цели
	скорость
	простота архитектуры
	поддержка налинейной разработки
	#тысячи || ветвей
	полная децентрализация
	возможность эффективного управления большими проектами
	#скорость работы
	#разумное использование дискового пространства
BitKeeper
#децентрализованная проприетарная скв
ОСНОВЫ GIT
интерфейс git похож на интерфейс других скв несмотря на иной способ хранения данных
СНИМКИ, А НЕ РАЗЛИЧИЯ
#большинство других сис-м хранят данные в виде списка патчей к файлам(CVS, SVN, Perforce, Bazaar)(контроль версий основанный на различиях)
	v0  v1  v2
	f0      p0
	f1  p0  p1
ПОДХОД GIT
#хранение снимков фс - при коммите сис-ма сохраняет состояние кажд файла на этот момент, не измененные файлы хранятся ссылками
#при init все файлы добавляются как отправные точки
#представляет данные как поток снимков
	v0		v1		v2
	fA		A1		*A1
	fB		*B		B1
#такой подход вностит преимущества при работе с данными(напр ветви)
#в отличие от цскв большинство операций локальны
	#perforce требует подключения к серверу в большом числе случаев
	#SVN/CVS позволяют редактировать файлы, но нельзя сохранять данные в бд
ЦЕЛОСТНОСТЬ GIT
#для всего вычисляется хеш=>происходит сохранение
#индексация по хешу	, отслеживание изменений тоже
#данная fx'ость - база git, неотъемлемая часть философии - данные не теряются при передаче и не повреждаются без ведома git
РАБОТА С GIT
	#база
		изменение файлов в working dir
		выборочное добавление в index изменений которые должны попасть в коммит
		#добавляя снимки только этих изменений в staged
		коммит
		#использует файлы из index как есть
#большинство gui- клиентов реализуют лишь часть fx git, shell - единственный способ использовать все возможности: при понимании какая команда требуется -> можно легко выяснить как сделать тоже в gui(обратное - не всегда верно)
УСТАНОВКА GIT
#используем 2.0.0
	из собранного пакета(bin)
		mac
			Xcode Command Line Tools
			or
			http://git-scm.com/download/mac
			or
			GitHub for Mac
			#http://mac.github.com
				установить консольные утилиты
		  Mavericks(10.9)+
		  #достаточно просто выполнить в term git
	   win
	   		Git for Windows(msysGit)
			#отделен от самого git
			#msysgit.github.io
			GitHub for Windows(необходимо!)
			#корректно работает с ps
			#обеспечивает четкое(?) сохранение учетных данных
			#обеспечивает правильные настройки CRLF
			сборка из sc
			#позволяет получить самую свежую версию
	другого установщика
	скомпилировать из source
	#обновление bin инсталляторов обычно немного отстает
	  Linux
	  #требуются curl, zlib, openssl, expat, libiconv
	    Debian
	  		apt install libcurl4-gnutls-dev libexpat1-dev gettext \
			libz-dev libssl-dev
		Fedora
			yum install curl-devel expat-devel gettext-devel \
			openssl-devel zlib-devel
		  #для сборки документации(в форматах doc, html, info) потребуются след зависимости
		  [apt|yim] install asciidoc xmlto docbook2x
		  #скачиваем архив с исходниками
		  	#kernel.org: имеют подписи
		  	https://www.kernel.org/pub/software/scm/git
			#или зеркала GitHub: немного проще(?)
			https://github.com/git/git/releases
		  #компиляция и установка
		    tar -zxf git-2.0.0.tar.gz
			cd git-2.0.0
			make configure
			./configure --prefix=/usr
			make all doc info			#возможно без doc и info можно обойтись(хотя возможно это внутренняя сравка)
			sudo make install install-doc install-html install-info
		  #получаем(обновляем?) Git с помощью его службы обновлений
		    git clone git://git.kernel.org/pub/scm/git/git.git
git --version
#проверить версию
ПЕРВОНАЧАЛЬНАЯ НАСТРОЙКА GIT
#при обновлениях настройки сохраняются






































