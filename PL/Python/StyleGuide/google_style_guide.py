ИМПОРТИРУЙТЕ ТОЛЬКО ПАКЕТЫ И МОДУЛИ
+единый стиль указания objs
+происхождение кажд obj очевидно
-возможны конфликты имен модулей
-длинные имена
    РЕШЕНИЕ
    #использовать
        from <packet_prefix> import <module_without_prefix>
    #при конфликте имен или длинных именах
        from <packet> import <module> as <alias>
    #es:
        from sound.effects import echo
        ...
        echo.EchoFilter(...)


НЕ ИСПОЛЬЗОВАТЬ ОТНОСИТЕЛЬНЫЕ ИМЕНА В ИМПОРТАХ 
#даже if модуль находится в том же пакете
+исключает повторный импорт пакета


ИМПОРТИРОВАТЬ МОДУЛИ ПОЛНЫМ ПУТЕМ
+обход конфликтов имен модулей
+видно расположение модуля на диске
-сложнее переносить код
 #тк требуется сохранять иерархию модулей
 РЕШЕНИЕ
 #импорт модулей по полному пути в пакете
     # Ссылка в коде с полным именем
     import sound.effects.echo
     
     # ПРЕДПОЧТИТЕЛЬНО: Ссылка в коде только с именем модуля
     from sound.effects import echo



МИНИМУМ ИСКЛЮЧЕНИЙ
+код обычного потока управления не перемешивается с кодом перехвата ошибок
+позволяет потоку выполнения пропустить несколько фреймов при exe cond
 #например выход из n-вложенных fx за шаг вместо множественный обработок except
-поток управления может завершаться
 #пропустить возникновение except - легко



ВЫЗОВ EXEPT ТОЛЬКО ТАК:
    raise MyException('Error message')
    raise MyException



ЗАПРЕЩЕНО:
    # str форма
        raise 'Error message'
    #?форма записи с двумя args
        raise MyException, 'Error message'



МОДУЛИ/ПАКЕТЫ ДОЛЖНЫ ОПРЕДЕЛЯТЬ СОБСТВЕННЫЕ ПРЕДМЕТНО-ОРИЕНТИРОВАННЫЕ КЛАССЫ EXEPT, НАСЛЕДНИКИ Exception



ОСНОВНОЕ EXEPT МОДУЛЯ ДОЛЖНО НАЗЫВАТЬСЯ:
    сlass Error(Exception):
        """"""



НЕ ИСПОЛЬЗУЙ ОБЩЕЕ EXEPT
#oi не собираешься перевозбуждать их позднее|не находишься во внешнем блоке в thread & выводится err msg
    +не ловятся лишние except чья обработка не предполагается



МИНИМУМ КОДА В try/except
#чем больше кода в try -> вероятнее возбуждение неожиданного except -> try/except скрывает реальную ошибку

    

ИСПОЛЬЗУЙТЕ finally
#бывает полезно для заключительных действий вроде закрытия потока io



# ?ИСПОЛЬЗОВАТЬ AS ВМЕСТО ЗАПЯТОЙ ДЛЯ ПСЕВДОНИМОВ EXEPT



MIN GLOBAL V
    +исключения
        стандартные настройки скриптов
        константы уровня модуля
            PI = 3.14159
        кеширование val полученные из/переданные в callable    
    -можно ИЗМ поведение модуля при импорте
     #?присваивание v модуля завершено когда модуль импортируется


GLOBAL V СОЗДАЮТСЯ В МОДУЛЕ И ДОСТУПНЫ ЧЕРЕЗ ОБЩЕДОСТУПНЫЕ FX УРОВНЯ МОДУЛЯ


КОНСТАНТЫ: UPPER_UNDERSCORED


ИСПОЛЬЗУЙ ВЛОЖЕННЫЕ КЛАССЫ & FX
#=локальные=внутренние
+позволяет вспомогательные классы/fx используемые only in ограниченном пространстве
+соответствует принципу ADT
-?экз вложенных классов не могут быть сериализованы



MAX 1 for & if ВО ВКЛЮЧЕНИИ/ВЫРАЖЕНИИ ГЕНЕРАТОРА



ВСЕ ЧАСТИ ВКЛЮЧЕНИЯ/ВЫРАЖЕНИИ ГЕНЕРАТОРА НА ОТДЕЛЬНОЙ СТРОКЕ
#кроме случает простого возвращения элта
    return ((x, complicated_transform(x))
        for x in long_generator_function(parameter)
        if x is not None)
    eat(jelly_bean for jelly_bean in jelly_beans
          if ...)



ИСПОЛЬЗУЙ СТАНДАРТНЫЕ ИТЕРАТОРЫ & ОПЕРАТОРЫ
#контейнеры определяют свои итераторы и операторы(напр тестовые in, not in)
+выражают операцию напрямую(без внутренних перевызово)
+стандартные интерфейсы
+/-нельзя определить тип по методу



ИСПОЛЬЗУЙ СТАНДАРТНЫЕ ИТЕРАТОРЫ/ОПЕРАТОРЫ ВМЕСТО МЕТОДОВ >> СПИСКИ
#кроме случаев когда нужно ИЗМ сам контейнер при итерации
#очевидно



ИСПОЛЬЗУЙ """Generate:""" вместо """Return:""" В DOCSTRINGS ГЕНЕРАТОРОВ



НЕ ИСПОЛЬЗУЙ lambda ДЛЯ ПРОСТЫХ ДЕЙСТВИЙ КОТОРЫЕ МОЖНО ВЫПОЛНИТЬ БОЛЕЕ ЛАКОНИЧНО
    operator.mul вместо lambda x,y: x*y
+легче отлаживать и читать код и стек вызовов тк lambda не имеет имени



НЕ ИСПОЛЬЗУЙ lambda IF СТРОКА С НЕЙ ПОЛУЧАЕТСЯ ДЛИНЕЕ 80ch
#lambda подходит только для inline exp



ИСПОЛЬЗУЙ ТЕРНАРНЫЙ ОПЕРАТОР ONLY ДЛЯ INLINE EXP
+лаконичнее
-мб снижать читаемость



НЕ ИСПОЛЬЗУЙ MUTABLE VAL BY DEF FOR ARGS


ИСПОЛЬЗУЙ ИМЕНОВАНЫЕ ARGS ДЛЯ АРГУМЕНТОВ СО ЗНАЧЕНИЯМИ ПО УМОЛЧАНИЮ ПРИ ВЫЗОВЕ
#позволяет документировать код
#предотвращение передачи не корректного числа args
#пожалуй не имеет особого смысла if arg всего один


?ИСПОЛЬЗУЙ СВ-ВА ДЛЯ ДОСТУПА К ДАННЫМ|ПРИСВОЕНИЯ VAL ВМЕСТО ГЕТТЕРОВ/СЕТТЕРОВ
#if вычисления не очень сложные
+читабельнее
 #за счет исключения вызовов getters/setters при простом доступе к attr
+?возможны ленивые вычисления
+?(in Python/OOP/questions)поддерживать интерфейс класса - python way
+быстрее
 #позволяет св-ву быть доступным через простейший геттер когда нужен прямой доступ к v
+позволяет методам доступа быть добавленными позднее без изм интерфейса
 #те(по идее) определение другой логики доступа, а сам доступ будет производиться так-же через доступ к св-ву
-св-ва объявляются после объявления геттеров и сеттеров требуя сообщить им что они используются для св-в находящихся ниже в коде(исключая read-only св-ва созданные с помощью @property)
-?могут скрывать побочные эффекты(напр оператор перегрузки)
-?могут вводить в заблуждение классы наследники



    СОЗДАВАТЬ RO СВ-ВА ONLY С ПОМОЩЬЮ @property 
    #наследование со св-вами мб непрозрачным if с-во родителя не переопределено
        #-> необходимо убедиться что геттеры вызываются косвенно для обеспечения переопределение методам подклассов, вызываемых через св-во(используя паттерн "Шаблонный метод")
    #es:
        #возможно это пример шаблонного метода
        import math
        ...
        class Square:
            """A square.
            :property area: a writable area
            :property perimeter:read-only perimeter
            
            To use:
            sq = Square(3)
            sq.area             # 9
            sq.perimeter        # 12
            sq.area = 16
            sq.side             # 4
            sq.perimeter        # 16
            """
            
            def __init__(self, side):
                self.side = side
            
            def __get_area(self):
                """Calculates the 'area' property."""
                return self.side ** 2
            
            def ___get_area(self):
                """Indirect accessor for 'area' property."""
                return self.__get_area()
            
            def __set_area(self, area):
                """Sets the 'area' property."""
                self.side = math.sqrt(area)
            
            def ___set_area(self, area):
                """Indirect setter for 'area' property."""
                self.__set_area(area)
            
            area = property(___get_area, ___set_area,
                            doc="""Gets or sets the area of the square.""")
            
            @property
            def perimeter(self):
                return self.side * 4



ИСПОЛЬЗОВАТЬ BOOL НЕЯВНО



ИСПОЛЬЗОВАТЬ is|not is для сравнения singleton obj
#es:None



ИСПОЛЬЗОВАТЬ 'if not v' ДЛЯ СРАВНЕНИЯ V С FALSE



ДЛЯ ОТЛИЧИЯ False от None ИСПОЛЬЗОВАТЬ 'if not x and x is not None'


СРАВНИВАТЬ ЧИСЛА С НУЛЕМ ДЛЯ ИСКЛЮЧЕНИЯ ПРИВЕДЕНИЯ None К НУЛЮ
    if foo == 0:...


MIN ИСПОЛЬЗОВАТЬ МОДУЛЬ string


?!ЦИКЛЫ ВМЕСТО reduce

ИСПОЛЬЗОВАТЬ GENEXP/COMPREHENSIONS ВМЕСТО map/filter СОДЕРЖ lambda
    [x[1] for x in my_list if x[2] == 5]
    вместо
    map(lambda x: x[1], filter(lambda x: x[2] == 5, my_list))

