Δ Py 2.X/3.X
    3.X
        Навязал модель Unicode для строк/файлов/библиотек(бесшовная модель Unicode)
        Переписaны io lib
        #для поддержки unicode и уменьшения зависимости от OC
            -> усложнил анализ производительности(например while vs for)
        #2.X
            'ф' >> '\xe4'

        Расширение применения итераторов и генераторов - часть функциональной парадигмы
        #гораздо большая часть инструментов тетерь генерирует результаты по запросу, а не сразу, что также позволяет снизить задержки при интерпритации
        Классы нового стиля обязательны
        Оператор print стал fx
        Появился nonlocal
        raw_input() -> input()
            
        input()2.X ~ 3.X eval(input())
        объединение int и long
        файловые интерфейсы радикально изменились, классы реализации fileobj были перенесены в модуль io
        
    2.X
        Программная база 2.x все еще > 3.x
        2.x практически !Δ -> более стабилен

ОБЩЕЕ
    JIT-компилятор
    #Just-In-Time оперативный, расширение PVM, транслирует порции байт-кода до bin машинного во время выполнения программы
    #способен создавать специфичный к типам машинный код для динамического кода Python отслеживая обрабатываемые программой типы данных, и по аналогии с Dalvik - программа работает все быстрее и быстрее

PYTHON VS OTHER PL


СТОРОННИЕ ИНСТРУМЕНТЫ

    АЛЬТЕРНАТИВНЫЕ РЕАЛИЗАЦИИ PYTHON
    
        PyPy
        #инициатива, реализация CPython 2.x , 3.5+ повышающая производительность обычно в 10-100 раз(в среднем 7,6 по сравнению с CPython)
        #тесты производительности:speed.pypy.org/;pypy.org/performance.html
        #site:pypy.org
        #в случае сложных систем может быть быстрее C
        #Работает на Intel x86(IA-32), x86_64, ARM, PPC(в разработке на 2013)
        #имеет поддержку численного программирования
        #содерж JIT-компилятор, песочницу, поддерку Stackless(микропотоки/массовый параллелизм)
        #в некоторых случаях программы на PyPy занимают меньше mem(до 3х раз)
        #способен выполнять большую часть кода CPython, но модули на C обычно требуется рекомпилировать
        #имеет ряд тонких языковых отличий
            #семантика сборки мусора - для избегания некоторых распространненых паттернов написания кода, напр:
                #схема без подсчета ссылок => файлы можно не закрывать и не сбрасывать выходные буфферы немедленно, хотя в ряде случаев может потребоваться ручной вызов fx закрытия
        #цепочка инструментов PyPy достаточно общая(?) => поддерживает дополнительные яп
            #Pyrolog(Prolog)
        
        
        Pyrolog
        #интерпритатор Prolog написанный на Python с использованием PyPy
        
    КОМПИЛЯТОРЫ
    
        Psyco
        #первоначальный специализированный JIT-компилятор, предшественник JIT-компилятора в PyPy
        #"полная реализация Python"(хотя не явл реализацией), с высокой скоростью выполнения(2-100раз)(обычно 4) что почти ~ динамическому модулю раширения C без смены интерпритатора
        #max ускоряет алгоритмы(которые обычно и нуждаются в ускорении) на чистом Python
        #компонент расширяющий модель выполнения байт-кода
        #устарел, не сопровождается, наработки использованы в PyPy
        #усовершенствование PVM, собирает и использует информацию о типах при выполнеии программы и порционно транслирует байт-код в машинный, не требует изменений в коде|предварительной компиляции
        #отличается от JIT-компилятора Java - обрабатывает действительно использующиеся типы данных

ВЕРСИИ PYTHON
    2.6
        .format()
    3.0
    #2008г
        nonlocal
        .format()
    3.2
        регресс .format(см .format)
    3.3
        регресс .format(см .format)



НАПИСАНИЕ КОДА СОВМЕСТИМОГО С ОБЕИМИ ВЕТКАМИ PYTHON

    ЗАМЕНА ССЫЛКИ
        import sys
        if sys.version[0] == '2': input = raw_input
        reply = input('Enter text')
        
    2to3
    #инструмент(сценарий) преобразования, пытающийся транслировать код 2.X для выполнение под 3.X
    
    3to2
    #инструмент пытающийся транслировать код 3.X для выполнения под 2.X

    __future__
    #
    
    PRINT
        ФОРМАТИРОВАНИЕ + СКОБКИ
            print(<форматированная строка>)

ФОРМАТИРОВАНИЕ
#можно использовать для преобразования ∀(?) obj в строки, в том числе прямо в вызове print/write
    
    .format()
    #нравится мне слегка больше тк метод как-то лучше вписывается в общий стиль
    #~ % - удобный способ преобразования int в различные cc в виде str
    #в Δ от % может напрямую обрабатывать
        ?ключевые слова
        ?ссылки на attr
        ?коды двоичных типов
    #3.2-3.3(?3.3.X) имеет дефект касающийся обобщенных пустых целей подстановки для attr obj не определяемые обработчиком __format__ - регресс
    #syntax
        {<имя_ключа|индекс_аргумента> <.ссылка|[индекс]> !<флаг преобразования>:<спецификатор>}
        #все эл-ты не обязательны
            флаги преобразования
                r   repr
                s   str
                a   ascii
            спецификатор
                [[заполнение]выравнивание][знак][#][0][ширина][,][.точность][код_типа]
                    заполнение
                        ЛЮБОЙ символ кроме '{' и '}'
                    выравнивание
                        <   влево
                        >   вправо
                        =   дополнение символом знака
                        ^   выравнивание по центру
                    знак
                        +
                        -
                        <пробел>
                    [,] 2.7+,3.1+
                        разделение тысяч запятой(групп по 3 цифры)
                может содержать вложенные строки {<имя_поля>} для динамического получения значения из списка arg, ~ * в выражении форматирования
                    #в отличие от выражений позволяет использовать args почти для всего
                    '{0:.{1}f}'.format(1/3,4) >> '0.3333'
                    '{0:.{1}f}'.format(1/3,4) >> '0.3333'
                    '{:.{}f'.format(1/3,4) >> '0.3333'
                    '{:{}{}{}}'.format(1/3,'.',4,'f') >> '0.3333'
                код типа ~ кодам типов в выражении, кроме
                    b   ~ bin()
                    %   '%'
                    d   заменяет d,i,u
                    s   требует str(что строже и может быть как преимуществом так и недостатком)
    #считается более характерным для python, т.к. не так тесно связан с C printf
    #может быть более читаемым
    #иногда может быть менее лаконичным чем выражение
    #позволяет смешивать типы аргументов(не кажется мне преимуществом("простое лучше сложного"))
        относительные и ключевые args
        позиционные и ключевые args
    #не позволяет смешивать относительные и позиционные args
    #выведен из format C#/.NET
    str.format(*args,**kwargs)
        '{:o} {:x} {:b}'.format(255,255,255) >> '377 ff 11111111'
    #относительные позиции args СОДЕРЖАТСЯ 2.7+,3.1+
        #'делает код менее ясным' - бред на мой взгляд
    #строка формата может сожержать имена атрибутов obj|ключей словаря|индексы эл-тов {xn}, , кажется не поддерживает вызов методов
        #<индекс элта>:<выравнивание><ширина>
            '{0.platform:>10}'.format(sys)
        '{0[key0]}'.format({'key0':'dictVAL0'}) >> 'dictVAL0'
        '{0[key0]}'.format(dict(key0='dictVAL'))
        '{0[0]}'.format.(['elt']) >> 'elt'
        '{d[key1]}'.format(d={'key1':'dictVAL1'})
        #использование для организации шаблонов,доступ к attr
            '{obj.path}'.format(obj=sys)
            '{.platform}'.format(sys)
        '{[0]} {[key1]}'.format(['elt'],{'key1':'val1}) >> 'elt val1'
    #не поддерживает отрицательные индексы('-' используется для выравнивания)
        '{[-1]}'.format([1]) >> TypeErr
format(<obj>,<спецификатор>)
#вызывает <obj>.__format__(<formatSpec>)
#применяется для форматирования одиного эл-та
#то что возвращается в методу .format при вызове obj(и выражению?)


старый формат(выражение форматирования)
#был объявлен устаревшим в 2008, до сих пор используется почти везде включая стандартную библиотеку, еще вопрос что умрет раньше
#часто лаконичнее .format
    '{:f}, {:.2f}, {:06.2f}'.format(x,y,z)
    '%f, %.2f, %06.2f' % (x,y,z)
#% бинарная операция(как-бы очевидно)
#%s %d ... - встроенные(в строку) цели преобразования, d s - коды типа
#нужны скобки if obj больше одного
#изначально в python, основан на модели C printf => поддерживает все обычные коды формата printf C, но возвращает значение вместо вывода
#не позволяет смешивать относительные, позиционные, и аргументы ключевых слов
    %[<(ключСловаря)><flags><width><.точность>]<код типа>
       коды типов
        %s поддерживает ЛЮБЫЕ obj ~ str(x)
        %r repr так-же поддерживает ЛЮБЫЕ obj
        %c символ(int|str)
        %d десятичное int
        %o oct int ~ str(oct(obj))
        %i int(не вижу отличий от %d)
        %x hex int
        %X upper case hex int
        %e тот-же формат что у arg float(научный|обычный)
        %E upper %e
        %f десятичное float
            округляет до ближайшего
        %F upper %f
        %u устарел ~i(раньше был unsigned)
        %g float в научной(при степени e (6<=x<-5)) или обыной форме
            имеет на один разряд меньше float по умочанию,округляет до ближайшего
        %G upper %g
        %% экранирование '%'
       флаги
        - выравнивание влево
        + принудительно показывать знак числа(включая положительные)
          пробел - для отрицательных
        0 дополнение нулями, вроде не работает без указания ширины поля
       точность - только float
       ширина поля включает точку для float
    '%o %x %X' % (64,255,255) >> '100 ff FF'
    * используется для получения параметров fmt из args, принимает int => по идее + передать не получится
        '%.*f' % (2,1.2345) >> '1.23'
    ключи словаря(требует dict) для организации шаблонов
        '%(first)d %(second)s' % {'first':1,'second':'two'} >> '1 two'
        '<string>' % dict(key=val,...)
        reply = '''
            Hello % (name)s!
            Your age is %(age)s'''
.format() vs %
    #сложность сравнима
        data = dict(platform=sys.platform,kind='laptop')
        'My {kind:<8} runs {platform:>8}'.format(**data)
        'My %(kind)-8s runs %(platform)8s' % data
    #.format мощнее => % имеет альтернативы
        #двоичное форматирование
            '%s' % bin()
        #разделение/группировка тысячных разрядов [,]
            '%s' % formats.commas()
    #.format имеет ссылки на значения => это может быть излишним и % имеет альтернативы
        '{[name]}'.format(**d)
        '%(name)s' % d
    #.format имеет явные ссылки на значения => их использование не обязательно => не все их используют, да и не сказал бы что это облегчает жизнь
    #.format имеет общий синтаксис для одиночных и множественных значений(а % позволяет не указывать скобки для одиночного arg) и в одном месте может оказать кортеж в кортеже если синтаксис не одинаков в разных частях программы => это тривиально
        следует всегда использовать скобки в выражении
    #.format - fx => может использоваться там где запрещены выражения
        решается однострочной fx

formats
#<3.1|2.7
#пакет для форматирования
    .commas()
    #вставка запятых
    #исходник содержит 8 строк
        formats.commas(999999999) >> '999,999,999'
    .money()
    #форматирование денежных величин
        formats.money(296999.2567) >> '$296,999.26'
fx в компилируемых яп(C) ведут себя отлично от fx в Python
в Python есть лишь исполняющая среда - понятие времени компиляции НЕ СУЩ => спорно
ФУНКЦИИ
    #инструмент для группировки операторов(упаковка логики) для многократного использования/откладывания выполнения кода
    #спецификации для генерации кода для комплятора
    #удобно помещать их в модули и получать к ним доступ импортированием
    #~подпрограмма,процедура; самоупорядоченная программная единица
    #инструмент управления сложностью, реализует процедурную декомпозицию разбивая систему на части с четкими ролями, каждую часть можно разрабатывать отдельно
    #реализует инкапсуляцию, многократное использование, снижение избыточности-самый базовый инструмент разложения облегчающий сопровождение кода
    #имя fx по сути ~ документации для блока операторов
    def
    #исполняемый код, оператор - можно вкладывать в другой код
        #нельзя писать в заголовке в отличие от lambda
        if True:def hello():print('hello')  >> SyntaxErr
        if True:lambda x:1             >> <function <lambda> ...>
        def hello():def inner():pass      >> SyntaxErr
        #альтернативные определения fx
            if x:
                def func():
                    ...
            else:
                def func():
                    ...
    #в отличие от fx в компилируемых яп(C) fx НЕ СУЩ пока интерпритатор не встретит(достигнет) и не выполнит def и не нуждается в полном определении перед запуском(тело не оценивается(exe) до вызова)
        def test():
            global x;x
        test()      >> NameErr
    #создает(генерирует) fx и автоматически(в отличие от lambda) присваивает ее имени, имя становится ссылкой на fx obj,оператор присваивания
    #вызов fx приостанавливает выполнение вызывающего ее кода пока управление не будет возвращено обратно
    #args передаются по присваиваниям(ссылкам) неявно, вызывающий код и fx разделяют obj по ссылкам, но псевдонимы имен отсутствуют, изменение var аргумента не приводит к изменению в global(отсутствие совмещения var), но изменение на месте приводят;именам(vars) аргументов присваиваются obj передаваемые в точке вызова
        def f(x):
            x = 'fx'
        x = 'glob'
        test(x);x       >> 'glob'
        l = []
        def test(x):
            x.append(1)     #l - obj разделяемый fx с вызывающим кодом
        test(l)
        l           >> [1]
    #передача аргументов = передача указателей(ссылок), не совсем то же что ссылочные параметры в C++, но похожа на модель передачи в C и других яп
    #immutable передаются "по значению" т.е. ссылкой на obj
    #mutable передаются "по указателю"(ссылке) что аналогично способу передачи массивов как указателей в C
    #на практике передача immutable = передаче mutable
    #obj передаваемые как args никогда автоматически не копируются=> меньше потребление mem/cpu,возможность легко изменять их на месте
        #по идее someObj не копируется в x
        L = [0]
        def f(x):
            print('hi')
        f(L)
        #так возможно тоже нет
        def f(x):
            print(x)
        f(L)
        #а так явно копируется
        def f(x):
            x += 1
        f(L)
    #можно распаковывать ЛЮБОЕ число args/kwargs(для указания стандартных val)
    #переопределяют var вышестоящих NS(желательное(ожидаемое) поведение)
        x = 'global'
        def f():
            x = 'local'
    #поддерживают прикрепление attr(2.1+)
    #также способ эмуляции статических локальных var - локальны для var, и сохраняются между вызовами
        def f():pass
        f.x = 1
        f.x     >> 1
        dir(f)      >> [...'x']
        #тупорылый пример применения
            def f():
                for attr in [obj for obj in dir(f) if not obj.startswith('_')]:
                    exec('print(f.' + attr + ')')
            f()         >> None
            f.x = 1
            f()         >> 1
      #код fx не выполняется до вызова
        def first():
            def inner():
                pass
            a = 0
        [i for i in dir(first) if not i.startswith('__')]   >> []
        def first():
            def inner():
                pass
            first.inner = inner
            first.a = 0
        [i for i in dir(first) if not i.startswith('__')]   >> []
        first()
        [i for i in dir(first) if not i.startswith('__')]   >> ['a', 'inner']
        #разумеется пересоздание fx должно удалять attr
        def test():
            test.a = 0
        test()
        'a' in dir(test)        >> True
        def test():
            test.a = 0
        'a' in dir(test)        >> False
    процедура - также действие
    параметры = входные данные fx
        fx - obj => можно сохранять в obj
            l = [print,format]
            l[0]('hello') >> 'hello'
    #obj ИМЕЮЩИЙ операцию(интерфейс) вызова и хранящийся в своей области mem
    #могут вызываться косвенно
    
    #сохранение obj возвращаемого fx
        x = f()
    #т.к заголовок fx выполняется при объявлении параметры по умолчанию сущ между вызовами, которые можно просмотреть например с помощью help
        def f(a=[1]):
            a += [2]
        help(f)     >> ... f(a=[1])...
        f()
        help(f)     >> ... f(a=[1,2])...
        #но не dir
            [obj for obj in dir(f) if not obj.startswith('_')]  >> []
    ЛОКАЛЬНЫЕ VAR fx
    #к локальным var внутри fx нельзя получить доступ извне
    ВЛОЖЕННЫЕ fx
    #вложение - лексическое вложенные NS соответствуют(физически и синтаксически) вложенным кодовым структурам в sc
    #вложенная fx = внутренняя fx = локальная fx(var) - временная fx СУЩ только в момент выполнения объемлющей fx
    ОПЕРЕЖАЮЩИЕ ССЫЛКИ
    #в коде fx допустимо использовать еще не объявленные var(опережающие ссылки), но в классах нет
        def f1():f2()
        def f2():pass
        f1()            >> ok
        class Test():f3()   >> NameErr
    СТАНДАРТНЫЕ attr fx
        function.__qualname__
        #str СОДЕРЖ имя fx
        function.__code__
        #хз что, содержит кучу других obj
        function.setattr
        #по идее сеттер
        function.getattr
        #по идее геттер
        function.__annotations__
        #3.0+
        #dict
        #аннотирующая информация - описание args и результата
        #синтаксические декораторы(?) args и результата собирающиеся в словарь
        #может применяться в контексте проверки на ошибки
        #может быть спользовано как средство регистрации информации об интерфейсах fx
        #м.б. альтернативой arg декораторов fx - более общая идея предусматривающая запись информации вне заголовка fx -> не ограничивается единственной ролью
        #также работает с lambda
            def f(a,b=0):
                pass
            f.__annotations__ = {'a':'file','b':'*args'}
            help(f)                             >> ...f(a:'file',b:'*args'=0)   #выводит тоже в интерактивной подсказке
        #для указания аннотаций используется спец синтаксис;аннотации дополнительно обобщают синтаксис заголовка fx
            def f(a: 'string', b: (1, 10), c: float) -> int:
                return a + str(a+b)
             f.__annotations__  >> {'c': <class 'float'>, 'b': (1, 10), 'return': <class 'int'>, 'a': 'string'}
        #при наличии аннотации Python накапливает их в словаре и присоединяет к obj fx ; аннотация возвращаемого val сохраняется под ключом return
        #в остально синтаксис не меняется
            def f(a: 'annotation' [=standartVal], b: (1,10) [=standartVal]) -> 'ReturnAnnotaion'
    РЕЖИМЫ ПЕРЕДАЧИ АРГУМЕНТОВ
    #Python ВКЛЮЧ инструменты повышающие гибкость передачи аргументов
    #способ отправки функциям объектов как входных данных
        def f(*a,**b):
        #при объявлении собирают аргументы в кортеж/словарь
        #собиратели/экстракторы произвольных аргументов
    #* / что-то вроде разделителей
    f(a,b,*,c,/,d)
сущ тенденция в Python к использованию "батарек в комплекте" для специальных случаев вместо универсальных методик разработки, влечет зависимость от батареек=> язык обрастает избыточным синтаксисом
батарейки в комплекте - подход акцентирующийся на предварительно собранных иструментах для любых задач
нужно будет сделать шпаргалку с труднозапоминаемым синтаксисом для работы/собеседований
декораторы классов Python 2.6+,3.0+
#по идее должны работать аналогично декораторам fx т.е. принимать базовый класс и дополнительно обрабатывать результаты их работы
    Private
    #
    Public
    #
класс - пакет fx обрабатывающих встроенные типы
    #обозначают поля именами
    #позволяют создавать пользовательские iterable
    #способны автоматически перехватывать извлечение attr с помощью перегрузки операций даже if клиенты не применяют средств доступа
    #геттеры/сеттеры - методика написания кода средств доступа к атрибутам
кажется сущ метод который управляет возвращаемым значение fx при загрузке без вызова
    print >> <built-in function print>
    licence >> Type license() to see the full license text
система PyDoc?
motto=3.14(какая-то отсылка?) motto вроде девиз
42 but under no circumstances(очевидно отсылка к автостопом)
альтернативные способы написания кода?
класс - инструмент ооп
ооп в Python сводится главным образом к поиску имен в связанных Ojb с помощью специального первого аргумента fx(self?)
ооп в python считается более простым чем в other pl
все определяемые пользователем исключения - должны быть классами
инструменты управляемых атрибутов - свойства, дескрипторы, декораторы fx классов и метаклассов
python - мультипарагмный - процедурный/ооп/функциональный
вывод, сортировки, .format() ,ряд вызовов dict полагаются на ключевые args
вызовы list({xn}?) используемые многими инструментами основаны на итерациях
применение exec предполагает наличие знаний интерфейсов
наследование связано с метаклассами и дескрипторами
Jython - реализация python на java
IronPython - реализация python на .NET
Stackless - реализация python
C
#нулевой байт в C завершает строку
код Python обычно в 3-5 раз короче кода на C,C++,Java
Даже интерфейсы ос включая запуск программ и обрабоку каталогов явяются насколько возможно переносимыми в Python
численное программирование? - походу что-то связанное с числодробилками вроде NumPy
NumPy мощнее Matlab
Python содержит различные механизмы интеграции, что позволяет исопльзовать его как инструмент настройки и расширения, вызывать библиотеки на C/c++ и наоборот, интегрировать с компонентами Java/.NET взаимодействовать с фреймворками вроде COM/Silverlight, сопрягаться с устройствами черз последовательные порты, взаимодействовать через сети с помощью интерфейсов вроде SOAP,XML-RPC,COBRA
традиционно в Python сценарий - программа из одного файла, программа - сложное многофайловое приложение
Python компилирует(транслирует) опереторы исходного кода в байт-код который затем интерпритирует
байт-код обеспечивает переносимость
Python обычно не компилируется до машинного кода
задачи вроде обработки файлов/конструирования gui выполняются со скоростью C т.к. такие задачи привязываются к скомпилированному коду C в Python
численное програмиирование/анимация обычно нуждаются в скорости
можно вынести части требущие скорости в скомпилированные расширения
язык управления = язык связывания
NumPy
#Numeric
#инструмент численного программирования
#умеет хранить матрицы эффективнее вложенных списков(неудивительно, список - жирная универсальная структура)
#включает
    массивы
    интерфейсы к стандартным математическим библиотекам
    матричный тип
    векторный тип
    float расширенной точности
Stackless предлагает улучшенные решения для удовлетворения требований многопроцессорной обработки
wxPython
#альтернатива tkinter
Dabo
#высокоуровневый инструментальный набор построенный поверх базовых API-интерфейсов(подобных wxPython, tkinter)
Библиотеки для поддержки gui из других инструментальных наборов Python
    PyQt
    #инструментальный набор для поддержки Qt(?)
    PyGTK
    #инструментальный набор для поддержки GTK(?)
    PyWin32
    #инструментальный набор для поддержки MFC(?)
    IronPython
    #инструментальный набор
    #реализация Python на .NET, предоставляет альтернативные способы написания кода для компонентов
    Jython
    #инструментальный набор, позволяет использовать библиотеки Java(например Swing)
    #веб-фреймворк предоставляющий альтернативные варианты написания сцераиев для компонентов (напр создание gui)
    #бесшовная интеграция с Java, написание серверных апплетов запускающихся на стороне клиента
    #позволяет программам на Java вызывать Python код с приенением Java API(класса интерпритатора Python)
    JPype
    #инструментальный набор, позволяет использовать библиотеки Java(например Swing)
    Django
    #фреймворк для веб-разработки
    TurboGears
    #фреймворк для веб-разработки
    web2py
    #фреймворк для веб-разработки
    Pylons
    #фреймворк для веб-разработки
    Zope
    #фреймворк для веб-разработки
    WebWare
    #фреймворк для веб-разработки
средства объектно-реляционного отображения
Model-View-Controller(архитектура модель-представление-контроллер)
RIA - rich(насыщенные) Internet application
python имеет расширение Silverlight
Silverlight
#инфраструктура, технология .NET
pyjs~pyjamas
#содержит компилятор в JavaScript, фреймворк AJAX и набор виджетов
Программирование для бд
    Облачные вычиления
        AppEngine
        #механизм, моделирует данные с помощью классов Python, масштабируем
    БД
        Реляционные
            Sybase
            Oracle
            Informix
            ODBC
            MySQL
            PostgreSQL
            SQLite
Python СОДЕРЖ переносимый API-интерфейс для доступа к SQL универсальный для разных бд(SqlAlchemy?) - обычно требуется лишь заменить лежащий в основе интерфейс поставшика
создать список истории изменений в Python:
    2.5+ содерж внутрипроцессный механизм бд SQL, SQLite поддерживающий прототипирование
pickle
#позволяет хранить obj в файлах и подобных файлам obj
ZODB
#система ОО бд
Durus
#система ОО бд
ОО - объектно ориентирован
SQLObject
#реализует средства ORM
SQLAclhemy
#реализует средства ORM
ORM - сопоставляет модель классов Python с реляционными таблицами(бд?)
PyMongo
#интерфейс к MongoDB
MongoDB - высокопроизводительная opensource документная бд в стиле JSON, не похожая на SQL, данные хранятся структурах похожих на списки/словари Python
json
#модуль, способен анализировать и создавать структуры MongoDB
#поддерживает сериализацию
#dict с вложенными структурами похож на JSON, многие структуры сохраняются почти без изменнеий и остаются допустимыми Python exp которые можно скормить exec()
#не умеет сохранять сложные obj вроде классов,set,модулей(походу умеет только в dict|list|str|int|float|bool|None),tuple => list
#транслирует obj в Unicode строки => в Python 2.X тип строк меняется на unicode
    .dumps(obj, skipkeys=False, ensure_ascii=True, check_circular = True, allow_nan=True,cls=None,indent=None, separators=None, default=None,sort_keys=False, **kw)
    #сериализация obj в json str
    #skipkeys=True => пропуск типов кроме str/int/float/bool/None вместо вызова TypeErr
    #ensure_ascii=False отключает проверку значений на наличие non-Ascii символов , символы преобрзуюстя в последовательности
    #separators принимет кортеж (item_separator,key_separator), по умолчанию "(', ', ': ')" при indent = None и "(',', ': ')" в иных случаях
    #indent - не отрицательный int определяющий тип вывода user-friendly или нет, 0 -(вставка только \n),None - наиболее компактная форма,число отступов(при 1-4 вполне комфортно)
indent - отступ?
    #sort_keys - сортировка словарей по ключу при выводе
        store = json.dumps(rec)
        res = json.loads(store)
        store == rec >> True
    #default, fx default(obj) возвращающая сериализованный obj или вызывающая TypeErr, по умолчанию вызывает TypeErr для неподдерживаемых obj
    #для использования пользовательского подкласса 'JSONEncoder' нужно указать его в cls kwargs, для обработки дополнительных типов
    .loads(string[, encoding=None,cls=None,object_hook=None, parse_float=None,parse_int=None,parse_constant=None, object_pairs_hook=None,**kw])
    #object_hook - необяз fx которая м.б. вызвана с результатом для ЛЮБОГО литерала с парами Ordered list
    #parse_float по умолчанию использует ~float(str) но может быть заменен для использования например с decimal.Decimal
    #parse_int ~ parse_float
    #encoding - ignored(deprecated)
    .load(fp, cls=None,object_hook=None,parse_float=None,parse_int=None,parse_constant=None,object_pairs_hook=None,**kw)
    #fp - obj содержащий метод .read();~.loads но пишет в файл вместо возврщения
    .dump(obj,fp,skipkeys,ensure_ascii=True,check_circular=True,allow_nan=True,cls=None,indent=None,separators=None,default=None,sort_keys=False,**kw)
    #fp - obj с методом .read();~dumps но с записью в файл
    .JSONDecoder
    #походу класс производящий декодирование
    .JSONEncoder
    #класс производящий кодирование
    .JSONDecodeError
    #класс обрабатывающий ошибки
Azure
#облачное хранение
PiCloud
#облачное хранение
Stackato
#облачное хранение
отступ = ограничитель блоков

инструментальный набор =? пакет =? lib

cgi
#модуль поддержки сценариев CGI в Python,позволяет извлекать информацию из форм отправленных сервреными cgi-сценариями(wsgi?)
    .FieldStorage()
    #Разбор данных формы, возвращает obj похожий на dict с записяи для всех полей ввода формы на клиентской веб-странице
    #интерфейс
    form = cgi.FieldStorage()

протокол SOAP?
HTMLGen
#система для генерации HTML-файлов из описаний на основе классов Python
mod_python
#запускает Python в Apache и поддерживает серверный механизм шаблонов с помощью Python Server Pages

кодовые шаблоны "первый,остальные","остальные,последний"
    a,*b = seq;'or';a,b = seq[0],seq[1:]
    *a,b = seq;'or';a,b = seq[:-1], seq[-1]
Интеграция компонентов
Python - может использоваться как язык управления(связующий/сценарный)(для сценарного описания других систем и компонентов), напр программирование настроек без необходимости перекомпилирования всей кодовой базы(или вообще необходимости в его исходниках)
SWIG
#инструмент генерирования кода, автоматизация связывания скомпилированных компонентов с Python
SIP
#инструмент генерирования кода, автоматизация связывания скомпилированных компонентов с Python
для Python компоненты написанные на Python и С/С++ эквивалентны(собственным? друг другу? вернуться)
Python хорош для прототипирования систем с последующим переносом критических компонентов на C/C++ для поставки
В отличие от ряда инструментов прототипирования Python не требует полного переписывания прототипа
численные процедуры Python написаны на компилируемом языке
инструменты численного программирования Python поддерживают анимацию, трехмерную визуализацию параллельную обработку etc
SciPy
#расширение содержащее библиотеки инструментов для научного программирования, основан на NumPy
#умеет хранить матрицы эффективнее вложенных списков
#кажется !~ ScientificPython
ScientificPython
#расширение содержащее библиотеки инструментов для научного программирования, основан на NumPy
#кажется !~ SciPY
pygame
#библиотека для создания игр
cgkit
#библиотека, (графика?)
pyglet
#библиотека, (мультимедиа)
PySoy
#библиотека, (мультимедиа)
Panda3D
#библиотека, (графика?)
PySerial
#библиотека для взаимодействия через последовательные порты Windows,Linux и других сред
pexpert
#поддержка интерактивных программ
PyOpenGL
#библиотека, походу для работы с OpenGL
Blender
#библиотека, походу для работы с Blender
Maya
#библиотека, походу для работы с Maya
Pillow
#библиотека для обработки изображений с помощью Pillow(PIL?)
#обработка меток содержимого медиафайлов и метаданных?
PIL - используется для обработки изображений
Pillow - ответвление PIL
PyRo
#инструментальный набор программирования контроллеров для роботов
NLTK
#пакет для обработки естественного языка
PyXLL
#создание fx/макросов Microsoft Excel
DataNitro
#создание fx/макросов Microsoft Excel
PyMedia
#обработка меток содержимого медиафайлов и метаданных
ID3
#обработка меток содержимого медиафайлов и метаданных
PyBrain
#библиотека нейронных сетей
Milk
#инструментальный набор машинного обучения
PyCLIPS
#программирование экспертных систем
Pyke
#программирование экспертных систем
Pyrolog
#программирование экспертных систем
pyDatalog
#программирование экспертных систем
zenoss
#система для мониторинга сети, написана и настраивается с помощью Python
PythonCAD
#проэктирование/моделирование
PythonOCC
#проэктирование/моделирование
FreeCAD
#проэктирование/моделирование
ReportLab
#обработка/генерация документов
Sphinx
#обработка/генерация документов
Cheetah
#обработка/генерация документов
PyPDF
#работа с pdf
Mayavi
#визуализация данных
VTK
#визуализация данных
VPython
#визуализация данных
xmlrpclib
#библиотека
Orange
#фреймворк для глубинного анализа данных
Pattern
#пакет
PySolFC
#программа для раскладывания пасьянса
конспект: конспект по каждому отдельному модулю в свой файл(хотя нахера?)
КАК PYTHON РАЗРАБАТЫВАЕТСЯ И ПОДДЕРЖИВАЕТСЯ
    PEP(Python Enchancement Proposal(предложения)) - содержит предложения обо всем
    #http://www.python.org/dev/peps/pep-0008
    #возможно стал слишком сложным/жестким/субъективным
    #часть его стандартов не приняты/не соблюдаются повсеместно, в ряде крупных компаний приняты собственные стандарты отличные от PEP => степень полезности PEP зависит от контекста, другая часть очевидно полезна эмпирическими знаниями о применении Python
        pep8 - систематизация стандартов кодирования библиотечного кода
ПРОЧИТАТЬ PEP!
    Расширение системы регрессионного тестирования Python
    PSF(Python Software Fondation) - оффициальная некоммерческая группа, организует конвенции Python, занимается вопросами интеллектуальной собственности
    конвенции Python
        OSCON - O'Reilly - множество opensource проэктов
        PyCon - PSF - Python only
opensource может быть хаотичным и даже анархичным, коммерческую выгоду заменяют личные предпочтения текущего круга разработчиков, другие разработчики становятся зависимы от тех у кого есть свободное время для изменения Python, OpenSource часто направляется немногими, но навязывается многим, менее актуально для людей сидящих на старых стабильных версиях
В Python 3.2.0 кажется не работает input() в windows
модель классов Python поддерживает полиморфизм, перегрузку операций, множественное наследование
Python прекрасно подходит как инструмент написания сценариев для других ооп яп, например можно создавать подклассы(специализировать) написанные на C++/Java/C#
C++ поддерживает процедурный и ооп режим
тактический режим разработки - стадии проэктирования отсутствуют
процедурная парадигма - основан на операторах(базовых)
операторы по идее = процедурные операторы, ? не процедурные операторы?
ооп - основан на классах
NS - namespace
выразительность ?= читабельность
границы между парадигмами слегка размыты
Icon
#яп
#способствовал появлению генераторов в Python
функциональная парадигма Python
#походу производство результатов по требованию а не сразу - то что Python позаимствовал у fx яп?
#fx автоматически применяющие к obj(iterable) другие fx
#инструменты применения и комбинирования fx
#предлагают сохранение состояния и кодовые решения альтернативные классам/ООП
#избавляют от написания некоторой логики, напр. map/filter|reduce|включения не требуют управление построением списка, и работают быстрее т.к. выполняют код C вместо байт-кода в PVM
    генераторы
    #типы
        exp
        fx
        пользовательские классы
            obj требующие мн-во активных проходов могут возвращать вместо себя экземпляры добавочного класса(видимо на вызов iter)
    #~генераторный obj~генератор результатов, obj поддерживающий протокол итерации(имееющий метод next)
    #генераторные fx появились до 2.2(раньше yield)
    #любая fx СОДЕРЖ yield - генераторная
    #генераторные fx компилируются(?) в obj поддерживающий протокол итерации, возвращают генератор при вызове(по сути то фабрика генераторов);возвращают obj поддерживающий next
    #генераторные fx универсальнее(будучи fx) встроеных генераторов и генераторных exp
    #fx может динамически выбирать схему работы: генерировать val по одному(возвращать на вызов генератор) или вернуть все val
    #генераторы не пишутся непосредственно Вместо этого пишется функция, возвращающая генератор при вызове. Это может показаться странным, но, поскольку "фабрика функций" является естественной возможностью Python, "фабрика генераторов" кажется ее очевидным концептуальным развитием. Благодаря наличию в теле функции одной или нескольких директив yield, она превращается в "фабрику функций". Если в теле кода встречается директива yield, оператор return может встречаться только без возвращаемого значения. Однако лучше составить тело функции так, чтобы исполнение просто "отваливалось с конца" после того, как все директивы yield будут выполнены. Но если встречается оператор return, то он заставляет созданный генератор вызвать исключение StopIteration, а не вернуть дальнейшие значения. 
        def f():
            for i in range(3):
                yield i
        f   >> <function f ...>
        f() >> <generator obj f ...>
    #заимстованы из других яп(особенно Icon)
    #в отличие от ряда встроенных типов нельзя иметь мн-во итераторов генератора поэтому(может наоборот?) итератор генератора он сам
        #имеется в виду это
        L = [1,2,3]
        I0 = iter(L)
        I1 = iter(L)
        I0 is I1    >> False
        #а изменения отражаются на итераторах
        next(I1)    >> 1
        del L[1:]
        next(I1)    >> StopIteration
        #разумеется iterable хранится в итераторе ссылкой
        L = 1,2,3
        I = iter(L)
        del(L)
        next(I)     >> 1
        #следовательно для многократного просмотра итератора(генератора)
            преобразовать в iterable
            создать несколько генераторов
            
    включения
    #свертка
    #лаконичнее из-за автоматической выдачи результатов(не требует предварительного создания коллекции и ее ручного наполнения)
    #концепция связанная с циклом for(оператором) и fx/fx-программированием, применяющаяя выражение к эл-там в iterable, синтаксис произошел из конструкции(выражение м-ва в предикатах) в сис-ме обозначений теории мн-в применяющей операцию к КАЖДОМУ эл-ту мн-ва, похож на перевернутый цикл for(for i in obj:i => i for i in obj)
    #в отличие от циклов создают отдельную NS
    #примеры
        #почти наоборот
        M = [list(range(1,10)[i:i+3]) for i in range(0, 9, 3)]  #[[1,2,3],[4,5,6],[7,8,9]]
        #итерация по строка здесь - внешний цикл
        [[-elt for elt in row] for row in M]    >> [[-1,-2,-3],[-4,-5,-6],[-7,-8,-9]]
        #группировка эл-тов во вложенных структурах
        M = [('a','b'),('c','d')];N = [('A','B'),('C','D')]
        [(*zip(M[i][j], N[i][j])) for i in (0,1) for j in (0,1)]
            >> SyntaxError: iterable unpacking cannot be used in comprehension
        [[*zip(M[i][j], N[i][j])] for i in (0,1) for j in (0,1)]
            >> [[('a', 'A')], [('b', 'B')], [('c', 'C')], [('d', 'D')]]
        [[(M[i][j], N[i][j]) for i in (0,1)] for j in (0,1)]
            >> [[('a', 'A'), ('c', 'C')], [('b', 'B'), ('d', 'D')]]
            #дополнительный пример(см. zip)
    замыкания
    #кажется довольно редко используется
    #изменение состояния - см. nonlocal
    #фабричная fx - паттерн проетирования - фабрика функций/классов/(etc?);замыкание областей видимости
       def outer():
           def inner():
		        pass
           return inner
       a = outer()
       a                >> <function outer.<locals>.inner at 0x03C352B8>
    #представляется как <function <внешняя fx>.<localNS>.<внутренняя fx>.<etc> at <adress>>
        def outer():
            def middle():
                def inner():
                    return 0
                return inner
            return middle
        a = outer()
        a                   >> <function outer.<locals>.middle at 0x03305588>
        b = a()
        b                   >> <function outer.<locals>.middle.<locals>.inner at 0x033055D0>
    #замыкание - методика fx программирования, предоставляет каждому вызову - локальное хранилище данных использующихся одиночной вложенной fx
    #поиск в enclosure работает даже if уже произошел возврат из объемлющей fx => внутренняя fx "помнит" значения из enclosure хотя объемлющая fx больше не активна и ее NS уже НЕСУЩ
    #fx создающая и возвращающая(но не вызывающая) ссылку на obj другой fx имеющий присоединенные пакеты данных из mem(сохраненные состояния) локальные для КАЖДОЙ созданной копии вложенных fx(самодостаточный пакет информации с уникальными именами)
    #obj из outer fx присоединяются к obj возвращемым inner
    #nonlocal var - данные с мн-вом копий для КАЖДОГО вызова видимые только внутри замыкания
        def outer():
            def inner():
                a = 1
            return inner
        f = outer()
        f.a         >> AttrErr
    #распространенный шаблон использования внутренних fx
    #внутренняя fx доступная снаружи посредством другого имени
    #позволяет получать доступ к замкнутым данным
        .__closure__
        #свойство хранящее лексический контекст fx(замыкания)
        #от enclosure
            def outer():
                z = 10
                def inner(x):
                    print(x+z)
                return inner
            test = outer()
            test(5) >> 15
            test.__closure__    >> (<cell at <adress>: <type> obj at <adress>>,) #кортеж
            list(test.__closure__[0]) >> 'cell' not iterable
            test.__closure__[0].cell_contents   >> 10
           .cell_contents
           #возвращает содержимое ячейки __closure__
    #альтернатива классам т.к. внутренняя fx выполняет действия над данными, а сохраненное состояние заменяет аттрибуты
    #иногда применяются для условной генерации обработчиков событий на лету
        #реагирование GUI в ответ на ввод юзером(который сложно предугадать) => требуется fx содержащая информацюи зависяющую от создаваемой fx
    #пример
                def maker(N):
                    def action(X):
                        return X ** N
                    return action
                exp2 = maker(2)
                print(exp2(10))         >> 100  #вызов замыкания
                #def + lambda
                    def maker(N):
                        return (lambda X: X**N)
                    exp2 = maker(2)
                    exp2(7)     >> 49
                #lambda + def
                lambda N:def action(X):X**N >> SyntaxErr
                #lambda
                #вложенная структура labda создает fx которая при вызове тоже создает fx
                maker = lambda N:lambda X: X**N
                exp2 = maker(2)
                exp(7)      >> 49
                #or
                ((lambda x: (lambda y: x + y))(99))(4)  >> 103
                (lambda x: lambda y: x+y)(99)(4)        >> 103
    def + class
    #вложенный class;фабрика классов и обеспечивает сохранение состояния для возвращаемого obj класса
    #val объемлющей fx сохраняются ссылками в классе или его методах
        #уебищный самописный пример
        def maker(*properties):
            class Actions():
                def __init__(self,values):
                    for p,v in properties,values:
                        exec('self.'+p+' ='+' v')
            return Actions
        CarClass = maker('color','weight')
        audi = CarClass(('red','5000kg'))
        audi.color                  >>  'weight'

    #стандартные val arg по умолчанию для передачи и запоминания obj в enclosure(альтернатива LEGB <2.2)
    #распространенный кодовый шаблон, устарел ввиду nonlocal
        def outer():
            x = 'nonlocal'
            def inner(x=x):
                print(x)
            inner()
        outer()
        #def + lambda
        def maker(N):
            exponent = (lambda X,N=N:X**N)
            return exponent
        exp2 = maker(2)
        exp(4)      >> 16
        #arg по умолчанию - опциональны
        exp(4,3)     >> 64
        #исключение:все еще используется для создания замыканий ссылающихся на разные Enclosure
fx обработчиков обратного вызова видимо fx выполняющиеся в ответ на некоторое действие/событие (возможно от callback(перезвон?))
в роли обратных вызовов часто используются объекты классов с .__call__ и привязки
        #ситуация может встречаться в коде генерирующем fx обработчиков обратного вызова(?) для виджетов в GUI(например обработчиков щелчков для ВСЕХ кнопок в строке) = > требутся сохранить состояние каждой отдельной кнопки, иначе они будут выполнять одно и тоже действие
            #в момент вызова outer создается ее NS в которой создается obj который (по идее) прикрепляется к замыканиям при выходе из outer( на который в последствии ссылаются fx при их вызове)
            #лутц - fx НЕСУЩ до вызова и они обращаются к последнему значению var на момент вызова(прикрепленные после выхода из outer)
                #например if объявление inner вложено в цикл и ссылается на var в enclosure изменяемую в этом цикле => ВСЕ сгенерированные fx будут ссылаться на один obj
                #p.s. дело не в циклах/изменяемости
                
                    #пример Лутц
                        def makeActions():
                            acts = []
                            for i in range(5):
                                acts.append(lambda x: i**x)
                            return acts
                        acts = makeActions()
                        acts[0](2),acts[1](2)   >> (16,16)
                    #упрощенный пример
                        def makeActions():
                            acts = []
                            i = 1
                            acts.append(lambda:i)
                            i = 2
                            acts.append(lambda:i)
                            return acts
                        acts = makeActions()
                        acts[0]() == acts[1]()      >> True
                    #def вместо lambda и изменение посредством явного присваения
                    def makeActions():
                        acts = []
                        for i in range(5)
                            def inner():
                                nonlocal i
                                print(i)
                                i += 1
                                acts.append(inner)
                        return acts
                    acts = makeActions()
                    acts[0](),acts[1]()     >> (4,5)
                    #переобъявление fx(c тем-же именем) работает аналогично
                    def makeActions():
                        acts = []
                        i = 0
                        def inner():
                            return i
                        acts.append(inner)
                        i = 1
                        def inner():
                            return i
                        acts.append(inner)
                        return acts
                    acts = makeActions()
                    acts[0]() == acts[1]()      >> True
                    #все еще одна NS
                    def f():
                        for i in range(2):
                            yield lambda: id(i)
                    acts = [*f()]
                    acts[0]() == acts[1]()      >> True
                #в ином случае можно использовать вызов outer несколько раз создавая независимые NS
                    def makeActions():
                        x = 0
                        def inner():
                            nonlocal x;x += 1
                            print(x)
                        return inner
                    a = makeActions()
                    b = makeActions()
                    a()             >> 1
                    a()             >> 2
                    b()             >> 1
                    #или использовать аргументы по умолчанию
                    #стандартные val - оцениваются при объявлении,а не вызове => каждая fx сохраняет собственное val
                    def makeActions():
                        acts = []
                        [acts.append(lambda i=i:i) for i in range(5)]
                        return acts
                    acts = makeActions()
                    acts[0](),acts[1]()         >> (0, 1)
        #второе исключение для передечи аргументов как стандартных
        #переопределение obj например с помощью замыкания с сохранением подсказки оригинала -> пример настройка open c помощью builtins
            import builtins
            def makeopen(id):
                original = builtins.open
                def custom(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None):
                    print('Custom open call %r:' % id , file)
                    #не знаю как вывести в print только те агрументы которые были действительно переданы?
                    return original(file=file,mode=mode,buffering=buffering, encoding=encoding,errors=errors,newline=newline,closefd=closefd,opener=opener)
                builtins.open = custom
            path = r'c:\users\mk\desktop\test.txt'
            makeopen('isID')
    #__get__
    #х.з. что делает?
        def outer():
            def inner():
                a = 1
            return inner
        g = outer()
        g.__get__('a')     >> <bound method outer.<locals>.inner of 'a'>
    #__name__
    #имя замыкания
        def outer():
            def inner():
                pass
            return inner
        g = outer()
        g.__name__      >> 'inner'
    
    
    отображения
    reduce/filter
    декораторы(т.к. организуют взаимодействие fx)
    #декораторы связаны с многоуровневым сохранением состояния
    #можно ли использовать декораторы к fx без return?->  да
    #принимают саму fx а не возвращаемое ей val
        хорошие примеры в конспекте любановича и на большом компе(да это хреновые примеры)
    #как блядь пользоваться декораторами?! - пока не доконца врубаюсь
        #случай реализации декоратора на классах и передачей в __init__ аргументов?
    лямбда fx
    obj функций первого класса(видимо речь о том что fx тоже obj)
    #первоклассная obj модель, вездесуща в Python, необходимая часть fx программирования - fx трактуются как данные
        echo = lambda msg: print(msg)
        schedule = [ (echo, 'Spam!'), (echo, 'Ham!') ]
        for (func, arg) in shedule: func(arg)
Декоратор не относится к ООП
    fx декораторов не похожа на наследование т.к. действует иначе
        базовая fx=>декоратор+декорированная fx
        базовый класс=> базовый класс + наследник
        #и полиморфизм не связан с ними явно
Tcl - opensource яп для написания сценариев
Scheme - сценарный яп
С,C++,Java  - яп для разработки систем
open source код позволяет делать с ним все что угодно - даже продавать его
функциональные инструменты могут быть альтернативой или дополнением ооп
    замыкания<=>классы
        классы
            обеспечивают более явное запоминание состояния постредством attr
            настройка наследованием и перегрузкой операций
            более естественно реализуют линии поведения с помощью методов
            могут быть избыточны например при часто встречающихся obj имеющих всего один-несколько attr(напр счетчик)
        замыкания
            проще => эффективнее если сохраниние состояния - единственная цель
            могут работать лучше в случае декораторов методов
BDFL(Benevolent Dictator for Life) - великодушный пожизненный диктатор Python - Гвидо ван Россум
Второй состав разработчиков Python - все кроме Гвидо
Python консервативен в отношении изменений
    измнения следуют формальной процедуре
стандартная реализация Python написана на переносимом ANSI C, и компилируется почти везде => Python переносимый
    Linux/Unix
    Win(современный)
    OSX,MacOS Classic
    BeOS,OS/2,VMS,QNX
    Системы реального времени(VxWorks)
    Суперкомпьютеры(Cray),IBM mainframe
    PalmOS,PocketPC
    Symbian,WinMobile
    игровые приставки,iPod
    IOS,Android
    etc.

Как и интерпритатор стандартная lib - максимально переносима
    <PythonDir>\Lib
Программы Python автоматически компилируются в байт-код выполняющийся на любой платформе с подходящей версией интерпритатора Python
Python содержат специфичные расширения для платформ(например поддежка COM для Win)
Python мощнее других сценарных яп и сравним с по функционалу с статическими яп
в Python нет явного объявления var
Автоматически управляет mem
    выделяет память под obj
    автоматический сборщик мусора - возвращает память если obj больше не используется(удаляется?)
Поддержка "программирования в большом" - инструменты для создания крупных сис-м вроде ооп
ооп/fx программирование могут применяться для настройки кода
конкатенация - объединение коллекций
замена эл-тов в коллекциях(изменяемых) - замена ссылок(по идее в один шаг,а не удаление->вставка)
нарезание - извлечение разделов
python еще и интерфейсный яп
python СОДЕРЖ C API
некоторые называют python исполняемым псевдокодом
многие сис-мы полагаются на то что пользователь может изучить Python достаточно для самостоятельной настройки продукта
наследие Monty Python
    традиционные имена для обобщенных(?) vars foo,bar => spam(тот прикол с консервами),eggs
    Brian,ni,shrubbery
    некоторые event на конференциях называют испанской инквизицией
Python мощнее Tcl или Visual Basic, библиотека прикладных инструментов обширнее
Python имеет простую согласованную структуру
Мощнее и универсальнее JS
Python читабельнее и распространенный чем Ruby
ООП в Python не обязательно
Python более зрелый и мощный чем Lua
Lua - встраиваемый, связуюйщий яп похож на Tcl
Smalltalk - экзотический яп
Lisp - экзотический яп
Prolog экзотический яп
Python использует модель выполнения на базе байт-кода
Python появился в начале 90х
На Python можно сделать все что можно сделать на perl но с лучшей читаемостью
Гвидо ван Россум математик => Python - ортогонален(?) и в высокой степени единообразен и согласован
Perl был создан лингвистом => Perl Близок к естественному языку, чувствителен к контексту, изменчив
Девиз Perl противоположен Python - есть более одного способа сделать это
Написание уникального/мудреного кода - гордость пользователей Perl- один из его недостатков
Python концентрируется на качесве кода
    pep
    синтаксическая модель
    единообразие кода
    согласованность fx средств
КАК PYTHON ВЫПОЛНЯЕТ ПРОГРАММЫ
способ запуска кода специфичен для платформы
интерпритатор = программынй пакет выполняющий другие программы, уровень программной логики между source code и оборудованием
установщик python содержит интерпритатор и библиотеку поддержки
интерпритатор Python в зависимости от способа применения - исполняемая программа или набор библиотек связанных с другой программой
интерпритатор мб реализован как
    программа C
    набор классов Java
    etc
думаю что не стоит использовать write вместо print и наоборот(общие рекомендации)
    print
    #вывод в консоль
    write
    #требует import sys для записи в поток вывода
    #запись в файлы, более переносим
конспект:записать print/file/потоки(sys) рядом
print([obj,...][,sep=' '][,end='\n'][,file=sys.stdout][,flush=False])
#flush
    3.3+
    немедленный сброс текста через поток вывода в любые ожидающие получатели, по умолчанию хранит данные в mem до принудительного сброса(обычно буферизация в mem определяется аргументом file(т.е. например if file=sys.stdout-> данные сбрасываются немедленно))
#file - obj имеющий метод .write(string), реализует автоматическое перенаправление потока, позволяет одиночному вызову print отправить текст в obj.write без постоянной переустановки sys.stdout
#получает текстовые представления obj форматирует их(sep,end) и выводит их в выходной поток имеющий метод .write(string) (интерфейс к стандартному выходному потоку sys.stdout), выходной эквивалент input()
    #можно например
        передать текст gui
        вывод HTML-страниц ответов в CGI-сценариях
        отправить текст нескольким получателям
        ...
    #чем-то напоминает мне утиную типизацию
    class FileFaker:
        def write(self, string):
            #do something
#может быть эмулирован sys.stdout.write()
    sys.stdout.write(str(x) + ' ' + str(y) + '\n') #~print(x,y)
#поддерживает перенаправление выходного потока на уровне shell (python file > out)
#не ключевое слово
#прочно связан с понятием потоков данных
#разумеется print(file=f,sep='',end='') ничего не выводит => не отправляет ничего в fileobj
#3.X fx(оператор выражения)но т.к. почти всегда выполняется на отдельной строке в виде оператора с выражением - трактуется как оператор; мощнее 2.X, синтаксис обычных fx - универсальнее, проще поддерживать чем 2.X(проще добавить arg чем дописывать синтаксис);реже требует создание строки перед выводом чем 2.X;эмулирует и совершенствует поддержку вывода 2.X
#2.x оператор со специфическим синтаксисом, не поддерживает изменение разделителей,чаще требует создания строки перед выводом, не считая flush и sep аналогичен 3.X
    print '%s%s' % (x,y)
    #хвостовая , подавляет \n (не синтаксис кортежей)
        print x, y,     #~ print(x, y, end='') 3.X
    #использует >> для указания потока вывода(замена file)
        print >> <fileobj>,x,y,    #~print(x,y,file=<fileobj>,end='')
fx != зарезервированное слово =? ключевое слово
зарезервированные слова ~ оператор
ЗАРЕЗЕРВИРОВАННЫЕ СЛОВА
#в CPython запрещено переопределение в качестве имен пользовательских obj(в отличие от имен во встроенной области видимости) => SyntaxErr
#не могут для каких-либо целей кроме obj которые они представляют(кривой перевод?)
#жестко вшиты в синтаксис и не могут использоваться кроме соответствующих контекстов
встроенная область видимости?
        True    False   None
            #True False None также ноходятся во встроенной области видимости(?) и являются именами которым присваиваются obj
            #в 3.X зарезервированны во всех отношениях(а в 2.X?)
        for     while   break   continue
        del
        and     or     not
        in      is
        return   yield(2.3+)   raise   pass
        with(2.6+(2.5+ idle?))    as(2.6+)
        import   from
        assert
        def     class   lambda
        try     except  finally
        global   nonlocal(3.X)
        if      elif    else
        print(2.X) exec(2.X)
импортируемые файлы вроде обязаны иметь расширение .py
структура исполняющей среды Python
    компиляция сценария в байт-код(или загрузка уже скомплированного файла в mem)
    отдает байт-код виртуальной машине
компиляция - шаг трансляции(translate), трансляция каждого оператора в набор инструкций байт-кода, разбивая операторы на шаги
трансляция происходит со скоростью выполнения
байт-код выполняется быстрее чем исходный код
байт-код  - low level платформо-независимое представление source code
т.е. по факту Python компилируемый
Если процесс Python имеет доступ на запись в каталог исполнения - он сохраняет .pyc файл в этом же каталоге(до 3.1);c 3.2+ в папке __pycache__, и имя включает версию python в которой были скомпилированны, занятно но я не вижу создание этого файла, вроде 2.7 этим промышляет, но версию в названии не указывает
Подкаталог __pycache__ сокращает колличество мусора попадающегося на глаза
новое соглашение об именовании файлов предотвращает переписывание байт-кода разными версиями Python, и возможно позволяет в будущем запустить байт-код в соответствующей вм
.pyc - python compiled, такие файлы вполне можно запустить без предварительной компиляции, банально открыв в python(это один из вариантов поставки программ)
модели файлов байт-кода могут варьироваться среди альтернативных реализаций python
после первого запуска файл байт-кода не удаляется, и при повторном запуске не перезаписывается(повторная компиляция не происходит) если не было изменений и не изменилась версия Python
Python автоматически сверяет timestamp исходника и байт-кода(а что если его отредактировать? или изменить байт-код?)
Версия сравнивается через магический номер версии в файле(3.2-) или имени файла(3.2+) (что будет если переименовать?)
<filename>.cpython-<versionXX>.pyc
если нет доступа на запись в текущий каталог - байт-код генерируется в mem и вроде удаляется после завершения
очевидно что в случае наличия доступа - файлы все равно генерется в mem и дублируются на диск для ускорения последующих запусков
Описанная схема выполнения программ Python характерна на момент написания книги и может измениться в следующих версиях
фиксированные(результирующие) bin файлы - вариант поставки Python программ
#альтернативная модель выполнения
#упакованные автономные исполняемые файлы ВЛКЮЧ интерпритатор(PVM) и байт-код и любые необходимые файлы поддержки, могут запускаться без отдельной установки Python !~ выходу(выхлопу) компилятора в машинный код, как правило мелкие программы имеют неадекватно большой размер(т.к. содержат PVM), т.к. хранят байт-код - более-менее скрывает его от получателя
#существует несколько вариаций
py2exe
#упаковка программ в exe, Windows only, широкая поддержка версий
#похож на PyInstaller
#совместим с tkinter,PMW,wxPython,PyGTK,pygame, клиентскими программами win32com,etc
PMW - ?
PyInstaller
#упаковка программ в фиксированные bin файлы, похожа на py2exe, работает с Windows,Linux,OSX, может генерировать самоустанавливающиеся(self-install) пакеты
py2app
#генерация автономных bin файлов для OSX
freeze
#первоначальная сис-ма генерации автономных bin файлов
cx_freeze
#межплатформенная система генерации автономных файлов с поддержкой Python 3.x
записать пример содержимого файла pyc
байт код сохраняется только для импортируемых файлов, но не для файлов верхнего уровня(выполняемых как сценарии)
сокращения:main - сценарий верхнего уровня
файл/сценарий верхнего уровня - аналог main из C++/Java, модуль
импортируемый файл - импортируется(и при необходимости компилируется) один раз за запуск программы
интерактивный интерпритатор не сохраняет байт-код(т.к. явно бессмысленно)
при нажатии ctrl-z/ctrl-d (win/linux) при выполнении операторов(например while/input) интерактивный интерпритатор генерирует исключение -> следует помещать такие блоки в try
PVM(Python Virtual Machine) - большой закодированный цикл выполняющий инструкции байт-кода
PVM - исполняющий механизм, последний шаг интерпритации
.pyc - Python специфичное представление
При трансляции в Python в отличие от например C/C++ отсутствует сборка(построение)
в процессе компиляции отсутствует начальная стадия, а исполняющий мехнизм(создание fx/классов, связывание модулей) работает прямо во время исполнения
двоичный код машинный код ~ машинный код
инструкции байт-кода длиннее процессорных + PVM => байт-код медленнее машинного
следствие модели выполнения Python - среда разработки = среда выполнения(это весьма относительно на мой взгля) - в C++ процесс тоже скрыт от меня - жмякнул F5 - получил результат
очевидно что мой уровень в компилируемых языках недостаточен для сравнения c python, вполне возможно что процесс сборки(линковки?)/компиляции менее автоматизированный чем я себе представляю
Python имеет динамичный характер - одни программы могут генерировать и запускать другие программы, что бывает весьма полезно
eval()
#принимают/выполняют str СОДЕРЖ python source code, может создать проблему безопасности
    eval('0x40') >> 64 #по идее медленнее int
    eval('a=1') >> SyntaxErr
    a = eval(1) >> a=1
#относительно медленна т.к. обязана скомпилировать и выполнить код
compile(source,filename,mode[,flags[,dont_inherit=False,optimize=-1]])
#предварительная компиляция исходного кода в <code object> содержащий байт-код для выполнения в exec/eval
#filename используется для сообщений об ошибках выполнения
#mode
    #'exec' компиляция в модуль
    #'single' компиляция в одиночное(интерактивное) состояние
    #'eval'  компиляция выражения
exec(source,globals=None,locals=globals,/) -> None
#source - str/compile() obj/Python statements
#globals - контекст, dict
#locals - контекст,mapping
#принимает/выполняет str/bytes СОДЕРЖ python source code, может создать проблему безопасности
#в отличие от eval() принимает строки содержание операторы не возвращающие значения, а не exp
    exec('list()')
#3.x fx
#2.x оператор со специфическим синтаксисом, совместим с 3.X - поддерживает скобки(видимо т.к. они опускаются в выражениях)
#почему-то не работает во включениях
    a = 1
    [exec(i) for i in ['a=1','b=2']] >> [None,None]
    a   >> 1
    b   >> NameErr:not defined
Python код способен изменяться на лету -> пользователи могут модифицировать его части на лету без потребности в source code и рекомпиляции -> хорошо подходит для настройки и связывания
РАЗНОВИДНОСТИ МОДЕЛЕЙ ВЫПОЛНЕНИЯ В АЛЬТЕРНАТИВНЫХ РЕАЛИЗАЦИЯХ PYTHON
CPython(основная)
#первоначальная(эталонная) реализация Python, входит в состав ActivePython, Enthought, предустановлена в большинстве Lunux/OS X дистрибутивов
#обычно быстрее, современнее, надежнее, полнее альтернативных реализаций
#снабжает компоненты на C/C++ сценариями Python
Python обычно ~ CPython
Cython
#site:cython.org
#гибридный яп Python/C, возможно менее быстрая, современная, надеждная, полная чем CPython, с меньшей пользовательской базой, и разработчиков
#основан на работе в рамках Pyrex
#код Python с возможностью вызова fx C, объявления типов C для vars, параметров, аттрибутов классов
#может компилироваться в код C где применяется API Python/C ,который затем можно скомпилировать полностью
#не полностью совместима со стандартной реализацией Python
#используется для построения оболочек для внешних lib C и создания расширений C для Python
Pyrex
#проект
Jython(Дубль)
#независимая(относительно конечно) реализация python
#язык сценариев для Java
site:http://jython.org
#компилирует sc для другой архитектуры времени выполнения(кривой перевод?) для обеспечения прямого доступа к компонентам Java, более завершенное решение по сравнению например с JPype, предоставляет полную реализацию python, менее быстрая, современная, надеждная, полная чем CPython, с меньшей пользовательской базой, и разработчиков
#состоит из классов Java компилирующий sc в java байт-код и передающий его jvm где то работает идентично скомпилированному Java коду
#цель - снабжение Java приложений сценариями Python
#интеграция Java с Python бесшовна
#Jython сценарии могут служить как веб-апплет, серверлет, строить gui на основе swing, etc
#позволяет использовать классы Java как Python, и наоборот
#разработана создателем IronPython
#частично меняет модель выполнения
IronPython(Дубль)
#независимая(относительно конечно) opensource реализация Python(частично меняет модель выполнения)
site:http://ironpython.net
#компилирует sc для другой архитектуры времени выполнения(кривой перевод?) для обеспечения прямого доступа к компонентам .NET, позволяет программам Python действовать как клиентские/серверные компоненты, использовать Silverlight,извлекать пользу от доступности .NET в и из остальных яп, более завершенное решение чем например Python for .NET, предоставляет полную реализацию Python, возможно менее быстрая, современная, надеждная, полная чем CPython, с меньшей пользовательской базой, и разработчиков
#была создана позже CPython/Jython
#создана создателем Jython,похож на Jython, разрабатывалась Microsoft
#имеет инструменты оптимизаци производительности

.NET ~ Microsoft .NET Framework
#платформа, СОДЕРЖ исполняющую сис-му C#, спроэктирована как уровень взаимодействия obj нейтральный к яп, наследник модели COM
COM
#фреймворк,модель, предшественник .NET
Mono - open source реализация .NET для linux
видимо альтернативные реализации python на других языках имеют теже преимущества что и CPython имеющий интеграцию c C, например Jython с Java
JPype
#система позволяющая стандартному коду CPython обращаться к компонентам Java
Python for .NET
#система позволяющая стандартному коду CPython обращаться к компонентам .NET
Stackless(дубль)
#усовершенствованная версия CPython, ориентирована на массовый параллелизм, не сохраняет состояние в стеке вызовов C=> облегчает перенос Python на архитектуры с малыми стеками, поощряет использование новаторских программных структур вроде сопрограмм
#добавляет микропотоки, лучшую структуру программ, более читабельный код, повышение продуктивности, используется CCP Games
#частично меняет модель выполнения
#site:stackless.com
микропотоки
#поддерижваются Stackless ,эффективная/леговесная альтернатива потоков/процессов
сопрограмма
#новаторская структура данных, возможно связана с параллелизмом
PyPy(дубль)
Shed Skin С++
#работает с программами с неявной статической типизацией
#инструмент оптимизации выполнения(одна из альтеративных моделей выполнения), транслятор Python->C++ который с помощью имеющегося C++ компилятора транслируется в машинный код,нейтральный к платформам подход к выполнению(платформонезависимый?), реализация Python, неявно статически типизированный
#конечно не явл нормальным Python кодом
#возможно быстрее Psyco-подобных расширений
#site:shedskin.github.io/
альтернативные реализации Python предназначены для специфических ролей/целей, но способный выполнять большинство ролей CPython
большинство программ(каких?) неявно-статически типизированы
sc -soure code
ActivePython
#дистрибутив основанный на CPython
Enthought
#дистрибутив основанный на CPython
.pyc код по идее работает в виртуальной машине аналогично Jython(как скомпилированный ANSI C код)
Parrot(Морковь?Перевод?)
#проект направленный на предоставление общего формата байт-кода, PVM и приемов оптимизации для различных яп ВКЛЮЧ python
#site:parrot.org
Unladen Swallow(перевод?)
#старый проект google стремившийся ускорить и повысить совместимость(с чем?) CPython 2.6 min в 5 раз добавлением JIT-компилятора, для замены C в различных контекстах;закрыт в 2011
НАСТРОЙКА РАБОЧЕГО КАТОЛОГА
ПУТИ ПОИСКА В СИС-МЕ
интернативный интерпритатор~итерактивная подсказка~интерактивная командная строка
можно запускать интерактивный интерпритатор из IDE
copyright
#возвращает copyright Python Software Fondation
credits
#возвращает краткие благодарности
ctrl-D выход из сеанса в терминале linux/закрыть окно wsl
cmd ~ консольное окно dos
ksh - консоль выполнения командной оболочки в linux, возможно имеет свой язык исполняемых сценариев, что-то вроде bash
csh - консоль выполнения командной оболочки в linux, возможно имеет свой язык исполняемых сценариев, что-то вроде bash
Cygwin
#предоставляет полную командную строку UNIX в win
расположение пользовательских программ в Linux /usr/local/bin | /usr/bin
py
#исполняющая программа(запускающий модуль) с консолью, поставляется с Python 3.3+, можно установить отдельно, оптимальный способ запуска под win
    py [option]...[-c cmd | -m mod|file| -] [arg] ...
    -N
    #Запуск последней N.X версии python
    #по возможности запускает x64
    -N-32
    #запуск посл N.X-32 версии python
    -N-64
    #принудительный запуск последней N.X.64bit версии
    -0 | --list
    #список доступных версий без путей
        py -0 >> Installed Pythons found by py Launcher for Windows
             >> -3.7-64 *
             >> ...
    -0p | --list-paths
    #список доступных версий Python c полными путями
    -b
    #issue warning about str(bytes_instance),str(bytearray_instance) and comparing bytes/bytearray with str. (-bb issue errors)
    -B
    #don't write .pyc files on import; also PYTHONDONTWRITEBYTECODE=x
    -c cmd
    #program passed in a string(terminates option list)
    -d
    #debug output from parser; also PYTHONDEBUG=x
    -E
    #ignore PYTHON* environement vars (such as PYTHONPATH)
    -h |--help
    #help
    -i
    #inspect interactively after running script;forces a prompt even if stdin does not appear to be a terminal; also PYTHONINSPECT=x
    -I
    #isolate Python from the user's env(implies -E -s)
    -m mod
    #run library module as a script(terminates option list)
    -O
    #remove assert and __dubug__-dependent statement; add .opt-2 before .pyc extension
    -q
    #don't print version and copyright msg on interactive startup
    -s
    #don't add user site dir to sys.path; also PYTHONNOUSERSITE
    -S
    #don't imply 'import site' on initialization
    -u
    #force the stdout and stderr streams(no stdin) to unbuffered;also PYTHONVERBOSE=x
    -v
    #verbose(trace import statements);also PYTHONVERBOSE=x, can be supplied multiple times to increase verbosity
    -V|--version
    #version;when given twice, print more about the build
        py -V   >> Python 3.7.0
        py -VV  >> Python 3.7.0 (v3.7.0:1bf9cc5093, Jun 27 2018, 04:59:51) [MSC v.1914 64 bit (AMD64)]

    -W arg
    #warning control:...
    #хз что
    -x
    #skip first line in sc, allowing use of non-Unix forms of #!cmd
    -X opt
    #set implimentation-specific option
    --check-hash-based-pycs always|default|never
    #control how Python invalidates hash-based .pyc files
    -
    #program read from stdin(default; interactive mode if a tty)
    Other env vars
    PYTHONSTARTUP
    #file executed on interactive startup(no default)
    PYTHONPATH
    #';' - separated list of dirs prefixed to the default module search path. The result is sys.path
    PYTHONHOME
    #alt <prefix> dir (or <prefix>;<exec_prefix>).The default module search path uses <prefix>\python{major}{minor}
    PYTHONCASEOK
    #ignore case in 'import' statements(win)
    PYTHONENCODING
    #Encoding[:errors] used for stdin/stdout/stderr
    PYTHONDEFAULTHANDLER
    #dump the Python traceback on fatal err
    PYTHONHASHSEED
    #=random - random val is used to seed the hashes of str,bytes,datetie obj;It can also be set an int[0,4294967295] to get hash vals with a predictable seed
    PYTHONMALLOC
    #set the Python mem allocators and/or install debug hooks on Python mem allocators
    #=debug : install debug hooks
    PYTHONCOERCECLOCALE
    #=0 - disable the locale coercion behavior
    #=warm - request display of locale coercion and locale compatibility warnings on stderr
    PYTHONBREAKPOINT
    #=0 disable the default debugger;It can be set callable of your debugger of choice
    PYTHONDEVMODE
    #enable devmode
установка версии Python по умолчанию для py.exe
    .../AppData/Local/py.ini
        ; This is an example of how a Python Launcher .ini file is structured.
        ; If you want to use it, copy it to py.ini and make your changes there,
        ; after removing this header comment.
        ; This file will be removed on launcher uninstallation and overwritten
        ; when the launcher is installed or upgraded, so don't edit this file
        ; as your changes will be lost.
        [defaults]
        ; Uncomment out the following line to have Python 3 be the default.
        ;python=3
        [commands]
        ; Put in any customised commands you want here, in the format
        ; that's shown in the example line. You only need quotes around the
        ; executable if the path has spaces in it.
        ; You can then use e.g. #!myprog as your shebang line in scripts, and
        ; the launcher would invoke e.g.
        ; "c:\Program Files\MyCustom.exe" -a -b -c myscript.py
        ;myprog="c:\Program Files\MyCustom.exe" -a -b -c
coercion - перевод?
behavior - перевод?
pyw
#исполняемая программа(запускающий модуль) без консоли, поставляется с Python 3.3 +, можно установить отдельно
в idle вполне можно играться с другими яп, например с Java через Jython
ведущий пробел - пробел в начале строки
при вводе многострочного выражения в IDLE приглашение последующих строк менятеся на отступ, а в коммандной строке/терминале - '...'
приглашения ввода вроде '>>>','>>>>','...' можно изменить(они доступны через sys)
sys
#в том числе позволяет изменить стандартные приглашения вроде '>>>'
#как-то используется по умолчанию, но у пользователя видимо нет доступа без импорта
    sys.getrecursionlimit()
    #zero args
    #получить глубину стека вызовов
    #стандартный Python ограничивает глубину стека вызовов для отлова ошибок INF рекурсии
        sys.getrecursionlimit() >> 1000
    sys.setrecursionlimit(number)
    #one args
    #устанавливает глубину стека вызовов - по умолчанию 1000(win)
    #максимум зависит от платформы
    sys.winver
    #только под win?
    #возвращает версию и битность интерпритатора
        sys.winver >> '3.5-32'
    sys.platform
    #строка содержащая имя платформы в виде строки
        sys.platform >> 'win32'
        sys.platform >> 'freebsd13'
    sys.path
    #список строк имен каталогов инициализированный содержимым var окружения(env var) PYTHONPATH+ набор стандартных каталогов
    sys.getrefcount(object)
    #one arg, возвращает int значение поля счетчика ссылок obj
    #возвращает не меньше 1 ссылки(должен же getrefcount как-то получать к нему доступ)
    #в cmd для случайных строк и чисел показывает Min 3 ссылки(на одну больше чем в idle)
    #в idle возвращает min 2 для случайных str|int
        sys.getrefcount(1) >> 1154 #используется python/idle/etc
    .argv
    #содержит переданные args shell начинающиеся с имени сценария
    .modules
    #dict доступных модулей, список очень куцый, не хватает модулей в текущем расположении, в 3.7 он сильно меньше чем например в 3.2
        sys.modules >> {... 'math': <module 'math' (built-in)>, 'pickle': <module 'pickle' from 'C:\\Program Files (x86)\\Python35-32\\lib\\pickle.py'>,...}
        type(sys.modules)         >> <class 'dict'>
        type(sys.modules['math'])   >> <class 'module'>
        #3.2
        len(sys.modules)    >> 55
        #3.7
        len(sys.modules)    >> 34
    #получение obj модуля
        #позволяет имитировать global без выполения кода модуля
        #иммпорт модуля без выполения(содержит не все модули => Видимо нужно расширить path или что-то в этом духе)
        glob = sys.modules(__name__)    >> получение obj текущего модуля
    СТАНДАРТНЫЕ ПОТОКИ
    #три подключения к данным создаваемые при запуске сценария
        .stdout
        #объект(интерфейс к) стандартного потока вывода в консоль, объект вывода по умолчнию для print,предварительно открытый fileobj
        #как-то связан с __stdout__(подробнее >> .__stdout__)
            sys.stdout  >> <idlelib.PyShell.PseudoOutputFile obj at <adress>>
            sys.__stdout__  >> <_io.TextIOWrapper name='<stdout>' mode='w' encoding='c866'>
походу кодировка win по умолчанию cp866
        #позволяет эмулированть print
        #объект в который по умолчанию отправляется текстовый вывод программы
        #обычно отображается на окно программы if не был перенаправлен
конвейер командной оболочки ос?
            #obj потоков похожи на файлы
            set(dir(sys.stdout)) - set(dir(open('test','w'))) >>
                _abc_cache_
                #
                __abstractmethods__
                #
                _abc_registry
                #
                _encoding
                #
                __module__
                #
                _abc_negative_cache
                #
                tags
                #
                _abc_negative_cache_version
                #
                shell
                #
        .__stdout__
        #в теории ссылается на исходное значение sys.stdout установленное при запуске программы
            #хотя что-то я не заметил(видимо это не разделяемая ссылка или что-то подобное, а нечто что используется иначе) => посмотреть в документации
                sys.__stdout__.write('hello') >> 5
                sys.stdout.write('hello') >> hello5

        .__stdin__
        #в теории, ссылается на исходное значение sys.stdin установленное при запуске программы
        .__stderr__
        #в теории, ссылается на исходное значение sys.stderr установленное при запуске программы
        .stdin
        #стандарный поток ввода
        #может быть переназначен ссылкой как и .stdout для перехвата ввода
        .stderr
        #стандартный поток ошибок
            print('This text is RED',file=sys.stderr)   >> This text is RED
      РУЧНОЕ ПЕРЕНАПРАВЛЕНИЕ ПОТОКА
        #процессе имеется только один модуль sys => переназначение этой var будет работать во всем процессе - это как-то слишком очевидно(если бы объектов sys было два - часть obj могли бы отправлять данные туда но это тупость конечно)
        #может быть удобен
            для перенаправления выводимых данных в программах использующих print
                import sys
                std_sdtout = sys.stdout           #сохранение исходного назначения вывода(для востановления в будущем)
                sys.stdout = open('log.txt','a') #ручное перенаправление; 'a' - добавление данных в конец файла
                print('hello',flush=True)              #перенаправление в log.txt,flush для немедленного сброса
                #or
                    #print('hello')
                    #sys.stdout.close()
                sys.stdout = std_stdout    #восстановление исходного потока
                #or использовать sys.__stdout__ (в теории)
            для перенаправления в obj отображающие текст в gui
            меняют его цвет
                IDE
        можно перенаправить поток в класс с пользовательским методом .write(str) произвольно обрабатывающем/перенаправляющим текст
        #можно присвоить sys.stdout любой obj, исключение будет сгенерированно только при попытке доступа
            sys.stdout = 1  >> None
            print()       >> AttributeError: 'int' obj has no attribute 'write'
        можно быть перенаправлять потоки ввода вывода в файл/конвейер командной оболочки ос
            python script.py < inputfile > outputfile
            python script.py | filterProgram    #вроде grep?
      АВТОМАТИЧЕСКОЕ ПЕРЕНАПРАВЛЕНИЕ ПОТОКА
      #см. print()
    .version
    #возвращает версию python
        sys.version >> '2.7.16 (v2.7.16:413a49145e, Mar  4 2019, 01:37:19) [MSC v.1500 64 bit (AMD64)]'
        if sys.version[0] == 2: input = raw_input
в интерактивном интерпритаторе обязательно разделение многострочных операторов пустой строкой
notepad++ ctrl-d дублирование текущей строки
ПЕРЕНАПРАВЛЕНИЕ потока ВВОДА/ВЫВОДА КОМАНДНОЙ ОБОЛОЧКИ
    $ <command> > <file> //Unix(-> OSX тоже) & Windows
    python script.py > output.txt // создает пустой файл output.txt в текущем каталоге т.к. Python пишет приглашение уже в своем сеансе, но ничего не возвращает
    dir -a > output.txt //сохраняет вывод в файл и ничего не выводит
перенаправление потока может быть полезно для логгирования или создания файлов, позволяет писать программы отслеживающие изменения в выводе других программ -> полезно например при тестировании
альтернатива перенаправления потока в ос на Python очевидно обладает большей переносимостью
python как и любая утилита командной строки поддерживает перенапраление потока, но это часть ос а не Python
===========================одно_и_тоже
исполняемые файлы можно запускать из cmd и Powershell без указания расширения .exe, даже if НЕСОДЕРЖ PATH
python 3.3+ сам прописывается в path
Windows как минимум с 7 открывает файл который она считает исполняемым(включая .py) из оболочки в ассоциированном приложении при наборе его имени(даже без расширения), не делает этого с файлами нестандартных расширений
    C:\test #открывает test.txt в ассоциированном редакторе
===========================
как импортировать модули не находящиеся в path/текущем каталоге?
СТРОКИ Unix стиля
ОСНОВЫ СЦЕНАРИЕВ UNIX
#!,(hash-bang(хэш-бэнг)директива позволяет указать версию Python для исполнения, кодировку, сделать файл sc исполняемым сценарием в lunux/Win7+,должна стоять первой
#для создания исполняемого сценария должна содержать путь к интерпритатору Python(думаю в это такой аналог ассоциаций), сценарию неоходимо дать права на выполнение chmod +x <filepath>
chmod
    chmod +x <filepath> #дает права на выполнение// думаю '+' это добавить, а вместо x может быть r|w
    или
    chmod 777 <filepath>
интересно, директива '#!' позволит открыть скажем txt в какой-нибудь программе кроме ассоциированной?
расширение файла сценария Unix не имеет значения
как сделать исполняемый сценарий в linux который автоматом открывается в shell по double clk и выводит print()?
путь к фс wsl
#C:\Users\mk\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs
путь к Python в wsl(из win)
#C:\Users\mk\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs\usr\bin\{python|python3|...} #думаю линь может смонтировать это путь и тоже получить доступ через него
из wsl
#/usr/bin/python3
заблочить ресурс по https -> узнать ip(через тот-же Python(socket.gethostbyname_ex()))-> заблочить через firewall/hosts
cmd
    fc
    #утилита сравнения файлов, есть гемор с кодировкой
    tracert
    #от Trace Route, возвращает список всех маршрутизаторов на пути к конечному узлу, посылает 3 пакета данных(вывод дублируется 3 раза)
    pathping
    #информативнее и медленнее tracert анализирует потери пакетов на маршруте
    ipconfig
        /flushdns #очистить кеш dns
    getmac
    #возвращает список mac адресов адаптеров
    nslookup
    #многофункциональна, возвращает адрес по имени
    netstat
    #настройка сети, по умолчанию возвращает список всех активных подключений
        -r #вывод таблицы маршрутизации
    netsh
    #от Network Shell, детальная настройка сетевых адаптеров, содержит контексты(маршрутизация, dhcp,диагностика)
        netsh wlan show drivers
        #вывод характеристик сетевых драйверов
shift-f10 контекстное меню
закрыть bash c клавы -> win-tab shift-f10 закрыть или exit
закрыть powershell
    выгрузить psreadline
    или
    notepad $PROFILE
        Set-PSReadlineKeyHandler Alt+F4 -ScriptBlock {
        (New-Object -ComObject WScript.Shell).SendKeys('%{F4}')
        }
conemu пиздатая альтернатива powershell, хотя cmd жрет очевидно меньше энергии
походу в win 10 при смене значка в ярлыке(по крайней мере на панели задач) меняется так-же значек в углу заголовка
размер буфера должен быть большим чтобы прокрутка wsl/cmd/powershell работала
ctrl-up/down    прокрутка в оболочке
переход в режим оболочки -> когда утилита подменяет собой оболочку(вроде python/diskpart)
ctrl-l перейти в адресную строку explorer.exe
в папку /usr/bin полно исполняемых файлов вида Python3.6 и куча инструментов связанных python -> СУЩ мн-во способов запуска различных версий интерпритатора
ТРЮК С ПОИСКОМ ПОСРЕДСТВОМ env в Unix
в некоторых unix системах можно избежать жесткого кодирования пути к интерпритатору(более переносимая схема)
#!/usr/bin/env python
env сама ищет python в каталог перечисленных в PATH(в большинстве оболочек) => при переносе мн-ва сценариев достаточно изменить только PATH
при условии что на всех системах env находится в одном месте
/usr/bin/env python3 ~ python3 ~ /usr/bin/python3
env, как и python может находиться в
    /usr/bin
    /bin/
    /sbin/
    etc
/usr/bin/env
#возвращает сведения об окружении
    LS_COLORS #список вида *.<расширение>=XX;XX...
    HOSTTYPE=X86_64
    LANG=C.UTF-8
    WSL_DISTRO_NAME=Ubuntu #видимо только в wsl
    USER=mk
    PWD=<текущая директория>
    HOME=<директория пользователя>
    NAME=<PC_name>
    XDG_DATA_DIRS=<какой то набор директорий>
    SHELL=/bin/bash #путь к оболочке
    TERM=xterm-256color #тип терминала
    SHLVL=1         #хз
    LOGNAME=mk      #логин?
    PATH=<содержимое PATH>
    ...
терминал!=оболочка
#! в Win
некоторое ПО под win понимает Unix-style комментарии
запускающий модуль в Python3.3+ умеет парсить Unix-style комментарии
    указывающие версию python в полной/частичной форме
    /usr/bin/python2
    /usr/bin/python3.5
    python3.7.4
    python3
    при отсутствии указанной версии -> Invalid version specification(если уж указали точную версию Python то наверное не спроста) - конечно такой файл можно запустить в имеющейся версии, например py -<version> file|python file
    приоритер аргумента py выше чем коментариев unix(что логично)
    шаблоны Unix, например
        /usr/bin/env
механизм разбора Unix-like комментариев в Win включается при запуске сценария из py(включая dblclk)
т.к. исполняемые сценарии в Win запускаются через py - не нуждаются в правах на выполнение
type
#программа оболочки
    #win:type <filepath>
        выводит содержимое файла
    #linux:type <args> <filepath0> <filepath1> ...
ЩЕЛЧКИ НА ЗНАЧКАХ ФАЙЛОВ
ОСНОВЫХ ЩЕЛЧКОВ НА ЗНАЧКАХ
ЩЕЛЧКИ НА ЗНАЧКАХ В WINDOWS
    ассоциации расширений файлов windows хранятся в реестре
    В Python 3.1- .py по умолчанию выполняются в python.exe в окне консоли, .pyw в pythonw.exe без консоли, файлы байт-кода выполняются аналогично
    В Python 3.2+ .py по умолчанию выполняются в py.exe, a .pyw в pyw.exe
ОБРАБОТКА ВЫВОДА PYTHON В WINDOWS
    Python по умолчанию генерирует всплывающее окно DOS обслуживающее in/out, и автоматом загрывает его при отсутствии потока ввода
    Лутц рекомендует использовать input() чтобы окно не закрывалось(только в данном контексте(win only, запуск по dblclk))

ЩЕЛЧКИ НА ЗНАЧКАХ OSX
    при щелчке на значке можно использовать PythonLauncher из папки MacPython|Python N.M
ЩЕЛЧКИ НА ЗНАЧКАХ UNIX
    зарегистрировать файлы .py в gui | ассоциировать MIME-тип редактированием конфигов | etc
input(prompt=None,/) -> str
    #читает строку из sys.stdin, вроде использует .readline() , не переводит строку
    #входной эквивалент print()
    #поддерживает перенаправление входного потока (python file.py < input.txt)
    #в Python 2.X выполняет ~ eval(raw_input())строки программного кода, err для пустой строки
в главе 10 input() применяется в интерактивном цикле
notepad++ выдает подсказки прямо как idle
raw_input()
#python 2.x ~ input() из python 3.x
#python 3.x отсутсвует
можно использовать pyw.exe для выключения wi-fi без консольного окна!
при возникновении ошибок окно программы запущенной по dblclk автоматически закрывается, это можно обойти используя try
ИСКЛЮЧЕНИЯ
#vars ПРИНАДЛЕЖ builtins
try
#запускает действие и перехватывает исключения для обработки и восстановление после исключений, логи можно писать в файл с помощью print
    try:
        print(x)
    except NameError as e:
        print(repr(e),type(e),sep='\n')  >> NameError("name 'x' is not defined",)\n<class 'NameError'>
#упрощает код т.к. не нужно предусматривать любой вид ошибки например типы не подходящих данных в пользовательском вводе
#требует except|finally иначе => SyntaxErr: unexpected EOF
#синтаксис
    try:
        <main code>
    except:
        #выполянется if исключения генерировались
        <код обработчика исключений>
    else:
        <выполянется если исключения не генерировались>
    while True:
        try:
            num = int(input)*2
        except:
            print('digits only!')
        else:
            print(num)
#можно использовать для проверки наличия эл-та в коллекции вроде dict.get()
except
#оператор
#2.5+ объединен с try
    ИСКЛЮЧЕНИЯ
        KeyError    отсутсвие ключа в (словаре?)
        SyntaxError
finally
#оператор
#2.5+ объединен с try(опционально?)
#финализация? кажется блок этого кода выполняется if код в try не вызвал exept
#try/finally кажется более старая альтернатива with/as
#нельзя возвращать val из finally => явная ошибка
    def f():
        try:
            return 1
        finally:
            return 0
    f()         >>  0
#
    try:
        f = open(path)
    finally:
        f.close()
исключения довольно затратная операция
#хотя в реальном коде отличие лишь в несколько процентов
      try_test = '''for i in string.printable:
                            try:
                                int(i)
                            except:
                                "error"'''
      if_test = '''for i in string.printable:
                            if i.isdigit():
                                int(i)
                            else:
                                "error"'''
      timeit.repeat(exept_test,'import string',number = 10000) >> 10.57
      timeit.repeat(if_test,'import string',number = 10000)   >> 0.723
импорт
#извлечение, затратная операция, доступа к содержимому модуля через его аттрибуты
#не требует(и по идее не разрешает) указание расширения, т.к. не имеет смысла(модули могут иметь расширение отличное от .py, например .pyc или модули C)
    поиск файла
    компиляция в байт-код
    сохранение байт-кода на диске
    исполнение его содержимого -> один из способов запуска файлов(пример __hello__, this) - вот как запускать файлы из idle!

программная архитектура Python основана на модели служб на основе модулей(программа состоит из модулей, которые импортируют другие модули)
по умолчанию сценарий работает однократно на процесс, даже если модуль изменен между импортами
    import __hello__ >> 'Hello world!'
    import __hello__ >> #ничего не возвращает
imp
#модуль
    .reload(<file>)
    #повторно импортирует уже импортированный модуль без перезапуска сеанса, и возвращает отображаемое представление модуля
    #встроенная fx в Python 2.5-
    #встроенная fx и fx модуля imp в Python 2.6,2.7 (для совместимости с 3.X)
    #интерпритатор ругается - DEPRECATED!(но не всегда - хз что)
        imp.reload(__hello__) >> ImportErr: not defined
        import __hello__
        imp.reload(__hello__) >> Hello world! <module '__hello__' (frozen)>
        imp.reload(this) >> ... <module 'this' from '<pathToModule>'>
        imp.reload(__builtins__) >> <module 'builtins' (built-in)> #повторный импорт модуля по умолчанию находящийся в globals() - просто возвращает его имя
в Python 3.X существовала(существует?) проблема: Загружаемые from имена не обновлялись напрямую reload, но имена доступные через import обновлялись
значение вызова = аргумент
ДОПОЛНИТЕЛЬНАЯ ИСТОРИЯ О МОДУЛЯХ:АТРИБУТЫ
модули
#библиотеки инструментов, пакет имен var's(атрибутов) = автономное пространство имен(один файл не видит имена другого до явного импорта)
#осуществляют пофайловое разделение var
атрибут
#имя var приклепленное к специфическому obj(вроде модуля)
модули/классы/fx/fileobj/экземпляры пользовательских классов/хз что еще поддерживают прикрепление attr(см. fx)
атрибуты можно использовать для создания методов уже СУЩ классов
    class List(list):pass
    List.r = lambda self:self.reverse()
    L = List([1,2])
    L.r();L         >> [2,1]
import, from, reload
#извлекают имена инструментов экспортируемых модулем извне, доступ к модулям
#имя модуля(без расширения) становится именем var
#~include C
from
#копирует attr модуля которые становятся var на принимающей стороне(генерация атрибутов)
    from <module|packet> import <obj> [as <name>][, <obj>][, <obj> as name] ...
#разумеется !~ import obj.obj т.к. это может быть не пакет модулей
модуль осуществляющий импорт - клиент файла
при импорте с указание расширения, импорт осуществляется,но с исключением
    ImportError: No module named '<module.py>':'<module>' is not a package
импорт вроде нельзя зациклить - кажется PYthon отслеживает obj которые уже были импортированы
    зато можно получать доступ к внутренним obj по имени модуля через другой импортированный модуль(что наркомания)
      #bad
        main.py
            import other
            print('main')
            a = 'var'
            try:
                print('main.a =',main.a)
            except:
                print('main.a not found')
            try:
                print('other.main.a =', other.main.a)
            except:
                print('other.main.a not found')
        other.py
            import main
            print('other')
        python main.py >>
            main
            main.a not found
            other.main.a not found
            other
            main
            main.a not found
            other.main.a = var
ПРАВИЛА ИМЕНОВАНИЯ VARS
    #имена файлов импортируемых(с помощью import|from) модулей(не main) подчиняются тем-же правилам именования что и obj
            import and  >> SyntaxErr
            import my-code  >> SyntaxErr
СОГЛАШЕНИЯ ИМЕНОВАНИЯ
    __x__
    #имена с ведущими и завершающими двойными подчеркиваниями, всегда предварительно определены в интерпритаторе
    #имена специфических инструментов для перегрузки операций в классах
    #явл реализацией obj, и предназначены для поддержки настройки(т.е. встроенные типы можно менять?=> можно созадавать свои и )
    #шаблон именования деталей реализации, системные имена имеющие особый смысл для интерпритатора
        __name__
        #содержит '__main__' или имя импортированого файла без расширения
        __package__
        #содержит None для main или пустую строку для импортированного файла
        __dict__
        #словарь с именами всех var и их val
        __weakref__
        #список слабых ссылок(if defined)
        __IDLE_eventloop_set
        #Sets up a callback fx for a GUI tookit
    #обеспечивают отсутствие конфликтов с пользовательскими attr
    __x
    #имена с ведущими двойными подчеркиваниями без завершающих двойных подчеркиваний локализованы для включения в себя классов(связаны с псевдозакрытыми(сокрытыми) атрибутами);неформально закрытая реализация
    #мне очевидно не следует лезть в эти атрибуты
    _
    #стандартная переменная только в интерактивном сеансе, инициализируется при первом выводе в интерактивном интерпритаторе и хранит результ последнего выражения
    имена классов с буквы в верхнем регистре
    имена модулей с буквы в нижнем регистре(очевидно не соблюдалось в 2.X)
    первый аргумент методов класса всегда называется self хотя не является зарезервированным словом
    подробнее -> pep8
    локализация - искажение
    _x
    #не импортируются from <module> import *
    #сокрытые имена модулей
    __r*__
    #3.x
    #правые методы начинающиеся с префикса 'r' вызываются для правого операнда когда для левого метод не определен
        a + b >> #if a.__add__(b) не определен => b.__radd__(a)
    func_
    #2.X некоторые детали реализации fx
именованные attr ?= attr не явл деталями реализации(не __x__)
предварительно определенные но не зарезервированные слова допускают повторное присваивание
#может быть полезно например для обеспечения обратной совместимости между версиями
псевдозакрытые attr - походу то соглашение из любановича(геттеры/сеттеры) когда к переменной как-бы нет доступа т.к. ее имя не известно(как бы)
имена файлов модулей регистрозависимы даже на ос с регистронезависимыми фс(символы разных регистров имеют разный код - фс очевидно различает их, но скрывает различия от пользователя)(для обеспечения переносимости)
отдельные(автономные) пространства имен модулей минимизируют конфликты имен
ПРОТОКОЛ ОБЪЯВЛЕНИЯ ФУКНЦИОНАЛЬНОЙ НЕЖЕЛАТЕЛЬНОСТИ К ИСПОЛЬЗОВАНИЮ
    изменения в зарезервированных словах поэтапно вносится в язык(кроме крупных выпусков вроде 3.0 ломающих совместимость со старым кодом)
        if новая fx возможность может нарушить работу СУЩ кода=> Python делает ее необязательной и выдает предупреждения о нежелательной к использованию(deprecated?) прежде чем возможность станет официально доступной, чтобы разработчики успели обновить код до перехода на новый выпуск
        #походу речь идет о компонентах которые заменяют собой другие(устаревшие компоненты)
            пример yield необязательное в 2.2 при использовании устаревших предшественников выдавалось предупреждение о функциональнсти нежелательной к использованию => стандартное ключевое слово 2.3
            with/as аналогично
from заменяет уже сущ obj c таким же именем(без предупреждения) -> некоторые рекомендуют всегда использовать import
ИСПОЛЬЗОВАНИЕ exec() для выполнения файлов модулей
exec()
    exec(open('filepath').read()) >> выполнение содержимого модуля ~ импорт модуля из произволного расположения, но целиком и без псевдонима. больше похож на include - втыкает код в место exec(), без предупреждения перезаписывает obj
python ищет модули в sys.path инициализированной PYTHONPATH + набор стандартных каталогов
execfile('<filepath>')
#В python 2.X ~ exec(open('<filepath>'))
интерфейс - способ доступа к содержимому(набор методов(операций))
#интерфейсы obj реализуются магическими методами
    socket
    fileobj
    потоки io
клиент
#кажется то/тот что/кто использует интерфейс
    #G - генератор
    next(G)     #запрос val объекта клиентом
IDLE
    #названа в честь участника Monty Python Eric Idle(Айдл), стандартный компонент OSX и Некоторых gnu/linux
    #написана на Python, использует tkinter/Tkinter для создания своих окон
    #сценарий <python>\Lib\idlelib\idle.py[pyw] | /usr/bin/
    "class browser"
        #позволяет просмотреть исходники модулей в path
    "path browser"
        #позволяет просматривать все модули в path
    расширенные операции поиска(?)
OSX может требовать обновления поддержки tkinter(например для запуска IDLE)
python -m idlelib.idle #запуск idle
запуск модуля расположенного в одном из расположений sys.path
    python -m
программы с gui на основе tkinter(т.к. tkinter получается вложенным) и многопоточные программы могут не корректно работать в IDLE
    вызов quit() в tkinter может привести к зависанию gui IDLE
    новые версии(какие?) IDLE запускают пользовательский код в процессе отдельном от gui IDLE что частично решает проблему
        т.к. работа IDLE осуществляется взаимодействием этих процессов -> в старых(каких?) версиях Pyhton возможны проблемы с запуском
            ошибка подключение(блокирование файерволом) => запуск с одим процессом
bat скрипты можно писать прямо в cmd
python -m script -n
#запуск в одном процессе
    python -m idlelib.idle -n
при запуске сценария в IDLE, IDLE переходит в его каталог
Eclipse
  #open-source IDE  для Java, поддерживает python через плагины(например PyDev)
Komodo
  #IDE компании ActiveState(activestate.com)
ActivePython
#дистибутивный пакет компании ActiveState
NetBEANS
#open-source IDE, поддерживает CPython/Jython
IDE могут ВКЛЮЧ отладку re, рефакторинг, покрытие кода, тестирование etc
PythonWin
#free Python IDE(win only) IDLE like включена в ActivePython, имеет поддержку COM-obj
Wing IDE
#поддерживает Python
Visual Studio
#поддерживает Python через плагин
PyScripter
#python ide
Pyshield
#python ide
Spyder
#IDE
Emacs
#текстовый редактор, ВКЛЮЧ поддерку Python
Vim
#текстовый редактор, ВКЛЮЧ поддерку Python
ВСТРАИВАНИЕ ВЫЗОВОВ
встроенная программа Python - запускаемая из другой программы, обычно применяются для возможности настройки у конечного пользователя
//вызов функции Python API из C
    //внедрение Python путем связываения его lib
    #include <Python.h>
    ...
    Py_Initialize();
    PyRun_SimpleString("x = 'brave' + 'sir robin'")
Python скрипты можно запускать через WIN+R
В Windows/OSX можно запускать сценарии Python перетаскиванием файла на интерпритатор


способы отладки
    втыкание print() чтобы понять где возникает ошибка
    pdb
    #стандартный shell-отладчик Python
    #исполнение кода построчно, с использованием breakpoints, может быть запущен как main|импортирован|как сценарий python -m pdb
        .pm()
        #информация об исключении
    как использовать pdb?
    python -i file.py
    #входит в режим интерактивного интерпритатора, где после возникновения исключения можно простотреть состояние пространства имен, или импортировать pdb
    Winpdb
    #автономный cross-platform отладчик СОДЕРЖ gui
исключения - механизм протоколирования и обработки ошибок
отладка = трассировка кода
тип данных - объект явл субъектом программ
способы запуска модулей(повтор)
    импорт
    перезагрузка
    IDE
        IDLE
    cmd
    команда выполнить(должна быть ассоциация как и в случае например щелчков)
    exec
    из других яп
    щелчок
    перетаскивание на интерпритатор(не работает с IDLE)
    #!unix
    авнономные фиксированные файлы
в Unix можно установить PATH в файле .cshrc|.kshrc чтобы сделать Python доступным постоянно
по идее python -m file.py ~ python file.py -m т.е. args можно указывать после файла
__file__
#var автоматически создающаяся при запуске скрипта из файла, строка содержащая путь к main файлу
по идее после удаления файла модуля он все еще доступен для импорта if сущ его скомпилированная версия в __pycache__, но у меня что-то не вышло
при запуске кода с ошибкой без ручного использования механизма обрабоки исключений - запускается стандартный обработчки исключений который принудительно останавливает выполнение программы и выводит сообщения об ошибке вместе с трассировкой стека
трассировка стека
#показывает место возникновения исключения и if вызовы fx активны во время возникновения ошибки - все уровни активных вызовов(wtf?)
#вот откуда Traceback(most recent call last)
python СОДЕРЖ полно-fx отладчик для особых требований к обнаружению ошибок
логика = алгоритм
ЦИКЛИЧЕСКИ ЗАКОЛЬЦОВАННЫЕ obj
    #могут быть полезны
    #требуют написание кода для их специальной обработки
    #требуют особой обработки сборщиком мусора, т.к. счетчик ссылок никода не 0
    l = [1,2] #l - именованная ссылка на obj [1,2]
    l.append(l) #добавляем ссылку l на начало [1,2] в конец [1,2](этого можно избежать с помощью .copy())
    l >> [1,2,[...]] #интерпритатор отслеживает циклические obj и выводит из особым образом
    l[2] >> [1,2,[...]]
    l[2][2] >> [1,2,[...]]
    #Python 1.5.0- не отслеживает циклические obj
    l >> [1,2,[1,2,[1,2....#бесконечный вывод до принудительного завершения
    ...
    #закольцованный obj можно создать присваиванием атрибутов объектво созданных из пользовательских классов
    l0,l1 = [1],[2]
    l0.append(l1),l1.append(l0) >> (None,None)
    l0,l1 >> ([1,[2,[...]]],[2,[1,[...]]])
экземпляр = obj созданный из класса
изменение на месте - изменение исходного obj
сортировка многократно разбивает/собирает {xn}
список - массив ссылок(0+) на obj с набором методов
    #работает почти также быстро как массивы C
    #основан на массивах C, по факту - не связанная структура
    связанные структуры?
    <list>.append(obj) -> None
    #присоединяет к концу массива дополнительную ссылку на еще один obj
    #'заталкивание в стек'
    <list>.count(val)
    #колличество включений val в <list>
    <list>.pop()
    #удаление и возвращение эл-та, по умолчанию -1(выталкивание из стека)
    <list>.extend(<iterable>) -> None
    #проходит по итерируемому obj и добавляет его ссылки в конец <list>
    <list>.sort()
    #str сортируется(сравнивается) по Unicode коду=> Буквы в верхнем регистре имеют меньший код 'Я' раньше 'а'
    #использует timsort старающийся извлечь преимущество из частичтной упорядоченности эл-тов.Создан Tim Peters
        #key - fx обрабатывающая эл-ты перед сортировкой(временно - не влияет на эл-ты)
            <list>.sort(key=str.casefold)
            ~
            list(map(str.casefold,<list>)).sort()
            ~
            sorted([x.casefold for x in <list>]) #результат содержит измененные эл-ты
            #последовательность сортировки(список символов по коду)
                list(map(chr,range(ord('A'),ord('я')+1)))
        #3.x
        <list>.sort(key=None,reverse=False)
        #больше не умеет принимать внешнюю fx для произвольной сортировки
            альтернатива - использовать key для предварительной обрабоки - например сравнивать obj и добавлять им эл-ты или менять так чтобы сортировка прокатила, а затем обрабатывать их снова для удаления изменений -> но это крайне переусложненно -> лучше воспользоваться альтернативами(например сторонними модулями)
        #2.X
        <list>.sort(cmp=None, key=None,reverse=False)
        #ключевой аргумент cmp принимает fx аналогичную по поведению стандартной fx cmp - if x<y возвращает -1, x==y -> 0, x>y -> 1
            #пример - sort всегда инвертирует список
            def rev():
                return -1
            l.sort(key=rev)

    "аргумент key метода list.sort может быть полезен при сортировке списков словарей для выбора ключа сортировки путем индексирования КАЖДОГО dict"(? стр.275)
ключевые аргументы обычно не передаются как позиционные(всегда?)
    #даже if всегда, это можно обойти принимая все подряд и обрабатывая внутри fx
ключевой аргумент = именованный аргумент = аргумент ключевых слов = аргументы ключевые слова = ключевое слово в аргументах fx
#ключевое слово - синтаксически вводит exp

именованная ссылка ~? имя
obj ~ значение
присвоение в python всегда генерирует ссылки на obj
присвоение = установка var в ссылку на obj = установка var в obj(значение)
можно думать об obj как об участках mem, а о ссылках как об указателях неявно отслеживающие участки mem
циклические obj должны особым образом обрабатываться сборщиком мусора, иначе занимаемое ими пространство остается невозвращенным обратно
    возможно потому что сборщик не удаляет ссылку которая используется другим obj(в данном случае им самим)
    в некоторых случаях при обходе произвольных obj/структур требуется обнаруживать цикличные obj самостоятельно(пример?)
возможно стоит заменить все слова "библиотека" на "пакет", т.к. библиотека это по идее пакет модулей
ТИПЫ И ОПЕРАЦИИ
ВВЕДЕНИЕ В ТИПЫ OBJ PYTHON
разные типы можно смешивать в выражениях дополненного присваивания(т.к. они отображаются на методы(по крайней мере часть из них)
Операции в python выполняются с помощью Obj
obj - область памяти со значением и связанными операциями ~ структура данных для предоставления реальных obj в конкретной предменой области
    Встроенные
    UserDefinedClasses
    obj созданные с помощью внешних яп
Концептуальная иерархия Python
Программы(пакеты) состоят из модулей(файлов)
    модули содержат операторы(этими модулями управляют другие операторы)
    операторы содержат выражения
    выражния создают/обрабатывают obj(нужны для управления Obj)
        #скорее наоборот выражения содержат операторы которые управляют Obj!! (видимо под оператором понимается for, etc)
3 принципа программирования
    очередность(послед выполнение)
    выбор(if|else)
    повторение
        многие концепции Python содержат оба принципа - включения(повторение и выбор) другие концепции вообще не вписываются
        основа Python - ооп - obj и то что с ними можно делать
в C/C++ большая часть работы сконцентрирована на реализации obj
    планирование структур в mem
    управление выделения mem/сборка мусора
    создание процедур поиска/доступа/etc
python включает мощные типы obj -> почти никогда нет смысла писать собственные типы, если не требуется специальная обработка которую не могут обеспечить встроенные решения
    встроенные obj - компоненты расширений(расширения основаны на базовых типах)
    встроенные obj обычно эффективнее специальных структур
    встроенные obj стандарт
LISP
#опирается на встроенные инструменты
С++
    #полагается на то что реализации obj предоставит разработчик
    ручное управление mem
        сборка мусора
пользовательские структуры данных могут затруднить сопровождение и совместимость
специальная структура данных = не базовый obj
при условии высочайшей квалификации возможно создать пользовательские obj с эффективностью аналогичной базовым
для некоторых задач может потребоваться создать собственные obj
пользовательские obj могут быть основаны на классах Python|интерфейсах языка C
стек
#структура данных, может быть реализована как класс управляющий списком
['key'][0][... цепочка индексов
неупорядоченные hashable коллекции поддерживают быстрый поиск по ключу(индексу) за счет переупорядочивания данных в mem
порядок в неупорядоченных коллециях основан на внутренней реализации сруктур данных и скрыт от пользователя языка, не поддерживают устойчивого порядка,разные fx выводят по разному например print|pprint, хотя например при выводе одним способом порядок обычно сохраняется
ГЕНЕРАЦИЯ В BUILTINS OBJ
    типы СОДЕРЖ итераторы, которые возвращаются __iter__
    #builtin iterable привязаны к специфическому виду генерации val
        dict по ключам
        file по строкам
        ...
d['a'] = 1 #динамическое присвоение по ключам
d(a=1)    #ключи требуют str, короче=> популярна
dict = поисковая таблица
    #по сути таблица хеш:Значение
        при совпадении хеша происходит сравнение на равенство
            хеш таблица отсортирована
                получаем val считаем его hash
                    сразу переходим на эту позицию без сравнения со всеми val
        хеширование заменяет поиск перебором на переход по индексу(адресу)
    #также конструктор/класс
    #предоставляет производительность среднего случая O(1)
    #не поддерживают операции на мн-вах без преобразований(кроме операций сравнения по абсолютной величине в 2.X)
    #сравниваются по парам key:val
    #2.X
        {'a':0,'b':1} > {'c':2} >> True
        {'a':0,'b':1} < {'c':2,'d':3} >> True
    #~записям/ассоциированным массивам/хешам в некоторых других яп, могут заменять алгоритмы поиска/структуры даннных которые реализуются вручную в более низкоуровневых яп
    #самый короткий способ записи с str ключами(+сразу видно что dict,а не set) => меньше символов -> меньше очепяток -> быстрее прогресс
        dict(name=dict(first='Bob', last='Smith'), job=['dev', 'mgr'], age=30.1)
        ~
        {'name': {'last': 'Smith', 'first': 'Bob'}, 'job'=['dev', 'mgr'], 'age'=30.1}
        #dict/zip(2.2+) нихрена не короче и не сказать что читабельнее, как и создание в цикле, но очевидно полезен при динамической генерации
        dict(zip((['name','job','age'],[{'last': 'Smith', 'first': 'Bob'},['dev','mgr'],30.1])
    #менее эффективны для хранения записей чем классы которые так-же обозначают поля именами + содержат логику обработки данных записи
    #хеш таблица ссылок на obj(обеспечивает быстрое извлечение)
    #хеширование - поиск ключей(операции с ключами?)
    #3.X
        включения dict 3.X 2.7(backports)
        из-за возвращения итерируемых dict_keys[_values,_items] требуют дополнительной обрабоки в некоторых случаях ~ viev<keys|values|items> в 2.7
        больше не поддерживают сравнение напрямую(кроме ==, !=)
        #убрано т.к. влекут слишком большие накладные расходы, даже при проверке на равенство
            #сравнение словарей похожее на 2.X, неэффективно => есть способы получше(алгоримты?)
            sorted(d0.items()) < sorted(d1.items())
        #использует оптимизированную схему проверки на равенство(какую?)
    #определяет итераторы ключей и явл iterable с некоторой версии(какой?)
    #используют быстрый прямой поиск т.е. имея ключ можно найти значения не перерывая весь словарь O(1)
    #можно ссылаться на obj вложенных коллекций используя цепочку индексов
        может быть более эффективен для хранения разряженных(почти пустых) структур данных(напр матриц) чем вложенный список
        3.X списки ключей словаря - obj _представлений_ поддерживающие линии поведения схожие set (пересечение/объединение)
        dict похожий на список
            dict(enumerate('abc'))[0] >> 'a'
        кажется с CPython 3.6/PyPy 3.6/3.7 dict - orderable - порядок согласно времени добавления(ВКЛЮЧ литеральные выражения)
        #отслеживание позиции при обходе циклических структур(напр графов) - отслеживание посещееных эл-тов для избежания входа в цикл(менее(или более) понятная альтернатива set)
                #транзитивная перегрузка модулей
                    list не эффективен т.к. поиск требует прямолинейногопросмотра
                    глава 25
                #вывод деревьев наследования
                    глава 31
        множественное ветвление с использованием fx для реализации обобщенных таблиц переходов
        #координирующая таблица
            #довольно специфичный сценарий - if/else почти всегда лучше(см.switch)
            def function():
                ...
            def default():
                ...
            d = dict(<key0>:lambda: ...,<key1>:function,...)
            #вызов fx в зависимости от значения var
            d.get(choice,default)() #choice - строковый ключ поиска
            #в случае предварительного объявления fx можно избавиться от словаря используя eval() (со всеми ее недостатками)
                def f1():...
                def f2():...
                key = 'f1'
                eval(key)()
                #or
                eval(key+'()')
        #таблицы переходов используются диспетчеризацией(?) полиморфных методов: вызов метода выполняет необходимое действие в зависимости от типа obj
обобщенные таблицы переходов?
  СЛОВАРНЫЕ ПРЕДСТАВЛЕНИЯ
  #3.x+,2.7+
  #возвращают iterableObj а не итератор, не поддерживающий индексацию(даже values)
    K = {}.keys()
    K is iter(K)    >> False
  #порядок тот-же что и у словоря и возвращают по одному значению за раз, для индексации можно использовать list()
  #выражения со словарными представлениями возвращают мн-ва/мн-ва ВКЛЮЧАЮЩИЕ кортежи
  #отражают изменения словаря - не хранят значения в новом obj а (по всей видимости) ссылаются на исходный dict(обновляются при изменении исходного obj)(по идее это должно слегка сказываться на производительности) => они реально возвращают по одному значению за раз
  #продолжают хранить значения при удалении исходного словаря
        d = {'a':1}
        k,v,i = d.keys(),d.values(),d.items()
        d['b'] = 2
        del d
        k,v,i >> dict_keys(['a','b']),dict_values([1,2]),dict_items([('a',1),('b',2])
    dict_keys
    #поддерживает оперции мн-в и смешивание с dict(~dict_keys)/set/другими представлениями|собой в exp
    dict_items
    #поддерживает операции мн-в(only if hashable) и смешивание с dict(~dict_keys)/set/другими представлениями/собой
    dict_values
    #поддерживает операции мн-в(only if hashable) и смешивание с set/другими представлениями
    #не поддерживает смешивание с dict/собой
        d = {'a':0}
        k,v,i = d.keys().d.values(),d.items()
        k | d >> {'a'}
        d | k >> {'a'}
        v | d >> TypeErr
        i | d >> {('a',0),'a'}
        d['b'] = []
        i | d >> TypeErr: unhashable type: 'list'
        v | k >> TypeErr: unhashable type: 'list'
    <dict>.fromkeys(<iterable>[,<default>=None])
    #создание словаря из списка ключей со значением по умолчанию
    #{k:<default> for k in <iterable>}
    <dict>.setdefault(<key>[,<default>])
    #возвращение значение по ключу, if ключа нет -> создание <key>:<default> и возвращение <default>
    <dict>.get(<key>[,<default>=None])
    #извлечение по ключу, if ключа нет -> вернуть стандартное значение
    #?быстрее in
    <dict>.pop(<key>[,default])
    #pop при наличии ключа, иначе возвращает default или KeyError
    <dict>.popitem()
    #возвращает (key:val)KeyErr if <dict> пуст
    #(вроде dict упорядочен с какой-то версии python) => вырезает эл-ты с начала в порядке в котором выводится(по крайней мере на этом примере)
    #если есть раньше то наверное выводит произвольную пару
        d >> {'a':0,'d':3,'b':1,'z':7}
        [d.popitem() for i in range(len(d))] >> [('a',0),('b',1),('d',3),('z',7)]
    <dict>.viewitems()
    #2.x ~ <dict>.items() ,словарное представление
    #3.x отсутствует
    <dict>.viewkeys()
    #2.x ~ <dict>.keys(), словарное представление
    #3.x отсутствует
    <dict>.viewvalues()
    #2.x ~ <dict>.values()
    #3.x отсутствует
    <dict>.keys()
    #2.x возвращает простой список(не dict_keys(...))
    #3.x возвращает iterableObj, словарное представление
    <dict>.values()
    #2.X возвращает простой список(не dict_values(...))
    #3.x возвращает iterableObj,словарное представление
    <dict>.items()
    #2.x возвраащет простой список кортежей(не dict_items(...))
    #3.x возвращает iterableObj,словарное представление
    индексация по значению в словаре(подходит только при редком использовании т.к. медленно)
        #может возвращать мн-во ключей на значение, а значение может быть коллекцией
        [key for key,val in <dict>.items() if val == ...]
        #более обобщенно(нравится мне даже немного больше)
        [key for key in <dict>.keys() if <dict>[key] == ...]
    ИСПОЛЬЗОВАНИЕ
        иммитация гибких списков(int ключи)
        #для хранения разряженных структур данных
        #без выделения памяти под все(пустые) значения и возможностью создания эл-тов присвоением
        #не сущ ключи обрабатывать через .get|in
        #думаю такой тип уже реализован в какой-нибудь либе
        #или можно переопределить метод перегружающий [] своим классом с полной заменой стандартного list(но звучит это крайне бессмысленно)
            film_list = {}
            film_list[1975] = 'Holy Grail'
        ключи-кортежи для разряженных структур данных
            #матрица с трехмерными координатами(куб из ячеек)
                #представление плотности в разных точках 3х мерного obj
                m = {}
                m[(2,3,4)],m[(2,3,7)] = 99,97
        хранение именованных записей
            bob = dict(name='Bob',age=40.5,jobs=['dev','mgr'])
            bob['name'],bob['jobs']
            json
        ~сторонним отображениям
            shelve
            dbm

        хранение данных нуждающихся в быстром поиске
        ОБРАБОТКА ОТСУТСТВУЮЩИХ КЛЮЧЕЙ
            #.get
                def n(d,k):
                    d[k] = 0
                    return d[k]
                d.get(k,n(d,k)) >> 0
            #.get + lambda(бредовый вариант который возвращает fx вместо значения)
                d.get(k,lambda k: d.update({k:0})
            #defaultdict
            #перенести эту часть в collections а здесь просто оставить ссылку
            m = collections.defaultdict(lambda: 0,{})
            m = collections.defaultdict(int,{})
            #fx + if/else(может это и можно доработать, но на мой взгляд выглядит довольно уебищно)
            def n(elt):
                if elt in Matrix:
                    print(Matrix[elt])
                else:
                    print(0)
            n(...)
            #defaultdict + defaultfactory
            m = collections.defaultdict()
            m.default_factory = lambda: 1
            #user class + defaultdict(на мой взгляд просто, гибко понятно)
            class DD(collectins.defaultdict):
                def __missing__(self,key):
                    self[key] = val
                    return val
            #try/except
            try:
                print(matrix[elt])
            except KeyError:
                print(0)
lambda-исчисления
#форма символической логики
lambda <args>: expression
    lambda a,b:a*b
    lambda: 1
    lambda: pass        >> SyntaxErr
    lambda:...          >> Ok
#синтаксис передачи args ~ def
f = lambda pargs,...,sargs=val,...,[*args|*],...,name,...,sname=val,...,**kwargs: ...
f(pargs,kargs,*args,**kwargs)
    #стандартные val
    func = lambda a='fee', b='fie', c='foe': a + b + c
    func(a='woe')     >> 'woefiefoe'
#создает fx с локальной NS и возвращает ее
#вроде не поддерживает декорирование(?проверить), синтаксис аннотирования, полные операторы(без костылей)
    #аннотирование
    lambda a:'fii':1    >> SyntaxErr
    #могут использоваться как декораторы
    decorator = lambda func: lambda: 'decorated'
    @decorator
    def func():'notdecorated'
    func()          >> 'decorated'
    #не могут быть декорированы т.к. не многострочный оператор, а exp
    @decorator
    func = lambda: 'notdecorated'     >> SyntaxErr
    #большинство составных операторов имеют ~ exp
        #циклы
            включения
                showall = lambda x: [sys.stdout.write(line) for line in x]
                t = showall(['first ','second'])    >> first second
                #с указанием args print
                showall = lambda x: [print(line, end='') for line in x]
            map
                showall = lambda x: list(map(print, x)) #list для вызова генератора
                t = showall(('a','b','c'))  >> a >> b >> c #t для скрытия возвращаемого val(списка) в интерактивном интерпритаторе
                #без цикла, с указанием args print
                showall = lambda x: print(*x, sep='', end='')
        #присваивания
            setattr
            .__dict__ с привязками NS и методов модифицирующих mutable на месте
            методики fx программирования
#называется lambda из-за сходства с инструментом в Lisp который получил его от lambda-исчислений
#использует правило legb ~ def(см. замыкания)
    def knights():
        title = 'Sir'
        action = (lambda x: title + ' ' + x)
        return action
    act = knights()
    act('robin')        >> 'Sir robin'
#анонимная fx т.к. обходятся без имени(присваивание имени - опционально)
#меньше конфликтов имен, fx объявляется прямо там где используется
    def maker(N):
        def action(X):
            return X**N
        return action
    a = maker(3)
    x = a;x.__name__    >> 'action'
    maker = lambda N:lambda X: X**N
    a = maker(3)
    a.__name__          >> 'lambda'
#выражение => может быть использована там где запрещен def, например в коллекциях
    if True:def hello():print('hello')     >> SyntaxErr
    if True:hello = lambda:print('hello')   >> ok
    #альтернатива - объявление def заранее
#почти всегда вкладывается в def;внутристрочная fx
#вместе с генераторными выражениями заменяет генераторные fx(см.ГЕНЕРАЦИЯ ПЕРЕМЕШАННЫХ {xn})
#распространена как вложенная fx фабричных fx(замыканий),т.е. используется как в качестве obj замыкания так и внутри obj замыкания
#используется в gui (см. tkinter)
#используется как краткое условное обозначение fx позволяющее встраивать свое определение внутрь кода где оно применяется => обеспечивает кодовую близость что особенно полезно для fx использующихся в одном контексте(месте)
#используются в списках args с вызовами fx - способ встраивания временных fx не применяющихся в других контекстах
#используется в качестве обработчиков обратного вызова встроенные в список args регистрирующего вызова(?) вместо определения в def и ссылки по имени
#используются для реализации таблиц переходов(коллекции(list/dict) действий подлежащих exe по запросу)
    L = [lambda x: x ** 2,
        lambda x: x ** 3,
        lambda x: x ** 4]
    for f in L:print(f(2))      >> 4,8,16
#не умеет присвоение в выражении
    lambda k: d[k] = 0 >> SyntaxErr
    lambda k: d.update({k:0}) >> OK
#условия
    lambda <args>: <ifTrue> if <Условие> else <ifFalse>
    #or бинарное выражение(bad)
#можно легко создать набор fx, хотя не уверен в полезности
    funcs = lambda x: x**2, lambda x: x**3
    func[0](3)      >> 9
#поддерживает self
    class List(list):pass
    List.a = lambda self:self.reverse()
    L = List([1,2])
    L.a();L     >> [2,1]
#используй скобки для кортежей возвращаемых lambda
    def f():
        i = ['var']
        yield (lambda x: i,id(i))
    acts = f()
    next(acts)                      >> (<function f.<locals>.<lambda> at 0x036553D8>, 1705216448)

    def f():
        i = ['var']
        yield lambda x: (i,id(i))
    acts = f()
    next(acts)                      >> <function f.<locals>.<lambda> at 0x03655420>
#используй скобки для выражений lambda
    action = (lambda x: (lambda y: x + y))
    ((lambda x: (lambda y: x + y))(99))(4)
#тело lambda - одиночное exp а не блок операторов/составной оператор;~ выражения указываемого после return в def, которое возвращается неявно
#ограниченность lambda - feature ограничивающая вложенность
#может быть заменен например модулем operator(см. operator)
обозначение <x> - произвольный obj подходящий по контексту или ключевое слово(например литерал типа) => там где просто ключи писать без <>, по идее все что без key= - не ключи, - нихрена(пример str(encoding))(?разобраться как понять что fx принимает ключевые или позиционные args)
arg fx передаются присваиванием объектов именам локальных var
    распаковка вложенных {xn} работает для списков arg fx(2.X), но не 3.X
    #2.X
        def f((a,b),c):pass >> f(<tuple>,c)
    #3.x
        def f((a,b),c):pass >> SyntaxErr
#распространенная кодовая идиома
    <set of vars> = <{xn} int>
литерал - выражение генерирующее obj ~ константа ~! const в C++ обозначаемый литералом(константой) obj может быть mutable(констаната != immutable)
    'abc' #литерал/литеральное выражение генерирующее и возвращающее obj
file obj - интерфейс для обработки реальных файлов
программные единицы
    fx
    модули
    классы
python предлагает набор типов связанных с реализацией
    obj скомпилированного кода
    #обычно интересны разработчикам python
ЛОГИЧЕСКАЯ СИММЕТРИЯ
#пример:set имеет теже модель поведения и литеральные выражения что и словарь
встроенные obj = основные типы данных = типы данных для создания которых сущ специальный синтаксис
    'string' | 1 | 1.1 | [1] | def | open() ...
фактически явное указание типов в Python основано на жестком синтаксисе
Python динамически типизирован
    #модель отслеживающая типы автоматически во время выполнения "не требуя" объявления(ограничения) типов
    #динамическая типизация подразумевает полиморфизм
    obj -
    #область mem(связанная со средой выполнения(процссом/потоком...(mem фрагментирована)) с конкретным значением(и достаточным пространством для его хранения) и именем(видимо отдельное поле)
    если имя var хранится в поле => var!=имя(проверить)
#по идее границы полей/obj/var должны разделяться по типу(числу битов ) или каким_нибудь разделителем;судя по строкам -разделение происходит по размеру типа
при использовании имен интерпритатор создает/изменяет/ищет их в namespace
var в Python похожи на указатели в C, но не var C
т.к. var может ссылаться только на obj, но не другую var => var не obj
        КАЖДЫЙ obj имеет 2 заголовочных поля
            обозначение типа(содержит ссылку на obj типа напр int)
                обычно имя ссылается только на один один тип obj(obj одного типа?)
                    но может указывать на несколько(для реализации полиморфизма)
                типы ассоциированы с obj
                типы не ассоциированы с именами(var)

            счетчик ссылок(для определения необходимости освобождения mem)
    значение hash = указатель?
    врядли Obj имеют имя - им это не нужно, достаточно счеткика ссылок
    по идее нельзя заполучить саму ссылку в Python
    как проворачивать трюки с указателями из C/C++ в Python?
        в отдельном модуле C
        habr
        ссылки высокоуровневый аналог указателя - всегда подвергаются автоматическому разыменованию при использовании
        внутренне ссылки это указатели
        obj(immutable) нельзя изменить
            в коллекциях ссылок добавляется новая ссылка
            в случае immutable obj - создается новый obj, страрый удаляется
        ссылка-точка доступа ~ указателям void* в C(С++?)
        по указателям void* в С(С++?) всегда происходит автоматическое следование при использовании
        по идее разыменование =переход по ссылке( превращение ссылки(указателя) в имя)
    ссылки python часто исполняют теже роли что указатели C(особенно с mutable типами)
    поле = область mem, ячейка
    #в алгебре мн-во для чьих эл-тов определен определенный набор операций, например поле R
    #поле бд !~ поле класса
    #поле класса = атрибут = переменная член, data member, instance variable
    #переменная связанная с классом|obj, все данные obj хранятся в его полях
    #доступ к полям осуществляется по их именам, тип данных полей задается описанием класса
    #обычно каждому obj соответствуют собственные значения всех его полей
    #статические поля класса=static data members=class variables - поля общие для всех obj класса(инстансов?), семантически равны глобальным var,но доступны только по квалифицированному имени => в отличие от глобальных var не загромождают пространство глобальных имен
    #в некоторых яп(java) НЕ СУЩ глобальных var => статические поля классов единственный способ хранения глобальных данных
    #обычно доступ к полям класса private - разрешен только для методов тогоже класса(используя свойства позволяющие классу контролировать изменения его полей)
С++ Поле класса Wiki пример(по идее просто реализация геттеров/сеттеров)
    #в Python поле и метод - атрибуты, статичные атрибуты могут быть перегружены в экземпляре
        #атрибуты экземпляра определяются в методах(напр конструкторе), а не структуре класса
        #свойство - отдельные методы осуществляющие доступ к атрибутам
            #синтаксически доступ к атрибутам и св-вам идентичны
    #битовые поля
        #битовые поля класса
            #могут быть определены в некоторых яп(С++)
            #занимают менее одной единицы mem(байта/слова), компилятор упаковывает несколько битовых полей в одну единицу mem, позволяя обращаться к битовым полям как к отдельным полям класса
        #по аналогии перенесено в
            сетевые протоколы
            форматы файлов
    квалифицированное имя var - с указанием имени класса
    структура = структурный тип= записи
    #частный случай классов - классы только из полей

    указатель = следуемый указатель от var(имени) к obj
    коллекция = obj содержащий поля с типом/ссылками на obj=коллекция с компонентами=составной тип
    коллекция
        физическая
            списки
        виртульные
            строки файла
    литерал коллекции - серия выражений возвращающих obj
    как я понимаю все типы данных python это либо коллекции указателей либо неизменяемые obj
    системная таблица - место хранения var(как минимум)
    изменить можно все что угодно, но не на уровне абстрации "объект"
        ctypes.cdll(...).memset #изменение прямо в mem
    #У лутца
        var = имя, ссылающееся на obj|var = ссылка!=указатель=> все obj связаны с var(классы,экземпляры,etc)
в программировании: var - именованная или иным образом адресуемая область mem позволяющая получать доступ к данным
        обобщенная природа имен - ссылку в var можно перезаписывать - может быть решающим преимуществом Python, НЕСОДЕРЖ ~ const из C++, obj могут быть immutable, но каждой var можно всегда присвоить новое значение
        var - запись в системной таблице с местом для ссылок видимо в пуле процесса(или потока если у потоков одного процесс не общая mem(песочница))
        var ~ указатель(коллекция указателей для mutable) который можно изменить, но не метка по которой можно изменять mem(obj)(в отличие от C++)
        #У меня var = имя + ссылка + obj
        #ссылка реализована как указатель в mem(ссылка указателем)
        #указатель - просто число, ссылка -механизм (слабые/сильные,etc?),действие
        #ссылка механизм обеспчения связи - более абстрактна,указатель - адрес
            но на практике ссылка ~ указатель
        переменная в python может называться именем
        var создаются при присваивании
        var просто имя?
            имя не содержит данных о obj только ссылку
                имя = обобщенная ссылка
            имя и obj хрянятся в разным местах mem и связаны ссылкой(односторонней/двухсторонней?)
            имена всегда ссылаются только на obj а не на другие имена
                в Python не СУЩ способа связать две var напрямую
            вся информация о obj хранится в obj
            все var должны быть присвоены - ссылка на не сущ obj => err
            все имена в коде автоматически заменяются на obj(значения)
                a = 3
                    создаем obj для представления 3
                    создаем var if еще не сущ|переписываем ссылку и удаляем obj по ней
                    связывание var и obj
    инициализация и объявление в Python происходят одновременно? или объявления нет?
    a = ['hi']
    a = a*2 #ссылка перезаписывается, obj ['hi'] сразу же подвегается сборке мусора(но не в случае int/str)
    по идее типы obj не меняются(не представляю как это сделать через указатели?)
    разделяемый ссылки
        a = [0]
        b = a #a заменяется на [0] и не присваивается
        #b,a - разделяемые ссылки, [0] - разделяемый obj (иногда одно подразумевается под другим)
        b[0] = 1 #заменили указатель в obj на который ссылается a и b,var не меняется(только obj)
        a >> [1] # var не изменились в отличие от obj
        #не имеет никаких побочек для immutable obj кроме экономии времени cpu и mem
        b = [0] #a все еще [1]
        #прекрасно подходят для инициализации нескольких var с помощью immutable, например счетчиков
            i=j=k=0
при присвоении obj компоненту структуры данных(для изменяемых типов) в нем сохраняется ссылка на него а не копирование(кроме явного копирования)
gc
#модуль
    #СБОРЩИК МУСОРА Cpython
    #занимается сборкой мусора(не всегда немедленно)
    #по идее при операции удаления/перезаписи ссылки в var переходит в obj по ссылке и если в поле ссылок = 0 => удаляет obj(отдает ее ОС?(Врядли он забивает ее нулями:)))=> область mem попадает в пул свободного пространства ос
    #СОДЕРЖ детектор циклов - компонент обнаруживающий и освобождающий mem занятую obj только с циклическими ссылками, включен по умолчанию; можно отключить(ради ускорения?)
    циклическая ссылка - ссылка в obj указывающая на сам obj,либо на другой obj или цепь obj последий из которых указывает на изначальный obj
    #классическая проблема сборщика мусора
    СБОРКА МУСОРА
    #очистка областей mem занимаемых obj у которых в поле числа ссылок стоит 0
    СЛАБЫЕ ССЫЛКИ
    #специализированное расширение модели ссылок
    #развитый интрумент, ссылка не препятствующая сборке мусора для данного obj
    #if на obj ведут только слабые ссыки - он удаляется, а слабые ссылки удаляются или уведомляются об освобождении
    #могут быть удобны
        #при кешировании крупных структур на основе dict,где ссылка кеша не будет препятсвовать его удалению
        weakref
        #модуль
Python строго типизированн
#КАЖД obj имеет ограниченный набор операций
java не поддерживает глобальные var - статические поля классов единсвенный способ хранения глобальных данных
первый эл-т {xn} = голова
основные числовые типы Python
    int
    #в 2.X точность зависит от интерпритатора, обычно 32бит,автоматически заменяется на long при переполнении
        type(2147483647) >> int
        type(2147483647 + 1) >> long
    #3.X точность неограничена, гибрид int/long из 2.X
    #поддерживает запись в hex/bin/oct сс => литералы создают одинаковый obj(альтернативный синтаксис)
    #поддержка неограниченной точности сказывается на производительности => целочисленная математика может быть медленной для больших чисел
    число =? целочисленный код ~? перечислимые типы other pl
    float
    #
        #представление бесконечности
        float('inf')    >> inf
        type(float('inf'))  >> <class 'float'>
    комплексные числа(с мнимой частью)
    десятичные числа с фиксированной точностью
    рациональные числа(числитель и знаменатель)
    bool
    полнофункциональные мн-ва(wtf? причем тут мн-ва?)
основной тип != базовый = встроенный
    базовые типы - все что не нужаются в import, включая
        unicode(2.x)
        bytes
             в некоторых случаях еще
                type
                None
                bool
                decimal
                complex
                fractions
видимо основной тип - наиболее часто встречающийся в программах(нет формальных критериев)
программные единицы
    fx
    модули
    ...?
внутренние св-ва интерпритатора
    стековые фреймы
    скомпилированный код
    ...
obj = тип объекта; все - obj
    можно поместить класс в кортеж или передать его fx
тип obj - obj типа type
все в python - тип объекта, включая сам тип объекта
объекты типов могут использоваться для проверок типа -> нарушает гибкость кода
проверка типов применяется к экземплярам, в классах нового стиля тип экземпляра класса - класс из которого был создан экземпляр
классы старого(традиционного стиля) 2.X - все экземпляры имеют тип экземпляр, для сравнения типов требуется использовать attr .__class__
.__class__
#атрибут содержащий ссылку на класс создавший(~из которого был создан) экземпляр, по идее есть у всех obj
#вроде интерфейс используемый type|isinstance
.__len__(self)
#возвращает число элтов в контейнере используется len()
#вызывается вместо __bool__ при его отсутствии
    class test():
        def __len__(self):
            return 1
    t = test()
    len(t) >> 1
    bool(t) >> True
import braces(или как-то так) по идее просто убирает скобки(или заменяет их отступами перед компиляцией)
2.2+ все типы ИМЕЮТ встроенное имя
имена типов используются для настройки типов(создания user class)
types
#модуль СОДЕРЖ имена типов недоступные в виде встроенных(fx)
#2.X также ВКЛЮЧ синонимы встроенных имен типов
#вроде менее предпочтителен чем isinstance
    .BuiltinFunctionType
    #
    .BuiltinMethodType
    #
    .CodeType
    #
    .CoroutineType
    #
    .DynamicClassAttribute
    #
    .FrameType
    #
    .GeneratorType
    #
    .GetSetDescriptorType
    #
    .LambdaType
    #
    .MappingProxyType
    #
    .MemberDescriptorType
    #
    .MethodType
    #
    .ModuleType
    #
    .SimpleNamespace
    #
    .TracebackType
    #
    .FunctionType
    #
        types.FunctionsType >> <class 'function'>
        type(print) == types.FunctionType >> False
        def test():pass
        type(test) == types.BuiltinFunctionType >> True
    ...

ВСТРОЕННЫЕ ТИПЫ
        Collections: {f
            {xn}: {
                immutable: str  Unicode   bytes  tuple
                mutable  : list bytearray
            }
            mapping: {
                           dict
            }
            sets: {
                           set  frozenset
            }
        }
        Numbers: {
            целые: {
                           int longint bool
            }
            floats: {
                            float complex decimal fractions
            }
        }
        Callable: {
                            fx generator class
            метод: {
                            связанный
                            несвязанный(2.X)
            }
        }
        Внутренности: {
            тип
            код
            Фрейм
            Трассировка стека
        }
        Others: {
            Модуль
            Экземпляр
            Файл
            None
            Представление(2.7+)
            объекты регулярных выражений
            файлы dbm
            виджеты gui
            ...
        }

==проверить этот блок =======стр 130====
    int в python 3.X при необходимости обеспечивает повышенную точность больших чисел
    в Python 2.X числа слишком большие для int поддерживались отдельным типом long int
        #python 3.X
            type(2**100) >> <type 'int'>
        #python 2.X
            type(2**10)  >> <type 'int'>
            type(2**100) >> <type 'lohg'>
    repr
    #форма вывода obj "как в коде"(не памяти) с полной точностью (float only?), противоположность str
    #используется для отображения вложенных эл-тов(см. str())
    #obj в строковом состоянии при выполнении которого будет получен исходный obj(представление obj строкой)
        #python < 2.7|3.1
        3.1415 * 2 >> 6.2830000000000004 #не ошибка(по сути особенность реализации), 4 - паразитная цифра
    repr(<obj>)
    #возвращает obj в виде repr str(сохраняет вид)
    #<obj> - ЛЮБОЙ
    #используется интерактивным интерпритатором для автоматического вывода
        repr('spam') >> "'spam'" #~print(repr('spam'))
    str(object='') -> str
    #используется print для отображения эл-тов верхнего уровня(см repr)
        print('a')  >> a
        print(['a']) >> ['a']
    #возвращает obj в виде str, если он доступен(убирает кавычки)
    #<obj> - ЛЮБОЙ
        str(bytesOrBuffer[,encoding[,errors]])
        #~<bytes>.decode() производит декодирование bytes с использованием указанной кодировки
        #
        str('spam') >> 'spam'
        repr('spam') >> "'spam'"
    str
    #форма вывода obj (float only?), дружественная пользователю
        #python 2.7+|3.1+
        3.1415 * 2 >> 6.283
    запись вида 2.6- под которой я подразумевал все версии ниже 2.7 - не верна, т.к между 2.6 и 2.7 тоже могут быть версии => переписать на python < X.X
    python 2.7+|3.1+ по умолчанию используют форму вывода obj str - более "разумно"(с меньшим числом паразитных цифр)
    python < 2.7|3.1 по умолчанию используют форму вывода obj repr =>
        if содержимое obj кажется странным из-за repr => можно попробовать воспользоваться print()
    в рамках использования классов разница между str и repr может быть существенной - obj классов используют перегрузку операций - str(для обычного применения) repr(для детального вывода)
    походу repr в 3.1+ и repr в <3.1 - разные вещи - переписать! хз вообще!
    возможно
        repr в <3.1 используется по умолчанию, а str например в print()
=====================
math
#математический модуль
    math.pi
    math.sqrt()
random
    .random()
    #zero args, возвращает случайное число float 0...1
    .choice(<non_empty_iterable>)
    #one args, возвращает случайный элемент из итерабельного obj
    .randint(<start>,<end>)
    #возвращает случайный int между <start> и <end> включая их, аргументы - целые,start<stop
    .shuffle(<{xn}>,random=None)
    #случайно перемешивает {xn}, меняя исходный obj, ничего не возвращает
    .seed(a=None, version=2)
    # Initialize internal state from hashable object
    # None or no argument seeds from current time or from an operating system specific randomness source if available.
    # If *a* is an int, all bits are used.
    #version 2  all of the bits are used if *a* is a str,bytes, or bytearray
    # For version 1 (provided for reproducing random sequences from older versions of Python), the algorithm for str and bytes generates a narrower range of seeds.
    
    
СТОРОННИЕ ЧИСЛОВЫЕ ТИПЫ
    матрицы
    векторы
    числа с повышенной точностью
строка может использоваться для записи набора байтов
строки не имеют символа завершения как в C,конец определяется длинной строки
{xn} - позиционно упорядоченная коллекция obj
строка - {xn} односимвольных строк
индекс - номер элта, a[0] - выражение индексации
переменная заменяется присвоенным значением при использовании в выражении
везде где python ожидает значение - можно использовать exp
нарезание - процесс получения среза
подстрока = раздел = срез
a[:] создает копию верхнего уровня(видимо неглубокую)
immutable obj нет смысла копировать т.к. оригинал все-равно не изменится, а методы сразу возвращают копии
{xn} поддерживают повторение(умножение на число) и конкатенацию с помощью перегруженных + и *
    #конкатенация создает новый obj => медленнее изменения на месте, менее подвержена эффектам разделяемых ссылок
        M = L = [1,2]
        L = L + [3,4]
        M,L     >> ([1,2],[1,2,3,4])
        M = L = [1,2]
        L += [3,4]
        M is L >> True
    [1,2]*2 >> [1,2,1,2]
    (1,)*2 >> (1,1)
    s = 'a';s*=3;s >> 'aaa'
    #при указании дополнительных скобок добавляет уровень глубины
    l = [1,2]
    l*2 >> [1,2,1,2] #~l+l #Новый список
    #коллекция ссылок на один obj
    r = [l]*2 >> [[1,2],[1,2]] #~[l]+[l]
    r[0] is l >> True
    #генерирует коллецию элементы которой ссылки на один obj
        [1,2] is [1,2] >> False
        l = [1,2]*2
        l[0] is l[1] >> True
        l[0][0] = 'a' >> [['a',2],['a',2]]
    1,*2   >> TypeErr #распаковка int в кортеже
    {1,2}*2 >> TypeErr: unsupported operand type
полиморфизм
    #действие оператора(exp) зависит от obj '1' + '1' | 1 + 1;интерпритатор делегирует  obj выполнение действия в зависимости от их типа
    #операторы(все) - координирующий механизм передающий контроль обрабатываемым obj
        вывод
        index
        расширенная распаковка
        ...
    #полиморфизм - поведение с зависимостью от типов
    #основан на  динамической типизации
    #код автоматически адаптируется к изменениям требований/компонентов
    #наиболее фундаментальная идея Python(т.к. Python динамически типизуруем)
    #fx не имеют ограничений на типы принимаемых/возвращаемых obj(при наличии совместимого интерфейса(протокола) для обработки)[методов(операции exp)](могут автоматически применяться к категориям тивов автоматически(obj автоматически совместитмы с логикой fx)=> полиморфичны
        def f(x,y):
            return x*y
        f(3,4)      >> 12
        f([0],2)     >> [0,0]
    #т.к. Python автоматически обрабатывает ошибки и возвращает исключения не требуется присать код проверок на ошибки(что нарушает гибкость кода)
    #основная причина лаконичности и гибкости кода Python, ключевое отличие от статических яп проверяющих типы;в Python код пишется для интерфейсов obj а не типов-> такое полиморфное поведение = утиная типизация
    #утиная типизация - код не обязан заботиться о том явл ли obj уткой, а лишь о том что от крякает -> реализация кряканья делегируется obj
    #утиная типизация - мы обязаны тестировать код на ошибки а не предоставлять компилятору объявления типов которые он использует для обнаружения специфических ошибок; в обмен на удлиннение тестирование -> радикальное сокращение кода, и увеличение его гибкости
    полиморфичная операция
        суть операндов не важна, важно лишь наличие подходящего интерфейса
ПЕРЕГРУЗКА ОПЕРАЦИЙ
#по идее для иммутабельности часть методов не нужно реализовывать

как удалить наследуемый атрибут?
    __getattribute__(self,name,/)
    #return getattr(self,name)
        obj.__getattribute__        >> <method-wrapper '__getattribute__' of <typeOfObj> object at <adress>>
        obj.__getattribute__('__dir__') # == obj.__dir__
    #может вызывать рекурсивное зацикливание
    __repr__
    #может вызывать рекурсивное зацикливание
    #вроде обязан возвращать str
    __setattr__
    #может вызывать рекурсивное зацикливание
    #method-wrapper, видимо для setattr() | выражения присвоения attr
    __getitem__(self, index)
    #вызывается для self[index]
    #перегрузка используется для создания iterable(как альтернатива __iter__/__next__), обладает преимуществами(?) при работе с {xn}, но менее гибок
    #используется для получения эл-та по индексу
    #старше __iter__
    #может быть использован для реализации in
    #относится к протоколу mutable|immutable коллекций, должен выбрасывать TypeErr при неправильном типе ключа, и KeyError при его отсутствии
    __reduce__(...)
    #return state information for pickling
    #интерфейс для reduce()?
    __add__(self, other)
    #вызывается для self + other
    __index__(self)
    #преобразование типа к int когда obj используется для указания диапазона среза
    #для пользовательских числовых типов
    __iter__(self):
    #implement iter(self), извлекает итератор
    #iterator.__iter__() возвращает self
    #используется для создания пользовательских итераторов(генераторов)
    #более гибок чем __getitem__
    __setitem__
    #self[index] = value
    __mul__(self,value,/)
    #self*value.n (что за .n?)
    #умножение короче
    __rmul__(self,value,/)
    #self*value. (чем отличается от __mul__ ?)
    __nonzero__
    #2.X ~__bool__
    #3.x отсутствует
    __reversed__()
    #по идее интерфейс для reversed()
    __sizeof__()    -> int
    #метод
    __contains__()
    #специфический метод
    #может использоваться для реализации in
    __dir__()
    #интерфейс для dir()
    __call__(self)
    #перехватывает прямые вызовы экземпляра
        class Outer:
            def __init__(self, start):
                self.state = start
            def __call__(self, label):
                print(label, self.state)
                self.state += 1
        E = Outer(0)
        H('text')       >> text 0
        print.__call__('hi')        >> hi
    
implement - реализация?
типы не ограниченны => if они поддерживают совместимый интерфейс => с ними могут работать одинаковые операторы
числа - immutable
list(<iterable>) - разворачивание obj в список(или создание копии списка)=список эл-тов iterable
индекс индекса [i][j]
bytearray(iterableInt|string,encoding[,errors]) -> bytearray
bytearray(bytes|buffer) -> изменяемая копия bytes|buffer
bytearray(int) -> bytearray размером полученным из параметра инициализации с null bytes(str,encoding)

#требует bytes(только с литералами шириной не более 8ми бит(напр. ascii))(это не совсем так) в python 3.X(но не python 2.X), строковый тип, гибрид bytes/list,изменяемая {xn} bytes(int), имеется в python 2.6+, аргументы - int; поддерживает методы списков и строк, вроде похож на массив символов в C
#выводится как строки
    #позволяет "менять строки" на лету(ascii only), реально по сути это изменяемые строки для ascii
    b = bytearray(b'str')
    b.extend(b'ing')
    b >> bytesarray(b'string')
    b.decode() >> 'string'
    #по сути работает с любым текстом и содержит стандартные методы str, но не интерпритирует nonAscii без преборазований и с учетом переменной длинны символов разных символов в разных кодировках сильно усложняет обработку даже вслепую
        #значительно сложнее обрабоки строк
        b = bytearray('абв','utf-8') >> bytearray(b'\xd0\xb0\xd0\xb1\xd0\xb2')
        b.decode() >> 'абв'
bytes
#байтовая строка
#отдельный строковый тип, неформатированные {xn} байт(напр. закодированный текст)
#содержит int значения кодовых точек символов ascii
    b'a'[0] >> 97 #т.к. содежрит последовательность int
метод
#атрибут ссылающийся на fx(fx метода) => а не наоборот!
#может быть применен там где запрещено exp
    d.get(k,lambda k: d[k] = 0) >> SyntaxErr
    d.get(k,lambda k: d.update({k:0}) >> OK
#fx специфичные к типу, инициализирующиеся посредством выражений вызовов(видимо ())
#вызов fx = инициирование действий fx
#атрибуты ссылающиеся на вызываемые fx имеющие в своем распоряжении подразумеваемый obj(self)
#self авмоматически получает подразумеваемый obj вызова(экземпляр созданный обращением к классу)
#self - специальный arg экземпляра, локальная var в fx методов объемлючего класса
#self до 2.2 передавался в fx внутри методов(как минимум) с помощью стандартных args
#тоже операция
#obj.method - obj - объект на котором вызывается метод
#вызов метода
    излекаем атрибут из obj(функцию)
    вызываем с передачей аргументов, self - сам obj
    #по сути это же синтаксический сахар
    class test():
        ...
        def func(self):
    obj = test()
    obj.func() ~ test.func(obj)
#методы mutable возвращают None
str.rstrip()
#удаляет пробельные символы с правой части строки(напр \n)
str.join(<iterable>)
#преобразование iterable в str
    ''.join(map(str,range(10)) >> '0123456789'
'{0} text {1}'.format(a,b) #в Python 2.6.x/3.0.x обязательно указывание индекса аргументов
'{:,.2f}'.format(296999.2567) >> '296,999.26'
'%.2f | %+05d' % (3.14159, -42) >> '3.14 | -0042'
str.casefold()
#~str.lower более совместимый с unicode
#кажется ~ str.lower()
str.expandtabs([tabsize])
#метод
str.find(sub [,start [,end]])
#возвращает индекс найденного эл-та или -1 при отсутствии
str.isdecimal()
#метод
str.isidentifier()
#метод
str.isprintable()
#метод
str.isspace()
#метод
str.istitle()
#метод
str.isupper()
#метод
str.maketrans(x[,y[,z]])
#метод
str.partition(sep)
#метод
str.rpartition(sep)
#метод
srt.rsplit([sep[,maxsplit]])
#метод
#по умолчанию использует пробельные симоволы
str.split()
#по умолчанию использует пробельные симоволы
пробельные символы - \t \n пробелы
str.rstrip([chars])
#удаляет пробельные символы в конце строки
str.splitlines([keepends])
#метод
str.zfill(width)
#метод
re обычно медленнее строковых методов, мои собственные костыли тоже
операции над {xn} универсальны в отличие от методов
уровни инструментального набора Python
    универсальные операции - встроенные fx|exp
        len()
        x[0]
        ...
    специфичные(методы)
возможно стоит писать конспект как справочник атрибутов obj - получилось бы крайне структурированно и возможно удобно

<string>.__add__(<string>)
#метод строк перегружающий оператор +, не рекомендуется к применению, менее понятен чем перегруженный +
#может работать медленнее +
    'str' + 'ing' == 'str'.__add__('ing')
<string>.translate(<table>)
#кажется заменяет одни подстроки на другие
occurrences - совпадения?(вхождения?)
специальные обозначения типа
#на самом деле имя класса с полиморфизмом, при передаче имени, другим obj они могут вызвать конструктор(или проверять тип через isinstance(хотя звучит бессмысленно))
#раньше(?когда) были просто fx преобразования;вызов имени класса вызывает конструктор для создания экземпляра данного класса
    str
    list
    dict
    tuple
    int
    float
    complex
    bytes
    set
    file(2.x)
    ...
что за / в аргументах fx? => кажется разделитель
ДРУГИЕ СПОСОБЫ НАПИСАНИЯ СТРОК
ord(<string>)
#возвращает внутренний int кодовой точки Unicode в 10ой сс(от 0...0x10ffff)(например в байтовое значение ASCII), принимает только символ, обратна chr()
    ord('\n') >> 10
#можно заменить распаковкой байтовой строки для ascii
    (*b'abc',) == (ord('a'),ord('b'),ord('c'))  >> True
\0 - байт с двоичными нулями - не завершает строку
    'A\0B\0C' >> 'A\x00B\x00C'
chr(int)
#возвращает симовол по кодовой точке Unicode, обратна ord()
r'string' - неформатированный строковый литерал, отключает механизм отмены(string cancelation?|escape?)
префиксы регистронезависимы
очевидно что не любая управляющая {xn} = unicode escape
обратный \ в строках - механизм(символа) отмены(escape)
    '\'' #отмена кавычки
строки принято писать с одинарными кавычками
unicode
#тип
    #разница в коде при использовании unicode и str почти отсутствует, пока дело не доходит до передачи unicode текста за пределы программы, unicode имеет все атрибуты str + .isnumeric и .isdecimal
    Python 3.3+ поддерживает unicode литералы python 2.X трактуя их как str
    u'sp\u00c4m' - unicode литерал из Python 2.X
    обычные(не unicode) строки Python 2.X поддерживают 8битные символы и не форматированные байтовые значения
        s = 'ф'
        type(s) >> <type 'str'>
        s   >> '\xe4'

    Python 2.X имеет отдельный тип unicode создающийся префиксом u'' для хранения строк unicode
        type(u'abc') >> <type 'unicode'>

строки - содержат данные основанные на байтах
байтовые литералы - литералы создающие obj типа bytes b'' появились в python 3.X
python 2.6+ имеет обратную поддержку байтовых литералов из 3.X, интерпритируется как str(префикс b игнорируется и необязателен)
В Python 2.X/3.X не Unicode строки - 8-bit {xn} байтов по возможности выводящиеся как символы ASCII, а Unicode строки - {xn} кодовых точек Unicode
строка - {xn} кодовых точек Unicode - {xn} чисел идентифицирующих символы, не обязательно сопоставляются с одиночными байтами при кодировании;
понятие байтов неприменимо к Unicode - может СОДЕРЖ кодовые точки > 1 байта
в некоторых кодировках/схемах хранения данных(напр utf-16) в mem даже на ASCII символы выделяется более байта(1/2/4байта)
    s = 'hello'.encode('utf-8')
    s                   >> b'hello'
    s = 'hello'.encode('utf-16')>> b'\xff\xfeh\x00e\x00l\x00l\x00o\x00'
    #\xff\xfe H \x00 E \x00 L \x00 L \x00 O \x00'
    len(s)                  >> 12
utf-16 жрет дохрена памяти для ASCII текста
УПРАВЛЯЮЩИЕ {xn} - внедряют действительные(имещие сопоставленный символ) закодированные значения(числа) кодовых точек в str в терминах unicode
\x<char><char>
#if <char> > 255(ff) -> значение кодовой точки unicode, а не hex escape
\u,\U... символичиеские управляющие {xn}
\ooo,\xhh абсолютные упраляющие {xn}
    \новая строка
    #игнорируется, используется для продолжения строк, как и везде в Python
    \a
    #звонок(?) по идее не работает в IDLE(выдает кракозябру)
    \b
    #забой(backspace?) что оно делает?
    \f
    #перевод страницы(?)
    \r
    #возврат каретки(возврат курсора в начало строки?)
    #в unix используется \r\n
    \v
    #вертикальная табуляция(зачем?)
    \<oct><oct><oct>
    #oct значение до 3х цифр, как использовать?
        \0
        #пустой двоичный симовол~'\00'~'\000'
    \N{id}
    #идентификатор ПРИНАДЛЕЖ бд unicode
    \x<hh>  hex управляющая {xn}
    #может использоваться в любых строках, значения 0-255
        \xc4
    \u<hhhh>
    '\u00c4' >> 'Ä'
    #short unicode escape,16 bit
    #может использоваться в ЛЮБЫХ строках кроме bytes
    #2.X распознается только в unicode
        b'\u00c4' >> b'\\u00c4' #добавляется лишиний \ и вообще это не верная unicode escape
        #правильно
        s = '\xc4'.encode() >> b'\xc3\x84'
        s.decode())       >> 'Ä'

    \U<hhhhhhhh>  long(32 bit) unicode escape
    #может использоваться в ЛЮБЫХ строках кроме bytes(аналогично \u)
        \U000000c4
    #2.X распознается только в unicode
    #3.x в bytes распознается как байт с заданным значением(пример?)
в строках '\' сохраняется в чистом виде, но выводится как '\\'
всегда следует использовать r'\'|'\\' во избежание возникновения нежелательной управляющей {xn}
даже неформатированная str не может кончаться на нечетное число \ т.к. \ отменит символ '
    r'...\' >> Err
    r'...\\'[:-1] >> '...\\'
    r'...\\'    >>'...\\\\'
    print(r'...' + '\\') >> '...\'
многострочные блочные строки = '''...'''|"""..."""
    ''' \''' ''' #экранирование тройной кавычки
    внедряет спец символы(сохраняет весь текст)
        '''
            ''' >> '\n'
ФОРМЫ ЗАПИСИ СТРОК
    s = (
    "first\n"   #позволяет комментировать
    "second\n"  #блоки строки
    )

/ прямая косая черта
для str 3.x, unicode 2.x управляющие {xn} внедряют закодированные символы unicode
для bytes 3.x, str 2.x управляющие {xn} внедряют закодированные байтовые строки
2.x позволяет использовать в exp ascii str и unicode
    u'x' + 'y' >> u'xy'
    u'x' + b'y' >> u'xy'
    u'x' + 'ф' >> UnicodeDecodeErr: 'ascii' codec can't decode byte...: ordinal not in range(128)

3.x строже - не позволяет использовать в exp str и bytes(явное лучше неявного)
    u'x' + b'y' >> TypeErr:Can't convert 'bytes' to 'str' implicitly
    b'x' + 'y' >> TypeErr:Can't convert 'bytes' to 'str' implicitly
    u'x' + 'y' >> 'xy'
т.е. 3.x игнорирует u'', 2.x игнорирует b''
implicitly - неявно?
декодированные байты и кодовые точки совпадают только для некоторых кодировок и символов
    '\u00a3' >> '£'
    '\u00a3'.encode('latin1') >> b'\xa3'
    b'\xa3'.decode('latin1') >> '£'
    #Но
    'ф'.encode('utf-8') >> b'\xd1\x84'
    '\xd1' >> 'Ñ'
bytes.decode(<encoding>)
#декодирует bytes в string используя кодек зарегистрированный за указанной кодировкой
#3.x кодировка по умолчанию utf-8
#2.x кодировка по умолчанию ascii
str.encode(<encoding>='utf-8')
#кодирует string в bytes используя кодек зарегистрированный за указанной кодировкой
обозначения кодировок
    'utf-8'
    'utf-16'
        вызывает кодек 'utf-16-le'
    'latin1'
ДЕСКРИПТОРЫ
#кажется реализуют методы, как-то через self видимо
    'hello'.capitalize() >> 'Hello'
    str.capitalize('hello') >> 'Hello' #capitalize здесь дескриптор
    #по сути доступ к методу класса через инстанс
реализация методов?
двоичные файлы
io
#модуль содержащий классы реализации fileobj, часть классов доступны для настройки
file
#3.X удален за избыточность
#2.X тип, синоним open и идентичным поведением при вызове, не рекомендован как интерфейс файлов
#используется для настроки файлов в модели ооп
    .xreadlines
    #похож на <fileobj>.readlines, но не возвращает весь файл целиком
    #предшественник файловых итераторов
fileobj
    #к ним неприменимо обычное разделение на mutable/immutable т.к. походу нельзя изменить путь к obj(etc) при этом obj может меняться
    #автоматическое закрытие файлов при сборке мусора - не часть определения Python, может по разному работать в разных реализациях ВКЛЮЧАЮЩИХ разные реализации gc(происходить с задержкой) >> лучше использовать with/close
    globals().['__warningregistry__']
        #в том числе содержит данные о незакрытых файловых obj
    #возвращает/принимает только str
    #могут использоваться инструментами итерации для прохода по строкам
    #obj ВКЛЮЧАЮЩИЙ ссылку на файл+методы передачи данных
    #предоставляет данные по требованию(как напр. генератор)
    #один из базовых типов, но без специфичного литерального синтаксиса,одновременно тип расширения(у лутца и так и эдак(возможно дело в переводе)
    #основной интерфейс к внешним файлам
    #один из основных типов, не используется в exp
    #входной файл(данные попадают в программу) - open(path,'r') ввод
    #выходной файл open(path,'w')   вывод
    fileobj.read([n])
    #чтение в str, n - число следующих символов(байтов) = -1 по умолчанию, метод _io.TextIOWrapper instance
    #Read from underlying buffer until we have n characters or we hit EOF.If n is negative or omitted, read until EOF. ?
EOF - end of file
    fileobj.readline()
    #чтение следующей строки файла(ВКЛЮЧАЯ '\n') в str меняет позицию курсора
    #походу использует __next__ и возвращает пустую строку при истощении файла вместо исключения
    fileobj.readlines()
    #чтение всего файла в список строк(ВКЛЮЧАЯ '\n')
    fileobj.flush()
    #сброс буфера вывода на диск не закрывая файл
    fileobj.seek(n)
    #изменение позиции курсора в файле для следующей операции, для произвольного доступа
        f = open(path)
        f.seek(0) #~f = open(path)
    #в текстовом режиме походу считает управляющие {xn} за набор отдельных символов а потому работает как говно(или я чего-то не понимаю)
        #вернуть последнюю позицию в файле
        file.seek(0,2)
    #походу не умеет указывать отрицаетельные смещения для текстового режима
    <fileobj>.write(buffer,/)
    #2.X не возвращает длинну записанных данных
    #в байтовом режиме возвращает длинну записанных байт, в текстовом - символов
        #чтобы перезаписать \n нужно сместиться на соотв число байтов  и перезаписать соотв числом символов
            with open(path,'w') as fout:fout.write('abc\n')
            f = open(path,'r+')
            end = f.seek(0,2)
            f.seek(end -2)
            f.write('zz')
            f.seek(0)
            print(repr(f.read()))       >> 'abczz'
            #иначе глючит
                with open(path,'w') as fout:fout.write('abc\n')
                f = open(path,'r+')
                end = f.seek(0,2)
                f.seek(end-1)
                f.write('z')    #с \x11 аналогично
                f.seek(0)
                print(repr(f.read()))   >>  'abc\nz'
                #
                with open(path,'w') as fout:fout.write('abc\n')
                f = open(path,'r+')
                end = f.seek(0,2)
                f.seek(end-2)
                f.write('z')    #с \x11 аналогично
                f.seek(0)
                print(repr(f.read()))   >>  'abcz\n'
как удалить(а не перезаписать) часть данных из файла?
    <fileobj>.close()
    #сброс содержимого буферов вывода на диск(если он не пуст) и закрытие файла,освобождение ресурсов, закрытие также происходит при сборке мусора/закрытии программы
    #при этом <fileobj> остается в mem
    .closed
    #bool сосотояние закрытия файла
    .detach()
    #открепляет файл от пути
    .mode
    #состояние режима
    .readable()
    #True/False
    .writeble()
    #True/False
    #можно использовать сразу несколько интерфейсов на одном файле, с блокировками(или чем там?) разбирается сам Python, это работает даже при постояной записи в циклах из разных процессов/потоков интерфейс сам заниматеся деталями
        fout,fin = open(path,'w'),open(path)
        print('data',sep='',end='',file=fout,flush=True);fin.read()>>'data'
файл - именованная ячейка хранилища
open(path,mode='r',bufferung=-1,encoding=None,errors = None, newline=None,closefd=True,opener=None)
#возвращает fileobj,path по умолчанию - каталог сценария(по идее можно изменить с помощью sys.chr или как-то так), mode принимает строку режима
#'w' перезаписывает файл при создании fileobj данные добавляются в конец файла
#'r' кажется только проверяет наличие файла по указанному пути, не меняет время последнего доступа
#имя файла может быть nonASCII символы Unicode - Python автоматически транслирует их в/из внутренней кодировки платформы(по идее cp866 на win), или может быть предварительно закодированной байтовой строкой
#encoding указывают схему кодирования для fileobj
    f = open(path,'w',encoding='utf-8')
    f = open(path,'w',-1,'utf-8') #плохо читаемо на мой взгляд
    data = open(path,encoding='utf-8').read()
#+ - read/write вместе с операциями позиционирования(seek); U - universal newline mode(deprecated(3.X)(не понял как пашет)
    '+r'
    #походу устанавливает курсов в 0
    #добавляет данные с перезаписью, кажется сбрасывает данные на диск сразу
    open(path,'w').write('abcd')
    open(path,'+r').write('1')
    open(path).read()   >> '1bcd'


#'t' - текстовый режим возвращает/принимает str кодируя и декодируя байты используя кодировку системы(например cp1251 в win) или указанную => в mem строки можно обрабатывать не заботясь о кодировках
#'b' байтовый режим io bytes, позволяет получить доступ к данным без изменений(данных/файла)(напр символов конца строки/возврата каретки|etc)|получить текст в виде байт(без изменений)(возвращает bytes), отключает трансляцию управляющий {xn} и кодировки), удобно для загрузки данных(например изображений) в mem и передачи другим сис-мам
#3.X текстовые и bin файлы имеют различную семантику - да это вроде и так видно
семантика?
    print(file=open(path,'w'))
    open(path,'r').read()   >> '\n'
    open(path,'rb')         >> b'\r\n' #'\r\n' вообще норма для windows?
#'a' добавление данных к концу файла без перезаписи исходных данных, например при логгировании
#без присвоения переменной удаляется сборщиком мусора автоматически и не нуждается в закрытии
    #создает плохо модифицируемый код, т.к. если операций должно быть несколько - либо просядет производительность либо придется создавать var(переписывать код)
#path по умолчанию ./
#'x' связан с файловыми int дескрипторами,блокировкой файлов
#buffering
    0 - вывод не буфферизируется, данные сразу пишутся в файл
#возвращает <class '_io.TextIOWrapper'> т.к. файловые интерфейсы в _io в 3.X
#по умолчанию все данные пишутся в буфер в mem, сброс происходит при .close()
#3.X по умолчанию io происходит благодаря Unicode кодировке платформы(c кодироваванием/декодированием) Ascii текст записывается без изменений
#2.X io проиходит побайтно(без кодирования/декодирования) ~ open(path,'b') в 3.X, но возвращает str а не bytes, поддерживает bin данные и ascii текст
#errors?
#newline?
#closefd?
#opener?
'''
Tis but
a flesh wound.      перевод?
'''
python обычно интерпритирует пути переносимым образом r'c:/user' ~ r'c:\user'
можно ли изменить кодировку для всей системы(win/linux) а не только shell?=> думается мне это сломает сис-му
интерфейсы к файлам зависят от линейки Python и типа данных
лучший способ чтения файла - не читать файл явно
    использование итератора встроенного в fileobj созданный прямо в итерационном контексте
    #лучше для текстового ввода(видимо в программу)
    #не загружает весь файл в mem => может работать с файлами ЛЮБОГО размера(при условии что строка поместится) т.к. загружает строки по запросу
    #обычно наиболее быстр и краток
        for line in open(...):|line for line in open(...)|'abc' in open(...)
fileobj имеет однопроходный итератор читающий файл построчно, и запоминающий свое положение между вызовами
#~файловый итератор строк
#был не всегда (когда появился?)
    for i in fout:print(i,end='') # end для вывода без дополнительных переводов строки
    [line for line in open(path)]
#быстрее while на 30%(3.3) 100%(2.7
разобрать методы методы файлов:dir(<fileobj>)
кажется bytes(a,'utf') == bytes(a,'utf-8')
в 2.X в файлы обычно записываются str(что видимо эквивалентно bytes ascii)
codecs
#2.X специальный файловый интерфейс
  #обрабатывает Unicode, позволяет писать/читать текст в указанной кодировке из файлов ~ open в 3.X
    .open(path,encoding=none,errors='strict',buffering=1)
    #по большей части ~open 3.X
ИСПОЛЬЗОВАНИЕ fileobj
    СОХРАНЕНИЕ OBJ
        #этот код уязвим к инъекции в файл между сохранением и извлечением данных
        #альтернатива - более сложный парсер строки и прогон через int|etc или использование pickle
        #разумеется сложные инкапсулировнные obj вроде модулей/классов так просто не сохранить
        s,x,l,d = 'text',47,[1,2],{'a':1,'b':2}
        import string
        #использование bytes потребует дополнительные шаги кодирования/декодирования,т.к. split
        with open(path,'w') as f:
            output = ('$"%s"' + '$%s'*3) % (s,x,l,d)
            f.write(output)
        inp = open(path).read().split('$')[1:]
        for var,exp in zip(string.ascii_lowercase,inp):
            exec(var+'='+exp)
        #или сохранение obj в списке
        res = [eval(exp) for exp in inp]
встроенные методы str не поддерживает сравнение с образцом => re
    import re
    match = re.match('Hello[\t]*(.*)world', 'Hello   Python world') #сравнить с любановичем, понять что происходит
    #[\t]* - ноль|более табуляций/пробелов
    #Затем произвольные символы подлежащие сохранению и world
    match.group() >> 'Python '
группа совпадения - часть данных совпавших с образцом
    #выбираем три группы разделенные '/'|':'
    re.match('[/:](.*)[/:](.*)[/:](.*)', '/usr/home:lumberjack').group() >> ('usr','home','lumberjack')
методы изменяемых коллекций быстрее операторов т.к. не создают новый obj
СПИСКИ
для хранения почти пустых матриц может быть менее эффективен чем dict
списки мощнее массивов(сравнить с C++)
    могут содержать данные нескольких типов
    не имеют фиксированных размеров
list.append()
#one args, увеличивает размер списка на 1 и помещает элт в конец
list.remove()
#удаляет элт по значению
присвоение эл-та за концом списка распространенная ошибка(например в C)
компилятор C производит меньше ошибок чем интерпритатор Python
базовые структуры данных вроде списка довольно жирные, например пустой список жрет сотни байт места в mem
list comprehension - выражение спискового включения
    #сбор списка результатов(СОДЕРЖИТ <exp> для КАЖДОГО эл-та <iterable>) с помощью итерации и опциональной фильтрующей проверки
    [<exp> for <var> in <iterable> [if <cond>] 
         for <var> in <iterable> [if <cond>]...]
    #<exp> - накапливающее выражение
    #for <var> in <iterable> ~ заголовка for
    [c*2 for c in 'abc'] >> ['aa','bb','cc']
    #думаю накапливает все результаты а затем отдает (не в этом примере-т.к. exp справа обязаны вычислиться до присвоения)
    L = [i for i in [0,1,2]]
    L = [i for i in L]      >> L
списки:в отличие от строк конкатенация требует +
    [1] [2] >> TypeErr
var со строками требуют + при конкатенации
    'a' 'b' >> 'ab' #неявное соединение, удобно при использовании скобок
    a,b = 'ab'
    a b >> SyntaxErr
    a 'b' >> SyntaxErr
    a += 'b' >> 'ab'
range([start,]stop[,step])
    #2.X ~ list(range()) в 3.X
    #0.X+
    #~xrange в 2.X
    #генерирует серию последовательных int начиная с start, не ВКЛЮЧ stop,
    #step !=0
    #поддерживает index,__hash__(),len,count(Нахрена? => возвращает 1|0)
    #не итератор, а вообще мутант(гибрид итератора и list?)
        R = range(3)
        iter(R) == R    >> False
        R[0],R[-3]       >> (0,0) не истощается
    #.count(elt) по идее всегда возвращает 0|1
    #.start;.step;.stop - атрибуты obj
    #при отрицательных значениях шага start/stop как-бы меняются местами
        *range(2,100),*range(100,2,-1)  >> (2...100),(100...2)
xrange([start,]stop[,step])
#~range 3.X
можно доставать данные из вложенных коллекций с помощью включений
применение операции к эл-там коллекции и накопление результатов
    выбор столбцов в бд
    изменение значений в полях бд
    разбор вложений в сообщениях элекронной почты
map(fx,<iterableObj>[,<iterableObj>,[...]])
#итерационный контекст, возвращает итератор
#родственна filter и включениям, генерирует результаты прогона параллельных элементов iterable через fx по одному по запросу(предоставляет данные по требованию), по сути извлекает параллельные элементы, объединяет их в кортеж и отдает fx
#1.0+, первоначальный, относительно прямолинейный представитель fx парадигмы Python
#может быть быстрее циклов и даже включений, появлению способствовал Lisp
#отображение fx по <iterableObj>; использует функциональную методику написания кода - fx передающая obj другим fx
#при получении несколько iterable передает соответствующие эл-ты  как индивидуальные args и ожидает fx c числом args = числу iterable
    list(map(pow, [1,2,3], [2,3,4]) >> [1, 8, 81]
#2.X сразу создает список и может исполнять роль zip(удалено в 3.X), в отличие от zip дополняет кортежи None до длинных длиннейшего iterable
#первый arg - None|Callable
    #если вместо fx - None - вырожденная форма map, избыточна, конфликтует с прикладным назанчением map
        map(None,(1,2),(3,4,5))   >> [(1,3),(2,4),(None,5)]
        #не является специальным случаем т.к. походу сначала объединяет элементы из iterable в кортеж который затем передает в fx
            map(lambda *args: sum(args),range(1,3),range(3,5))  >> [4,6]
    #разумеется это может вызвать исключение
        map(sum,(1,2),(3,))     >> TypeErr: 'int' obj is not iterable
        #искючение не бред т.к. второй arg sum - start
            sum(2,None) >> TypeErr:int is not iterable
            sum(None,2) >> TypeErr:None is not iterable
            sum((1,None))   >> TypeErr:unsupported type for +: int,None
            #т.е по сути аргументы передаются как кортеж, но исключение - хуйня => (возможно стоит узнать подробности)? - хотя это устаревшая хуйня, и все эти доводы не в ее пользу - думаю лучше просто не пользоваться
    #3.x
    #класс, возвращает генератор
        #т.к. obj итератор(?) ошибки нет
        map(None,range(10)) >> <map obj ...>
        list(map(None,range(10)) >> TypeErr: None not callable
    #эмуляция map из 2.X но копирующий поведение zip 2.X в 3.X
        list(map(lambda *args: args,(1,2),(3,4,5))) >> [(1,3),(2,4)]
        #не переборщи со скобками
        list(map((lambda *args: args),((1,2),(3,4,5)))) >> [((1, 2),), ((3, 4, 5),)]
    #полная эмуляция map из 2.X
        #подготовка iterable
            a,b = list(range(4)),list(range(5))
            if a<b: a += [None] * (len(b)-len(a))
            else:  b+= [None] * (len(b) -len(a))
            list(map(lambda *args: args,a,b))
    #тупой пример
        list(map(print,[1,2])>> 1 >> 2 >> [None,None]
    #как передать ключевые аргументы в fx с помощью map?
        map(print,('a',**{'end':'&')))      >> SyntaxErr
    #альтернативы
        counters = [1,2,3,4]
        updated = []
        for x in counters:
            updated.append(x+10)
        #отдельная fx(костыли), ведет себя не совсем ~
            def mymap(func, iterable):
                res = []
                return [func(x) for x in iterable]
        #map
        list(map(lambda x: x+10),counters)
генераторы vs other
#нет смысла использовать генераторы if все val требутся сразу
map vs включения
#используй то что в результате выглядит короче
    map
    #может выполняться быстрее(if альтернативы требуют вызова fx)
    #меньше кода?
    #менее универсальна т.к. использует вызов fx, а не произвольное exp
    #может требовать больше кода
    включения
    #могут быть избыточны при использовании fx
    #может быть быстрее map
    #используй if можно обойтись exp
    #в некоторых случаях м.б. заменен другими fx инструментами(напр. filter)
    примеры
        (x for x in range(5) if x % 2)
        filter((lambda x: x % 2), range(5))
        map((lambda x: x if x % 2 else None), range(5)) #затем удаление None
        #возведение чисел в квадрат
        [x ** 2 for x in range(10) if x % 2]
        list( map((lambda x: x**2), filter((lambda x: x % 2), range(10))) )
    можно комбинировать когда это уместно
        #короче и яснее
        map(func, (x ** 2 for x in obj))
        #длиннее и менее читаемо
        (func(x) for (x ** 2 for x in obj))
включения генератора м.б. медленнее списковых включений используй для
    больших данных
    снижения задержек в ущерб производительности
filter(function|None, iterable) -> filter obj
#родственна map и включениям;использует функциональную методику написания кода - fx передающая obj другим fx, накапливает результаты отображая iterable на function
#появлению способствовал Lisp
#2.X возвращает список вместо filter obj
#класс, возвращает iterator yielding чьи эл-ты для function(item) = True, если fx = None -> возвращает все True элты;фильтрует эл-ты на основе проверяемой(ющей) fx
#может использоваться как альтернатива цепочке or;для выбора истинных значений из набора кандидатов неизвестных до момента выполнения возвращая все истинные;в отличие от цепочки or возвращает все истинные значения
    list(filter(bool,[1,0,[])) >> 1
    list(filter((lambda x: x > 0), range(-5, 5)))   >> [1,2,3,4]
    #эмуляция
    def myfilter(func, iterable):
        return (x for x in iterable if func(x))
    #альтернатива - включения
        ''.join(x for x in 'aa bbb c'.split() if len(x) > 1)
        ''.join(filter(lambda x: len(x) > 1, 'aa bbb c'.split()))
        #добавление шагов обработки делает включения выгоднее
            ''.join(func(x) for x in line.split() if len(x) > 1)
            ''.join(map(func, filter(lambda x: len(x) > 1, line.split())))
отображение fx на iterable ~ отображению iterable на fx(в конспекте-но по идее так и есть)
reduce(<function>,<seq(iterable?)>[,<initial>]) -> value
#2.X встроенная fx(см. functools)
functools
#библиотека fx инструментов
    reduce(<function>,<iterable>[,<initial>]) -> value
    #комбинирование эл-тов
    #прогоняет пары эл-тов через fx;использует функциональную методику написания кода - fx передающая obj другим fx
    #накапливает результат отображая fx на iterable
    #на каждом шаге передает результат fx и следующий эл-т iterable, начальное значение инициализируется первым эл-том iterable
        #передает в fx первые два эл-та
        #затем результат и 3й
        ...
    #<initial> начальное val вместо первого эл-та iterable ~ стандартный результат для пустых iterable
        reduce(lambda x,y: x*y, [1,2,3],-1)     >> -6
    #2.X встроенная fx
     from functools import reduce
     reduce                  >> <built-in function reduce>
     reduce((lambda x, y: x + y), [1,2,3,4])        >> 10
     reduce(lambda x, y: x*y, [1,2,3,4])            >> 24
     reduce(None,[1])                           >> 1
     reduce(None, [1,2])                        >> TypeErr: 'None' is not callable
     #только по 2 эл-та
     reduce((lambda x,y,z:0),[1,2,3])   >> TypeErr: missing 'z'
     reduce(lambda *args:args,[1,2,3,4,5]) >> ((((1, 2), 3), 4), 5)
     reduce(lambda *args: print(args, end=','),[1,2,3,4,5])     >> (1, 2),(None, 3),(None, 4),(None, 5),
     open(path).write('abc')
     reduce(lambda x,y: print(x,y,end=';'), open(path).read())  >> a b;None c;
    #эмуляция reduce
        f = lambda *args:args
        L = [1,2,3,4,5]
        def myreduce(func, iterable):
            L = list(iterable)
            res = L[0]
            for elt in L[1:]:
                res = func(res, elt)
            return res
        myreduce(f,L)               >> ((((1, 2), 3), 4), 5)
operator
#модуль standart lib предлающий fx соответствующие встроенным выражениям, м.б. полезен при использовании fx инструментов
#может заменять простейшие lambda
    import operator, functools
    functools.reduce(operator.add, [2,4,6]) >> 12
генератор ПРИНАДЛЕЖИТ итераторы
    итератор генератора - сам генератор
    #а так и не скажешь
    #а зря - range - мутант
        I,G = iter(range(5)),(i for i in range(5))
        type(I),type(G) >> <class 'range_iterator'>,<class 'generator'>
        isinstance(G,type(I)),isinstance(I,type(G)) >> False,False
next(<iterator>[,<default>])
#2.6+
#возвращает следующий эл-т итератора(не iterable obj) по одному за вызов, начиная с первого, запоминает состояние; реализует ручной механизм итерации
#может использоваться для инициализации генератора как и send(None)
#более нейтрален к версии Python вызывает встроенный метод __next__(3.X)|next(2.X)
    a = (i for i in range(2))
    next(a) >> 0
    next(a) >> 1
    #вызывает исключение при истощении итератора
        next(a) >> Err:StopIteration
    next(a) >>
    next((i for i in range(3))) >> 0
    next((i for i in range(3))) >> 0
ключи словаря - мнемонические ключи ~ имена полей
запись в виде литерала - синтаксическая конструкция для создания соответствующего obj
    d = {'a':1,'b':2}
словари индексируются по ключу
словари не поддерживают конкатенацию (и размножение)
реализация поиска, как индексирования dict по ключу - зачастую самый производительный вариант
zip(iter0[,iter1,[...]])    -> <zip obj>
    #производит связывание, упаковка, операция обратная *, генерирует серию кортежей из параллельных эл-тов извлеченных из iterable
    #итерационный контекст и возвращает iterator упорядоченно возвращающий результаты
    #проецирует iterable по столбцам - для n аргументов строит n-арный кортеж
    #усекает результирующие кортежи по длинне кратчайшего iterable
    #развертывание сжатых кортежей,например для отмены действия прошлого вызова zip
        a,b = (1,2),(3,4)
        *zip(a,b),      >> ((1,3),(2,4))
        *zip(*zip(a,b)),  >> ((1,2),(3,4))  #(*zip(*zip(a,b),) == (a,b)
        #a,b = zip(*zip(a,b));a,b   >> ((1,2),(3,4))
        #комбинирование эл-тов 2х матриц(см. включения)
            M = [('a', 'b'), ('c', 'd')]; N = [('A', 'B'), ('C', 'D')]
            [[elt0 + elt1 for (elt0,elt1) in zip(row0,row1)] for (row0,row1) in zip(M,N)]
                >> [['aA', 'bB'], ['cC', 'dD']]
    #2.0+
    #используется для
        реализации параллельных(в одном цикле) обходов
        #для реализации параллельных обходов во времени => многопоточность
        для работы с sql
            #таблицы результатов запроса - {xn}, внешний список - таблица бд, вложенные кортежи - строки данных для извлечения которых используется распаковка
        создания dict
    #2.X
    #возвращает список кортежей
enumerate(iterable [,start]) -> <enumerate obj>
#2.3+, генерирует значения и индексы(смещения) элементов iterable -(iterator for index, value of iterable) ;возвращает генераторный obj или итератор
#start - то что может быть интерпритировано как int, например bool, но не float, включая отрицательные
#по сути добавляет индексирование для iterable с шагом +1, избавляя от необходимости ручного подсчета
#вспомогательная fx для поддержки двойного режима использования(т.е. когда одновременно требуется и элемент и смещение) заменяет range/простые циклы в этой роли
    i = 0
    for item in obj:print(item,i);i+=1
    #
    for offset,item in enumerate(obj):print(item,':',offset)
janitor - перевод?
вложенные структуры данных распологаются в разных областях, по идее в одной области хранятся только указатели
в сценарных яп все операции управления mem и создания структур данных выполняются автоматически
a = 'abc'
a = 0 #obj 'abc' удаляется
сборщик мусора удаляет obj на который больше не ссылается ни одна ссылка немедленно
восстановление mem ~ возвращение mem ~ очистка mem
pickle
#сис-ма постоянства obj Python,поддержки обобщенного хранилища obj
#способ храниения почти любых obj Python напрямую(без промежуточных преобразований) в файлах/бд автоматически транслирует obj в/из потоков байт(строковый тип bytes) в патентованный(wtf?) формат разработанный специально для Python
#кажется использует метод __reduce__
#сложные obj вроде классов вроде сохраняются в виде ссылки
    class c():
        def __init__(self):
            self.x = 0
    store = pickle.dumps(c)
    del c
    c = pickle.loads(store) >> AttributeErr: Can't get attribute 'c'

#безопаснее eval|exec
#~универсальный способ форматирования и разбора данных
#документация вроде сожержит описание формата данных в виде литералов вроде DICT = b'd',EMPTY_SET=b'\x8f',etc
#требует использования файлов в bin режиме, в ранних(видимо очень)
    .dump(<obj>,<file>[,protocol=None,*,fix_imports=True])
    #сохранение obj в файл в pickle представлении
    #~.Pickler(file,protocol).dump(obj) но более эффективный
    #3.x
    #protocol 0...4, default вроде 3 - backward-incompatible(designed for python 3) двоичный протокол, создает bytes для всех протоколов в отличие от 2.X
    #2.X
        #вроде протокол по умолчанию=0 (создает ASCII текст) и допускает использование текстового режима файлов, в отличие от остальных протоколов
    #указание отрицательной версии протокола - выбирает самую последнюю доступную версию протокола
    #<file> - obj имеющий метод .write() принимающий одиночный байтовый аргумент, любой obj имещий io.BytesIO instance(может interface?)
    #if fix_imports=True и protocol<3 pickle попробует отобразить новые(3.x) имена на 2.x модули чтобы pickle data stream был доступен в 2.X
    #реализация включает трансляцию obj в bytes(со своим способом кодирования)
    .dumps(<obj>[,protocol=None,*fix_imports=True])
    #на первый взгляд ~ .dump, но возвращает pickle представление, а не пишет его в файл
    .load(file,*,fix_imports=True,encoding='ASCII',errors='strict')
    #более эффективный ~ .Unpickler(file).load()
    #протокол определяется автоматически
    #байты после pickled obj игнорируются
    #file должен иметь .read(<int>) и .readline(<noArgs>) возвращающие bytes, и иметь io.BytesIO interface
    .loads(data,*,fix_imports=True,encoding='ASCII',errors='strict')
    #~.load() но примает данные из программы а не файл => замена .load() для .dumps()
    #fix_imports,encoding,errrors - нужны для совместимости 2.X
    #encoding может принимать значение 'bytes' для чтения 8bit кодировок
    with open(path,'wb') as f:pickle.dump(d,f)
    with open(path,'rb') as f:res = pickle.load(f)
    with open(path,'w') as f:pickle.dump(d,f) >> Err#требует bytes
cPickle
    #2.x
    имя пакета:cPickle
    #модуль стандартной lib, оптимизированная версия pickle, может импортироваться напрямую для повышения скорости(что за бред?)
    #3.x
    переименован в _pickle
    #автоматически используется в pickle
сериализация - преобразование obj в строки байт и обратно
сериализация в xml
#глава 37
CSV
#формат, Comma Separated Value
shelve
#система постоянства obj Python;файловая сис-ма
#автоматически сопоставляет obj с файлами для обеспечения постоянства
#бд с доступом по ключу хранящая obj постоянства а не только str
#использует pickle(основана на нем?)
#хранилища shelve - iterable
d = {}
d['key'] >> err #извлечение не сущ obj вполне логично считается ошибкой
JSON(JavaScript Object Notation - сис-ма обозначений для JS obj)
#нейтральный к яп формат данных используемый для хранения записей в бд и передачи данных
#новее pickle,позволяет сохранять меньше типов Obj, но более переносим
MongoDB
#хранит данные с помощью нейтраной к яп двоичной сериализацией JSON-like документов(документной бд)
if
#оператор в конструкции if/elif/else != if в тернарных if/else != фильтр if включений
#обычно предпочтительнее других способов организации ветвления
тернарная форма if...else
#2.5+ позаимствован из C; выполняет укороченную оценку
#выполняет в порядке отличном от порядка x ? y : z в C
    #больше подходит для широко употребляемых шаблонов кодирования
    #для препятствования чрезмерного использования бывшими программистами C
#думаю стоит использовать в простых случаях
#=выражение if/else
    'correct' if 0 == 1 else 'incorrect' >> 'incorrect'
условный код - код содержаний выбор(if/else)
если не указано иное - операторы выполняются {xn}, операторы управления потоком - заставляют интерпритатор выполнять переходы в коде
условный переход - переход к коду в зависимости от условия
поток управления - {xn} выполнения кода интерпритатором => if/while/try/etc - операторы управления потоком
операторы управления потоком = операторы потока управления
<dict>.has_key(<key>)
#2.X ~ <key> in <dict> в 3.X
#3.X отсутствует ~ in
порядок в не упорядоченных коллекций зависит в том числе от версии Python
сортировка словаря
    d = {'a':0,'b':1,'c':2}
    l = list(d.items())
    l.sort()
    #or
    d = {'a':0,'b':1,'c':2}
    Ks = list(d)
    Ks.sort()
    for key in Ks:
        print(key,d[key])
    #or
    sorted(d.items())
sorted()
#возвращает список
#~list.sort(обращаться за справкой туда), но возвращает новый obj не изменяя старый и подходит для любых iterable
#может быть удобнее list.sort в некоторых контекстах
    #сортировка словарных представлений без преобразования в list
#str сортируется по Unicode коду=> Буквы в верхнем регистре имеют меньший код 'Я' раньше 'а'
    #2.x
    sorted(<iterableObj>,cmp=None,key=None,reverse=False)
    #возвращает list, сортирует obj разнообразных типов,полезно для сравнения словарей
        sorted(d.items())
    #3.x
    sorted(<iterable>,key=None,reverse=False)
    #основан на операции сравнения =>не сортирует obj разных типов
        sorted([1,'a']) >>TypeErr: unorderable types
reversed(<seq>)
#~list.reverse() для ЛЮБОЙ {xn}, возвращает итератор
    reversed('abc') >> <reversed obj at <adress>>
    reversed((1,2)) >> <reversed obj at <adress>>
    reversed([1,2]) >> <list_reverseiterator obj at <adress>>
#по идее должен использовать __reversed__
<class_name object at <adress>> - адрес - hash + '0'
.append() + .pop() реализуют LIFO, конец списка - верх стека
while универсальнее for
iterable obj - поддерживающий протокол итерации, отвечает на вызов iter значением которое продвигается вперед на вызов next и генерирует исключение при завершении;значения предоставляются на запросы(обычно инструментов итерирования)
#концепция появившаяся в python отновительно недавно(?) - обобщение понятия {xn}, основная концепция в Python
#obj - iterable если является физическим/виртуальным набором значений(производящим по одному результату в контексте итерационного инструмента)
#все iterable генерируют результаты
    #от итерация!
    все контексты итерации(напр включения списков/for/...) автоматически следуют протоколу итерации
    итерационные контексты используют протокол итерации для прохода по генератору(obj) if он поддерживает протокол, иначе итерация многократно индексирует(использует протокол индексирования) {xn} которую создает генератор(используя __index__?)
    

iter(iterable|callable,{xn})
#возвращает итератор типа соответствующего типу obj, имеющий метод next(то что вернул ему __iter__), дергая __iter__
    d = iter({'a':1,'b':2}) >> <dict_keyiterator obj at <adress>>
    next(d) >> 'b'
    next(d) >> 'a'
    next(d) >> Err StopIteration
#ничего не делает с итераторами/obj имеющими итераторы(пустая операция); возвращает текущий|дополнительный obj
    f = open(path)
    f is iter(f) is f.__iter__()    >> True #f - собственный итератор
пустая операция - операция не выполняющая никаких действий
генератор - предоставление данных по требованию снижает задержки(распределяя вычисления по всем итерациям цикла, вместо производства всех val в первой же итерации) и экономит mem
включения и генераторы м.б. до x2 быстрее for(реализованы на C) и не нужно создавать пустые коллекции для накопления результатов и переменную счетчик, но могут быть и медленнее например в случае проверок if
time
#модуль standartlib
#может использоваться для анализа производительности
профилирование =? анализ
то что выводит подсказка в аргументах fx это не всегда реальные названия ключей(как понять, принимает ли fx аргументы ключевые слова)
думаю зачастую стоит использовать ключевые args где это возможно кроме самых распространенных и очевидных fx - т.к. сразу видно что куда передаю, врядли все наизусть помнять порядок позиционных args
subprocess
    .Popen
    #выполнение команд shell и чтение/запись их стандартных потоков данных
timeit
#2.4+ модуль может использоваться для анализа производиетльности
#создает свою искуственную среду
    .repeat(<code>,<setup>,timer,repeat,number,globals=)
    #по умолчанию выдает результаты 3х лучших прогонов -> довольно репрезентативно
    #setup - предварительный код не нуждающийся в проверке
        def f(x):return x*x
        import timeit
        timeit.repeat("for x in range(100):f(x)","from __main__ import f",number = 100000)
        #from __main__ import <obj> позволяет использовать код из текущего простраства имен(модуля верхнего уровня) внутри среды timeit
        #или запустить код в shell из интерпритатора
            #с трудом жрет многострочный код
            subprocess.getoutput('python -m timeit -s "x = range(1000)" "sum(x)"')
            or
            python -m timeit -c "$(cat file_name.py)"
            or
            python -m timeit -s "import <filename>" "<filename>.<function|obj>()"
    .Timer()
    #дает кумулятивное а не min время
    .timeit(stmt=<func>,setup=,number=)
    #вызывает <func> number раз
    .default_timer()
    #вроде возвращает метку времени
    НАКЛАДНЫЕ РАСХОДЫ
        #узнать сколько времени уходит на x+=1
        #-s кажется устанавливает setup
            python -m timeit -s "x = 0" "x += 1" >> 0.0476 #суммарное время x+=1
            python -m timeit -s "x = 0" ""      >> 0.014 #накладные расходы
            python -m timeit -s "x = 0" "x"     >> 0.0166 #накладные расходы + поиск x
            МЕТОДЫ МУТИРОВАНИЯ ОПАСНЫ
                python -m timeit -s "x = [0]*100000" "while x: x.pop()" >> 0.0436 usec per loop #неправильно т.к. x пустой list после первой итерации -> требуется повторная инициализация
                python -m timeit "x=[0]*100000" "while x: x.pop()" >> 9.79 msec #вместе с накладными расходами
                python -m timeit "x = [0]*100000" >> 261 usec #только накладные расходы
              при оценке времени сортировки нужно использовать random.shuffle между проверками(т.к. кеширование)
    #сравнение скорости включений/циклов   pow/x**y % z
        timeit.repeat('a=[pow(x,y,z) for x in range(1,100) for y in range(1,100) for z in range(1,100)',repeat =1 ,number=1) >> 1.61
        timeit.repeat('a=[x**y % z for x in range(1,100) for y in range(1,100) for z in range(1,100)',repeat = 1,number =1) >> 1.65
        timeit.repeat('''l=[];for x in range(1,100):for y in range(1,100):for z in range(1,100):l.append(pow(x,y,z))''',repeat=1,number=1) >> 1.73
profile
#модуль для устранения узким мест производительности
очевидно что если коллекция не упорядочена - она не может содержать unhashable, ведь иначе будет сложновато как-то индексировать значения
типы расширений - типы основанные на базовых
    fileobj
связанные расширения C могут предоставлять собственные типы
tuple
    для создания одноэлементного кортежа требуется хвостовая ',', элемент в скобках - интерпритируется как exp т.е. число скобок для единственного эл-та вообще не имеет значения
        1,
        (1,) + (2,3)
        1, + (2,3) >> Err
        1,2 + 3,4 >> 1,5,4
    создание пустого кортежа
        ()
    #не нуждается в скобках в случае синтаксической однозначности
    #кортеж - простое фиксированное объедиение obj в отличие от списков(изменяемая структура данных)
    #слово кортеж заимствовано из математики
    tuple.count()
    #появился 2.6+,3.0+
    #~list.count()
    tuple.index()
    #появился 2.6+,3.0+
    #~list.index()
    ПРИМЕНЕНИЕ
        строки таблиц
        рбд
        там где можно использовать только hashable/tuple
            dict keys
            выражение форматирования
            fx
старое соглашение Python(min до 2.6/3.0)
    immutable НЕ СОДЕРЖ методов
mutable внутри immutable меняются
иммутабельность обеспечивет ограничение целостности
константность в python ассоциирована с obj а не var
в С константность ассоциирована с var, a не obj(проверить)
именованные кортежи основаны на tuple
struct
#модуль для создания(формирования)/распаковки(разбора) упакованных bin данных, созданных например программой на C/полученых по сети
#3.2+ принимает только байтовые строки вместо str => файлы нужно открывать только в режиме b
#при превышении  размеров => struct.error: out of range
    #формат
        дополняющие байты
        #
        float
        #
        ...
    fmt = '>i4sh'
    #обозначает пакет с обратным порядком байт, 4байтовый interger,4х символьную строку bytes,2х байтовое int(hex?)
    packed = struct.pack(fmt,7,b'spam',8) #передаем tuple
    packed >> b'\x00\x00\x00\x07spam\x00\x08' #первые 3 нуля видимо служебная информация, spam интерпритируется \x00 видимо завершение строки
    struct.unpack(fmt,packed) >> (7,b'spam',8) #снова tuple
упакованный != сжатый
bin данные - неформатированные байты фиксирующие значения не являющиется Python Obj
вернуть код сивола
    '\xc4'.encode('latin1') >> b'\xc4'
думаю стоит опускать параметры по умолчанию
    open(path) вместо open(path,'rt')
        но только там где нет отличий между ветками python, напр:
            .decode()/.encode()
2.X строки по умолчанию вводятся и отображаются как набор управляющих символов с префиксом u'' можно ли это изменить с помощью unix-like комментария=>нет
unix-like комментарий в idle?
в интерактивном интерпритаторе можно вывести print('ф') без unux-like комментариев
python поддерживает не ascii имена файлов
3.X поддерживает unicode имена obj
в высокоуровневом яп(а может и любом другом) - нужно думать на высоком уровне
    строки = текст, а не {xn} байт
fifo - очередь, похожа на файлы/сокеты
lifo - стек
#использование списка как структуры данных типа стека
    l = [1,2,3,4]
    while l:
        front, l = l[0], l[1:] #~front = l.pop(0)
        print(front,l)
            >> 1 [2,3,4]
            >> 2 [3,4]
            ...
файлы с доступом по ключу?
дескрипторные файлы
#поддерживают блокировку и другие low-level инструменты
блокировка
#низкоуровневый инструмент
ооп бд?
сокет
#интерфейс для межпроцессного и сетевого взаимодействия(синхронизации), похож на fileobj
set
    #сравнения проверяют на множество/подмножество, а не относительно
        a,b = {'a'},{'b'}
        a > b, a < b >> False,False
    #используются для
        #фильтрации дубликатов
        #сравнения содержимого <iterableObj> нейтральное к порядку
            set(dir(dict)) - set(dir(set)) >> {'items', 'values', 'popitem', '__setitem__', '__getitem__', 'get', 'keys', '__delitem__', 'setdefault', 'fromkeys'}
        #отслеживание позиции при обходе циклических структур(напр графов) - отслеживание посещееных эл-тов для избежания входа в цикл(более-менее понятная альтернатива dict)
            #транзитивная перегрузка модулей
                list не эффективен т.к. поиск требует прямолинейногопросмотра
                глава 25
            #вывод деревьев наследования
                глава 31
    #литералы и включения set появилось в 3.X и 2.7
        < 2.7 создаются с set(), <3.X отображаются тоже с set()(хотя возможно новый синтаксис тоже работает - проверить)
            set('abc') >> set(['a','c','b'])
    #коллекция с числовыми операциями,ближе к числам чем к коллекциям, не {xn}|mapping
    #~dict без val => используют соотв литералы
    {'a'}|{'b'} #объединение set
    {'a'}&{'b'} #пересечение set
    {'a'}>{'b'} #надмн-во
    методы мн-в принимают iterable, операторы только set
        .add(<obj>)
        #добавляет элт
        .update(<iter>)
        #довавляет элты из <iter>
        .remove(<elt>)
        #one arg, удаление сущ эл-та, if elt несущ => KeyError
        .union(<iter>)
        .intersection(<iter>)
        #
        .issubset(<iter>)
        #
        .issuperset(<iter>)
по идее все операторы пергружены методами определенными внутри типов, где первый аргумент = self
это по идее дескриптор
    set.issubset(a,b) ~ a.issubset(b)
set(<iterable>)
#конструктор set в < 2.7 и 2.7+/3.X
    set('spam') - set('ham') >> {'p','s'} #разность коллекций
    set('spam') == set('aspm') >> True #сравнение мн-в букв

frozenset
#фиксированные мн-ва, в отличие от set может быть вложено в set|frozenset
hashable - по идее ЛЮБОЙ obj содержащий соотв метод, пользовательские классы могут включать протокольные методы сообщающие о наличии в них хешируемых значений(immutable)
unhashable ключи нарушали бы смысл отображений
if нужен dict поддерживающий изменение ключей - можно использовать мн-во кортежей
объект типа - hashable
    {int,float} >> {<class 'int'>,<class 'float'>}
obj модуля - hashable => может быть ключом словаря/etc
по идее hashable и кеширование связаны
    при генерации значений Python часто использует кешированный immutable obj вместо выделения новой области mem, при это все работает так будто это новый obj(если не сравнивать hash/указатель)
    более длинные строки не кешируются(как и строки с пробелами)
        a,b,c,d = 'hi','hi',256,256
        e,f = 257,257
        a is b,c is d >> True, True
        e is f >> False
        g,h = 'asdfasdfsadf','asdfsadfsadf'
        g is h >> True
        g,h = ' a', ' a'
        g is h >> False
    кажется хеш !~ указатель - ЛЮБОЙ obj имеет адрес(указатель(к тоторому как-бы нет доступа)), но не любой имеет hash(к нему вполне можно получить доступ)
КЕШИРОВАНИЕ
    a = 42
    del a
    sys.getrefcount(42) >> 14 #obj еще сущ
    небольшие int,небольшие целые float, и строки кешируются(видимо те что были созданы(на все возможные просто не хватило бы mem) - хранятся в системной таблице и удаляется не сразу
    кешированнные obj удаляются при нехватке mem?


decimal
#модуль,десятичные числа - float с фиксированной точностью, позволяют обойти ограничения и неточность float, можно указать каким образом усекать число
#медленнее float, но может быть точнее(хотя для этого все args должны быть str) или число разрядов должно быть зафиксированно
#в Python < 3.3 медленне в 10-100 раз
#имеет инструменты для обработки ошибок
    .1*3 - .3 >> 5.551115123125783e-17
    from decimal import Decimal as d
    d(.1) + d(.1) + d(.1) - d(.3) >> Decimal(5.551115123125783e-17)
    d('.1')*3 - d('.3') >> Decimal(0.0)
    #точность определяется числом с max числом разрядов
        d('.10')*3 -d('.3') >> Decimal(0.00)
    .Decimal(<obj>='0')
    #obj может быть строкой/int/float/tuple/etc, создает Decimal obj
        .from_float(<float>)
        #2.7+,3.1+ преобразование в dec из float также требует установки точности
        #походу делает это автоматом в новых версиях Python
    .getcontext()
    #содержит конфигурацию Decimal
        decimal.Decimal.getcontext() >> Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[FloatOperation], traps=[InvalidOperation, DivisionByZero, Overflow])
        .getcontext().prec
        #фиксация значения числа знаков после запятой
            decimal.Decimal('1.00')/decimal.Decimal('3.00') >> Decimal('0. 3333333333333333333333333333')
            decimal.getcontext().prec = 2
            decimal.Decimal('1.00')/decimal.Decimal('3.00') >> Decimal('0.33')
                #альтернатива округлению/форматированию
                    a = 1999 + 1.33 >> 2000.33..... #в старых версиях Python
                    decimal.getcontext().prec = 2
                    decimal.Decimal(str(a)) >> '2000.33'
    .localcontext(ctx=None)
    #ДИСПЕТЧЕР КОНТЕКСТА Работает и ДЛЯ DEC(разобрать подробнее)
    #возвращает менеджер контекста устанавливающий контекст по умолчанию как условие with
    #возможно сбрасывать точность при выходе из with, если контекст не установлен - используется копия контекста по умолчанию
                decimal.getcontext().prec >> 28
                with decimal.localcontext() as ctx:
                    ctx.prec = 2
                    decimal.getcontext().prec >> 2
                decimal.getcontext().prec >> 28
with...as (as обязателен?)
#2.6+,3.0+,IDLE 2.5+?
#2.5+ доступен как backport __future__
#схема диспетчера контекста~(по идее) диспетчер контекста
#требует поддержки ее протокола(метод .close()?)
#альтернатива try/finally, более новая форма обработки исключений
with использует метод __exit__ и по идее поддерживает ЛЮБОЙ obj с ним
#относится к средствам обработки exept, уровень логики гарантирующий закрытие файла
with <obj> as <alias>:
    <code>
    оператор применяющий диспетчер контекста
fractions
#модуль, дробные числа - рациональные, как и decimal решает проблемы точности float, похож на decimal
#простая дробь очевидно проще чем float с кучей разрядов
    .Fraction(<numerator>=0,<denominator>=1|<num>|<str>)
    #конструктор рациональных дробей,<numerator> и <denominator> должны быть рациональными включая строки
        #упрощаются автоматически
        fractions.Fraction(3,6) >> Fraction(1,2)
        fractions.Fraction(2,3) + 1 >> Fraction(5,3)
        fractions.Fractions(2,3) + fractions.Fraction('.5') >> Fraction(7,6)
        print(fractions.Fraction(2,3)) >> 2/3
        #почти всегда хранит неоравдано(на первый взгляд) большие числитель знаменатель
        a = fraction.Fraction(0.1) >> Fraction(3602879701896397, 36028797018963968)
        a.numerator/a.denominator >> 0.1
        .real
        #понятия не имею зачем нужно
            a = fractions.Fraction(0.1)
            a.real == a >> True
        .from_float()
        #принадлежит инстансу abc.ABCMeta
        #создает fraction из float
            fractions.Fraction.from_float(1.0) >> (1,1)
            a = fractions.Fraction() # a = Fraction(0,1)
            a.from_float(0.5) # a = Fraction(1,2)
        .limit_denominator(max_denominator=1000000)
        #max_denominator - рациональный, больше 0 включен в диапазон
        #возвращает упрощенную дробь ограничивая max значение знаменателя(с потерей точности)
            #или восстановлением
                x = fractions.Fraction(1,3) + Fraction(*(4/3).as_integer_ratio()) #Fraction(22517998136852479, 13510798882111488)
                x.limit_denominator() >> Fraction(5,3)
                x.limit_denominator(1) >> Fraction(2,1)
                x.limit_denominator(y.denominator) #Fraction(22517998136852479, 13510798882111488)
используй сильные строны структур данных
    подсчитать число колличество разных букв в строке
        defaultdict позволит сделать это за одну итерацию(или dict с get)
    удалить дубликаты
        set/frozenset(если порядок не важен)
    обход цикличных структур данных
        list неэффективен
        dict|set
    изменение строк
        str неэффективен т.к. при каждом изменении будет создаваться полная копия строки
        bytearray умеет только 8-bit текст
        list неплохой вариант
если решение сложно понять - скорее всего оно неудачно
походу метод __bool__ реализован как __bool__(a):a != 0 ; кстати есть не у всех obj
    #при отсутствии __bool__ вызвается __len__ (для проверки на пустоту очевидно)
    #позволяет задать булевскую природу инстансов пользовательских классов
    #при отсутствии __len__/__bool__ по умолчанию считается True(интересно почему? инстанс может быть вообще тупо пустым)
    #3.X ~__nonzero__ из 2.X
    #2.X отсутствует
        class Test():pass
        t = Test()
        bool(t) >> True
инстанс = экземпляр класса = obj экземпляра созданный из класса
булев тип ~ булевский
bool exp != exp возвращающее bool, это скорее выражение оперирующее значениями истинности/ложности

bool
    #2.X var ПРИНАДЛЕЖ __builtin__
    #3.X keywords
    #1,0 со специальной логикой отображения
        #ведут себя аналогично int
        [x,y][True] >> y
    #лучше по возможности использовать bool в проверках, но только там где это улучшает читаемость
        if x: <code>       #GOOD
        while True: <code>   #GOOD
        if x==True: <code>   #BAD
        while 1: <code>     #BAD
    #не может иметь наследников
        class test(bool):pass >> TypeErr: type 'bool' is not acceptable base type
    #подкласс int где 1,0 отображаются как True False в определенных контекстах, в коде 1,0 ~ True,False
        __str__ и __repr__ переопределены для 1 и 0
        ~ двум var со значениями 0 и 1
            type(True) >> <class 'bool'>
            isinstance(True,(bool,int)) >> True
            True == 1 #значения равны
            True is 1 #разные obj
    #True/False - внутренняя характеристика любых obj
        любой пустой obj/0/None - False и наоборот
            bool([]) >> False
            bool([()]) >> True      #выделить!
bool()
#возвращает True if obj == True и наоборот, по сути преобразование в bool
#проверка на пустоту или ==0
None
#obj-заполнитель,занимает место в mem(сколько?), похож на C указатель NULL, тип данных с единственным значением, похож на Ellipsis
#возвращается fx без yield/return
#используется для отметки что fx ничего не нашла
создание разряженного списка
    [None] * 100 >> [None,None,...]
КАК НАРУШИТЬ ГИБКОСТЬ КОДА
    type()
    #type(name,bases,dict) >> новый тип(это что создание типа? - звучит бредово - наследование выглядит лучше)
    #type(obj) -> возвращает объект типа для obj
    #вроде менее предпочтителен чем isinstance
        type
        #obj возвращаемый type(), содержит тип другого obj
            type([1,2]) == list >> True #нарушает гибкость кода
        #3.x
            type(list()) >> <class 'list'> #нарушает гибкость кода
        #2.x
            type(list()) >> <type 'list'> #нарушает гибкость кода

    в python 3.x типы были полностью объединены с классами(нового стиля) >> типы можно создавать как производные классы(а раньше?)
    isinstance(obj,<class>)
    #рекомендован вместо type() и types
        isinstance([1,3],list)>> True
нарушение гибкости кода
    ограничение работой только с одним типом
        проверка на специфический тип
в Python используется взаимодействие с интерфейсами obj, а не типами
    Python полиморфичен => не нужно думать о типах => можно писать код нечувствительный к типам
    важно что obj делает, а не чем является

интерфейс
#способ доступа
#поддерживаемые операции
#=протокол
    obj имеющие одинаковый интерфейс, будут работать через него одинаково
    методы/fx
ооп сокращает врямя разработки благодаря поддержки программирования через настройку
атритуты obj = информация о состоянии
ссылки на attr с помощью точечной нотации фактически могут задействовать наследование
    class List(list):pass
    L = List()
    L.append    #доступ к attr унаследованному от базового класса
методы obj = линии поведения
КЛАССЫ
    вызов класса создает экземпляры класса со своей NS наследующие аттр класса(записывают состояние obj в виде attr)
    тело класса оценивается при вызове
        class C():
            def __init__():pass
        c = C()     >> TypeErr  #забыл self
    методы класса автоматически получают экземпляр в self
    пользовательский класс - базовые классы + методы(логика) + данные
    классы могут быть эффективнее для храниения данных об объектах чем dict
    "ПСЕВДОНИМЫ" КЛАССОВ
        #ссылка(вроде нет недостатков)
        l = list
        l() >> []
        type(l()) >> <class 'list'>
        #наследование(меняет имя типа=> может ломать код)
        class l(list):pass
        l() >> []
        type(l()) >> <class '__main__.l'>   #возможно можно переименовать с помощью .str/.repr/etc
        #подмена имени типа
        list = l
     #кажется класс по умолчанию наследуется от builins.object
        class test():pass
        help(test)      >> ...class test(builtins.object):
     #могут произвольно кодировать __iter__,__getitem__,__contains__,... определяя смысл итерации для своих данных
     #лутц пишет классы вообще без наследника
     #что логично - усложнение без надобности - излишне
     #PyCharm ругается на лишние скобки!
        class Test:
            pass
        #вместо
        class Test(object):
            pass
обычно роль контейнера верхнего уровня для хранения данных - исполняет интерфейс к файлу/бд
наследование = настройка расширением(расширение по путем написания новых классов, а не переписывания старых)
obj python не всегда obj в ооп смысле(нет наследования)
ЧИСЛОВЫЕ ТИПЫ
числа в Python - категория похожих типов
модули для вычерчивания?
точность int = число разрядов
вызов функций конструкторов - set()/list()/...
    list(<iter>)
    set(<iter>)
    frozenset(<iter>)
    ...
конструктор - то что создает экземпляр класса, генерирует запрос конструирования obj, также функция
float
#в CPython реализован как double C и обеспечивают соотв точность
    3.14e-10
    4.0e+210
    #ошибки точности => нуждается в округлении|использование других типов
    1.1 + 2.2 == 3.3 >> False #1.1 + 2.2 >> 3.30...03
    #числа с периодом
     1/3.0 >> 0.3333333333333333 #16 разрядов после нуля #float для совместимости с 2.X
    .as_integer_ratio()
    #возвращает пару (numerator,denominator) int,denominator всегда положителен
    #точность соответствует float
        1.0.as_integer_ratio() >> (1,1)
        float.as_integer_ratio(-.25) >> (-1,4)
        fractions.Fraction(*(1.0).as_integer_ratio()) >> (1,1)
float()
#преобразование в float
#может принимать fractions.Fraction в качестве аргумента
    float('1.234E-10') >> 1.234e-10
complex
#реализованы как пары float, поддерживают все обычные математические выражения
#[действительная_часть +] мнимая_часть[J|j]
    3+4j
    3+4j*2
    3-2j
    3.0 + 4.0j
    3j
    3+0j
    type(3+4j) >> <class 'complex'>
унарные +/-
    --1 >> 1
    -+1 >> -1
cmath
#модуль, версия math для работы с комплексными числами
математика с плавающей точкой - не целочисленная, применятеся к float
long
#тип int 2.X неограниченной точности,автоматически преобразуется из int при переполнении
#можно создать вручную добавив к число l/L(err в 3.X) => проверка на тип long в 2.X ломает совместимость с 3.X, по всей видимости наследник int
    1l
    1L
long()
#2.X ~ int, но возвращает Long
литералы чисел в hex сс регистро-независимы
литералы bin чисел появились в 2.6+/3.0+
2.6+ oct int имеет формат совместимый с 3.X(его и стоит использовать)
    0oXX
в 2.X oct литералы могут записываться также только с нулем(легко спутать с dec=> Err в 3.X)
    0o77 ~ 077
oct(<int>)
#возвращает строку с <int> в oct сс
hex(<int>)
#возвращает строку с <int> в hex сс
bin(<int>)
#возвращает строку с <int> в bin сс
#возможно 3.0+,2.7
int(<num>[,<base>])
#преобразует <num> по основанию <base> в dec int, при указании <base>, <num> должен быть str, base = 0|2-36, 0 - интерпритирование строк как литералов int,игнорирует пробельные символы(например '\n')
#~ math.trunc() - отбрасывает остаток(усечение)
complex(real[,<image>])
#
complex(<real>[,<imagine>)
#возвращает комплексное число
<float>.as_integer_ratio()
#возвращает (числитель,знаменатель), хоть и огромные(может это для точности?)
    1.2.as_integer_ratio() >> (5404319552844595, 4503599627370496)
<float>.is_integer()
#возвращает True if <float> целое и наоборот
<int>.bit_length()
    1.bit_length >> SyntaxErr
    int.bit_length(1) >> 1
#возвращает число битов необходимых для представления int; ~ len(bin(<int>)) - len('0b')
выражение - комбинация obj и операций
<< побитовый сдвиг влево
    #умножение на 2 n раз
    1 << 2 >> 4
is,is not
#проверяет равенство ссылок на mem(идентичность obj) - строгая проверка на равенство
#тратит ~50/130 времени == т.е. быстрее на pentium p6200
#is not на 2% медленнее is; not жрет микроскопическое число тактов
==
#оператор сравнения значений по ссылкам, медленне is в ~ 130/50 2.6 раз
#проверка на эквивалентность
return
#немедленная передача одиночного(в отличие от некоторых других яп) результата обратно в вызывающий код
yield
#2.3+, оператор(<2.5)
#организует множественные выходы из fx
#передача результирующего obj обратно в вызывающий код и запоминает место где остановился;приостанавливает выполнение с сохранением состояния и возобновляет его между выдачами
#нарушил совместимость со старым кодом(видимо обратную)
#выражение(2.5+)/ключевое слово (не операция/оператор хотя по лутцу - х.з.) генераторных fx, возвращает эл-т переданный send;
    #можно вызывать как
        yield x
        A = yield x
        #должно вызываться с круглыми скобками if не единственное в правой части присваивания(см.send)
    #хотя yield возвращает None
#реализует генераторное поведение => создание пользовательских генераторов
#распространенное применение(неявное и потенциально полезное) yield - как альтернатива fx методов в iterable (?не уверен что до конца осознал формулировку) user-def-classes(для превращения этих методов в фабрики генераторов)(см.собственные генераторы)
#требует круглые скобки if не является единственной справа от =
#т.к. почти всегда выполняется на отдельной строке в виде оператора с выражением - трактуется как оператор
#делает fx доступной для протокола итерации
    #разумеется вернет весь список в первой же итерации - по сути не верное применение
    def fx(...):yield [...]
    #использование
    def squares(x):
        for i in range(x):
            yield i**2
    G = squares(5)
    type(G)           >> <class 'generator'>
    G               >> <generator object squares ...>
    next(G)           >> 0
    next(G)           >> 1
    #альтернатива итераторам
<ВыборIfTrue> if <условие> else <ВыборIfFalse>
#тернарный выбор,доступен 2.5+
else
#выбор по умолчанию, часть if
elif
#часть if
if/elif/else - проверки;выполняют код условия первой возвращающей True
оператор if = if...[elif...[else]]
множественное ветвление - когда выбора больше чем два
в Python нет оператора ~ switch|case из C/Pascal выбирающего действие на основе значения var(да и хрен с ним - он всегда казался мне избыточным - zen of python)
    обычно заменяется if/elif/else - т.к. более читаемо
    хотя реализация множественного ветвления м.б. основана на индексируемых коллекциях - может быть более гибкой чем жестко закодированные if/elif т.к. коллекции можно создавать динамически во время исполнения(структуры данных - добаляют гибкость), и короче; менее читаемо!; используется только в специфичных случаях
        #реализация на dict, для реализации default можно использовать .get(.has_key 2.X)| in | try/except
        choice = 'ham'
        print({'spam': 1.25,
             'ham': 1.99,
             'eggs': 0.99}[choice])
        #более сложные действия fx в словаре(см.dict)
сравнение коллекций происходит рекурсивно по короткой схеме до первого эл-та определящего результат или конца, str сравниваются по значению кодовых точек(ord)
сравнение относительных величин по идее больше меньше(сравнение величин) ? сравнение абсолютных величин ==/!=(проверка равенства)?
Python СОДЕРЖ три bool операции выражений:and,or,not
#выполняют укороченную оценку => непроверенные выражения не выполняются
    #if f1() вернет True, а от f2 требуются побочные эффекты -> код не верен
    if f1() or f2():...
        #нужно выполнить их предварительно
        tmp1,tmp2 = f1(),f2()
        if tmp1 or tmp2:...
and
#возвращает последний проверенный obj(первый истинный)(левый операнд если он False иначе правый)
or
#возвращает последний проверенный obj(первый истинный)(левый если он True иначе правый)
    print or 0  >> <built-in func print>
in,not in
#поиск
#пoдходит для iterable obj
    'abc' in 'asdfabcaad' >> True #поиск подстроки
требования к отступам не очень жесткие
    'abc'in'sfasfabc' >> True
< <= > >=
#сравнение, подмножество(подробнее -> sort/sorted)
^
#исключающее или, симметр разность мн-в
    bin(0b11111111 ^ 0b10101010) >> 0b01010101
|
#побитовое или объединение мн-в
    1|2 >> 3
&
#побитовое и(выбор общих битов), пересечение мн-в
    1&1 >> 1
    #позволяет проверять на четность(по идее быстро)
    2 & 1 >> 0
    3 & 1 >> 1
побитовые операторы != логическим
    1|2 >> 3
    1 or 2 >> 1
в 2.X
    сущ второй оператор неравенства <> - нерекомендуется
    `exp` ~ repr(exp) возвращает выражение в виде отображаемой строки
    x / y ИСПОЛЬЗУЕТ ОКРУГЛЕНИЕ С ПОНИЖЕНИЕМ для exp из int(вместо настоящего деления)(классическое) ~ math.floor(x/y) 3.X
        #int / float >> float
    2 / -4 >> -1
    10 / 4 >> 2
    10 / 4.0 >> 2.5
КРАТКО ПРО ДЕЛЕНИЕ 2.X 3.X
    (5/2),  (5/2.0), (5/-2.0), (5/-2), (9/3)
     2.5    2.5     -2.5   -2.5    3.0 #3.X
     2     2.5     2.5     -3     3  #2.X
ПОДДЕРЖКА 2.X И 3.X ДЛЯ ДЕЛЕНИЯ
    // идентично в 3.X 2.X
    x / float(y) #дает одинаковый результат в 3.X 2.X
    или
    2.X>> __future__

__future__
#кажется используется то ли для импорта необязательных компонентов еще не ставших стандартными, толи импорта новых возможностей в старые версии(это было бы так если это работает в любой старой версии=> скорее всего первый вариант)
#должен быть импортирован в каждом модуле где используется- меняет поведение python только в пределах module namespace, транзитивный импорт не поддерживается, даже через exec
    exec('from __future__ import division,print_function')
    print(11/3,)            >> (3,)
#выглядит получше альтернатив как по мне
#вроде используется только в 2.X и игнорируется 3.X
    #with...as в 2.5
    from __future__ import with_statement
    #поведение деления из 3.X
    from __future__ import division
        10 / 4 >> 2.5
    #print 2.6+
    print_function
.next(self)
#2.X ~.__next__() из 3.X
#предпочтителен в < 2.6
.__next__(self)
#метод используемый next(), а может и наоборот?(это бы объяснило os.popen и сломало мой мир)
#используется для создания пользовательских итераторов(генераторов)
#более гибок чем __getitem__
#2.X отсутствует
#генерирует StopIteration except после достижения конца итератора
классическое деление(округление с понижением для int выражений) != целочисленное деление(сохраняет тип)

сцепленные операторы(по идее != дополненное присваивание)
    <=
    x == y < z
    #может выполняться быстрее x == y and y <z т.к. y будет оценен на один раз
    a = b = c = [1]
    a is b is c    >> True
2.X
#поддерживает сравнение словарей, ~ сравнению упорядоченных коллекций
    {'a':1} < {'a':2} >> True
#поддерживает сравнение разных типов, числа преобразуются в общий тип(float?), и упорядочивает разнородные типы в соответствии с именами типов(тупо сравнивает строковые имена типов по ascii коду str>int)
#сравнение никогда не преобразует типы кроме случаев когда exp СОДЕРЖИТ числа only

    [1] > (2) >> True
    #но не все типы
    1 > 3j >> TypeErr: no ordering relation is defined for comlex
    [1] > (2) >> TypeErr: unorderable types #3.x

3.X
#нельзя сортировать один obj по содержимому другого(что?)
в выражения со смешанными числовыми типами obj сначала преобразуются к самому сложному типу
    3j - 1.0 >> (-1 + 3j)
    3j - 1.0 >> (-1 + 3j)
полиморфизм
    перегрузка операций в классах ~ реализация операций в классах = реализация obj
    все операции можно перегружать в классах Python и типах расширений C, для создания obj имеющих св-ва сразу нескольких базовых типов
        сложение/конкатенация
        индексация
типы расширений C типы реализованные на внешнем C подобном яп,для их создания нужно заполнить места указателей на fx С для выбора между наборами операций над числами,{xn},mapping
ДОКУМЕНТАЦИЯ>
#~протокол документации
    строки документации('...') != строки комментариев(#)
        строки комментариев/документации экранированные кавычками интерпритируются как obj, и на его создание уходит mem и такты cpu => микроскопически влияет на производительность, но может повлиять на тесты например timeit(Зато комменты остаются даже в байткоде:)) еще и жрут место в байткоде(может быть актуально для микроконтроллеров)
        комментарии экранированные '#' по идее не включаются в байт код - не влияют никак
        #раньше выносились предложения использовать языки разметки/шаблоны для строк документации вроде html/xml но т.к. нахер не нужно - не прижилось -> Тем более что PyDoc и так умеет генерить html
    документация(протокол) - часть общей синтаксической модели Python, создана для упрощения процесса документирования
    НЕ СУЩ общепринятого стандарта регламентирующего структуру документации
    документация python на русском?(и нужна ли она мне?)
    источники документации(как правило с растущей степенью детализации)
        КОММЕНТАРИИ #
            внутрифайловая документация;базовый способ документирования
            '#' не нуждается в экранировании в строках
            доступных только при ручном чтении файла
            используется для комментирования мелких фрагментов вроде конкретных выражений,
            использование ограничивается областью действия операторов/групп операторов вроде описания работы конкретного exp/var/...
            по идее выпиливаются при компиляции в байт-код(перепроверить конспект)
            #менее приоритетны для использования чем docstring
        dir(<obj>)
            #возвращает список attr доступных obj(классу) коих обычно дохрена
                dir('') == dir(str) >> True
            #по идее тоже что и locals() но без val
            #возвращает не все obj, как подсказка и интерактивного интерпритатора :(
                import datetime
                'time' in dir(datetime) >> True
                '__hash__' in dir(datetime)) >> False
                datetime.__hash__() >> 3713728
                dir(os.popen(...))              >> нет readline
                os.popen(...).readline()          >> Работает
                #все доступные obj
                dir(__builtins__)
            #Без аргументов выводит список var в области видимости вызывающего кода(obj) != locals()|globals()
            #т.к. __x__ шаблон именования деталей реализации - остальные имена(без __) зачастую относятся к методам(например в случае строк)
            #первый уровень документации Python
            #вывод документации по main
                print(__doc__)
        строки документации
        #внутрифайловая документация строки в определенных местах(в любой литеральной форме(не var|'#')(в начале файлов модулей, fx, классов, ЛЮБЫМ другим исполняемым кодом(че?) присоединяются к obj (автоматически помещаются интерпритатором в .__doc__) сохраняются во время выполнения; отображаются инструментами вроде PyDoc,для инспектирования; часть более широкой стратегии документирования
        #вроде не присоединяется к __main__ в итерактивном интерпритаторе
            #новый сеанс
            '''docstring'''
            __doc__ >> #None
            #но доступен для редактирования
            __doc__ = 'IDLE session'
            __doc__     >> 'IDLE session'
            __name__    >> '__main__'
            help(__name__)  >> NAME >> __main__ - IDLE session >> FILE >> (built-in)
        #основа качественного ПО
        #перед ними допускается размещать строки комментариев(# т.к. видимо выпиливаются при компиляции) ВКЛЮЧАЯ #!
        #используются для широкого документирования функциональности(на уровне функций/файлов/модулей)
            class hello():
                '''мой текст'''
            help(hello)
            >> Help on class hello in module __main__:
                class hello(builtins.object)
                 |  <мой текст>
                 |
                 |  Data descriptors defined here:
                 |
                 |  __dict__
                 |      dictionary for instance variables (if defined)
                 |
                 |  __weakref__
                 |      list of weak references to the object (if defined)
        #для корректного отображения => обычная история с кодировками
        PyDoc
        #Module Docs, стандартные руководства и документация(по модулям)(конечно возвращает docstring для всего ВЛЮЧАЯ fx/classes)
        #отчеты менее подробны чем руководства
        #может плохо работать со сценариями читающими stdin - PyDoc импортирует(выполняет) целевой модуль и в gui(например Module Docs, но не запуск с gui из shell - там доступ по идее должен быть) доступа к stdin может и не быть
        #при запросе документаци по файлу сценария верхнего уровня => окно shell где запускался PyDoc - стандартный ввод/вывод для взаимодействия с user'ом.Совокупный эффект - страница документации сценария появится после его запуска и отображения его вывода в shell(для некоторых сценариев интерактивный ввод будет чередоваться с приглашениями к вводу сервера PyDoc)
        #система кода в стандартной поставке Python, поддерживает визуализацию вывода в html или в виде текста в shell
        #генерирует отчеты "даром" при грамотном использовании строк документации
        #извлекает строки документации с ассоциированной структуроной информацией(напр. шаблоны вызова fx) и форматирует их в отчеты - назаменимая штука - избавляет от написания колоссального колличества кода|траты кучи времени
        способы запуска
            параметры shell
                #по идее
                py -<ver> -m pydoc
                    pydoc <ObjName>
                    #<ObjName> - keyword/topic/fx/module/pkg/dotted reference to obj
                    #if contains a '\' it is used as the path to a sc
                    #if 'keyword','topics','module' -> a listing of these things is displayed
                    #генерация документации в виде текста в shell
                    #~python >> help(<ObjName>)
                    -k <keyword>
                    #Search for a keyword in the synopsis lines of all available modules
                    -p <port>
                    #start an http serv on the given port on localhost;0 can be used to get an arbitrary unused port(произвольно)
                    -w <name>
                    #write out the HTML docs for a module to a file in the current dir; If <name> contains a '\' it is treated as a filename;if it names a dir >> docs is written for all the contents
                    #с именем модуля

                #<=3.2(3.1)
                    -g
                    #Pop up a graphical interface for finding and serving docs
                #3.2+(3.7)
                    -n <hostname>
                    #start an HTTP server with the given hostname(default:localhost)
                    -b
                    #start an HTTP serv on an arbitrary unused port and open it Web-Browser.Can bo used in combination with -n and/or -p
            help(obj)
            help('str')     -> help on the str class|help for str
            help()         -> интерактивная справка
            #один из интерфейсов PyDoc, извлекает строку документации из obj, интерактивная справка для obj
            #вызывает PyDoc для генерации текстового отчета, вывод(в shell) похож на вывод Unix man и разбивает текст на страницы подобно Unix more
                q-exit
                space-next page
                enter-next string
                q-exit
            #для модулей/классов отчет помито строки документации разбивается на разделы и содержит документацию о всех obj ниже уровнем, например для модуля рекурсивно возвращает документацию о всех obj в модуле
                NAME
                    <module name>
                MODULE REFERENCE
                    ...
                DESCRIPTION
                    ...
                CLASSES
                    class <name>(builtins.object)
                    data descriptors defined here:
                    __dict__...
                    __weakref
                FUNCTIONS
                    ...
                DATA
                    __warningregistry__ = {'version': 0}
                    <variables>
                FILE
                    <filePath>
            #первый уровень документации Python
            #позволяет просматривать значения параметров fx(см. fx)
            #CPython 2.7+ позволяет получать справку по имени модуля без импортирования, поиск по всей видимости осуществляется аналогично импортированию
                help('trash')     >> #ищет модуль в текущем расположении,etc
                help('re')       >> #справка по re
                #поэтому справка для str доступна по имени типа/пустой строке
                help('')        >> ...str...
                help(str)       >> ...str...
            #разумеется не работает с операторами
                help(assert) >> SyntaxErr
            #старые версии Python умели выводить справку при получении экземпляра класса
                S = 'a'
                help(S) >> проверить
            #в новых версиях справка получается при передачи специального обозначения типа или конкретного obj содержащего справку
                help(str)
                help('a') >> 'No Pyhton doc for 'a' Use help(str) '
            СРЕДСТВА ОТОБРАЖЕНИЯ В HTML
            #разновидность PyDoc основанная на HTML, генерирует отчет в HTML
            #веб-браузер функционирует как клиент поискового механизма и средство отображения
            #функциональность сервера и браузера Python обеспечивается инструментами автоматизиующих ее в модулях стандартной lib(webbrowser,http.server,...)(подробнее pydoc.py)
            #server документации не всегда убивается а потому изменения в pydoc.py/vars окружения/содержимом модулей и dir могут не подхватываться т.к. сервер по сути не перезапускается-> проверяй наличие лишних процессов Python.exe (не замечал этого со схемой 3.2+=> не пользуйся устаревшим клиентом gui)
            #может полуавтоматически открыть файл(видимо в асоциированной программе)
            #генерирует отчет для ВСЕХ модулей доступных для импорта ВЛКЛЮЧ статически|динамически компонуемые модули C
            #3.2 иногда требуется генерировать отчет для модулей C сразу т.к. может не работать полноценно по завершении поисков(кривой перевод?)
            #<=3.2 СОДЕРЖ простой клиент с GUI для отправки поисковых запросов(интерфейс поискового механизма верхнего уровня) + сервер документации, запускал веб-браузер(по запросу) для простотра документации произведенной автоматически стартовавшим локальным сервером
            #простой переносимый сценарий Python/tkinter
            #работает пиздец как медленно на win10
            #пока отчет генерируется пишет нельзя искать в клиенте
            #ручная генерация документации в клиенте работает бысрее чем переход по ссылка в браузере
            #при запросе страницы генерирует также ссылки на части(заголовки) в этой страницы(при наличии)
            #может использоваться для отображения документации сценариев(файл должен быть доступен для импорта(находиться в PYTHONPATH);сканирует стандартные пути(видимо sys.path) и пути в переменной окружения(это так?) PYTHONPATH
                IDLE => Module Docs
                cmd  => pydoc -g
                Win-S -> Module Docs
              расширение переменной среды PYTHONPATH(по умолчанию не проверяет текущее расположение - т.к. это не имеет смысла при запуске из например IDLE)
                #также требуется в интерфейсной схеме в 3.2.X
                #не требуется в 3.3+ - стандартное логичное поведение
                set PYTHONPATH=.
                py -3.2 -m pydoc -g

<cmd set>
    cmd
      #в том-же сеансе shell где будет запущен python
      set
      #вывод задание, удаление vars среды cmd
       set  #показать vars
       set <str>    # показать ВСЕ vars с именем начинающимся с <str>
       #при отсутсвии подходящих имен => ERRORLOVEL 1
       set /A "<exp>"
       #/A указывает что строка справа - числовое exp чье val вычисляется
       #ЛЮБЫЕ нечисловые строки оцениваются как переменные(% не требуется), if var не определена - подставляется 0
       #последовательное присвоение aka Python не поддерживатеся
       #выводит результат при использовании в shell
            ()
            !~-     унарные операторы
            */%+-    арифметические операторы
            >><<    двоичный сдвиг
            &^|     двоичные операторы
            = *= /= += -= &= ^= |= <<= >>=   операторы присваивания
            ,       разделитель операторов
            ПРЕФИКСЫ
            0x  HEX
            0   OCT
       set /P <var> = [promptStr]
       #позволяет установить значение var для входной строки введенной пользоваетелем
       #показывает необязательное promptStr приглашение
       set PYTHONPATH =.
       #set PYTHONPATH =.;%PYTHONPATH - забавный пример рекурсии, добавляет пустое расположение ./%PYTHONPATH% - на первый взгляд не имеет смысла ~ set PYTHONPATH=.;.
       Подстановка var может быть расширена:(?)
        %PATH:str1=str2%
        #расширяет действие var PATH заменяя КАЖД вхождение 'str1' в расширенном результате на 'str2'. 'str2' м.б. пустой str для удаления вхождений 'str1' из расширенного вывода;'str1' может начинаться с '*' => ЛЮБОЕ начало расширенного вывода до первого вхождения оставшейся части 'str1'
        #Можно так-же использовать строки расширения
            %PATH:~10,5%
            #расширит действие var PATH, затем использует только 5 char начинающиеся с 11 символа расширенного результата.if длинна не указана => используется оставшееся значение var, if длинна и число пропускаемых символов <0 => используется длинна значения var + указанное значение пропуска|длинны
                %PATH:~-10%
                #извлечет последние 10 символов PATH
                %PATH:~0,-2%
                #извлечь все символы PATH кроме двух последних
        cmd /V
        #включить поддержку связывания времени выполнения для var(отключена по умолчанию)
        #полезно при обходе ограничений раннего связывания происходящее при первом чтении строки(а не при выполнении)
            #демонстрация проблемы при раннем связывании var
            set VAR=before
            if "%VAR%" == "before" (
                set VAR = after
                if "%VAR%" == "after" @echo Тело внутреннего оператора сравнения
            )
            #сообщение не будет выводиться т.к. %VAR% в обоих exp IF подставляется в момент первого использования в первом IF в том числе в тело первого ветвления IF которое явл составным exp в IF в реале "after" == "before"
                #еще одна демонстрация
                set LIST=
                for %i in (*) do set LIST=%LIST% %i
                echo %LIST%
                #список файлов текущей папки не будет построен - значение LIST - имя последнего найденного файла,т.к. LIST подставляется только раз ~(for %i in (*) do set LIST=%i
                для связывания времени выполнения для var используется спец символ'!' - проведение сопоставления во время выполнения(при включенной поддержке связывания)
                    set VAR = before
                    if "%VAR%" == "before" (
                        set VAR=after
                        if "!VAR!" == "after" @echo Тело внутреннего оператора сравнения
                    )
                    #и
                    set LIST=
                    for %i in (*) do set LIST=!LIST! %i
                    echo %LIST%
      #включение расширенной обработки объявляет var коротые расширяются но не отображаются SET; val вычисляются динамически при КАЖДОМ извлечении, м.б. переопределены
        %СD% = текущий каталог
        %DATE% = значение возвращаемое командой date
        %TIME% = значение возвращаемое командой time
        %RANDOM% = случайное десятичное 0...32767
        %ERRORLEVEL% = текущее val ERRORLEVEL
        %CMDEXTVERSION% = версия расширенной обработки команд
        %CMDCMDLINE% = исходная командная строка(str?) вызвавшая коммандный процессор
        %HIGHESTNUMANODENUMBER% = max номер узла NUMA на локальной машине

</cmd set>
            #3.2+  СОДЕРЖ интерфейсную схему поддерживающую единый браузер,служит для поиска/отображения в html взаимодейсвующей с автоматически запущенным локальным сервером;устраняет посредника в форме клиента с gui
            #работает значительно бысрее чем клиент gui
                cmd => pydoc -b #порождает процессы локального сервера документации и веб-браузера
                    py -m pydoc -b  >> Server ready at http://localhost:50415/
                                 >> Server commands: [b]rowser, [q]uit
                содержит
                    поле для запроса документации модуля по имени
                    поле для поиска связанных записей
                    кнопку возврата на главную
                    кнопка Topics  -> общие темы Python
                        CALLS
                        CLASSES
                        DEBUGGING
                        ...
                    Keywords    -> операторы/выражения
topic - тема
            #интерфейская схема в 3.2+ и клиент GUI в <=3.2 отличаются лишь в верхних уровнях пользовательских интерфейсах, практически идентично отображают документацию и пишут логи в консоль(насчет <3.2 Не уверен)
            стартовая страница - индекс модулей(включая модули в каталоге где запущен PyDoc(текущий)) - \index.html
            #позволяет сохранить сгенерированные страницы
        ИЗМЕНЕНИЕ ЦВЕТОВ PYDOC
        #нет простого способа изменения(передача args(fx|cmd),глобальные var модуля,конфиги) => only изменение sc
        #фрагменты генерируемых html Жеско закодированы в файле pydoc.py в виде html кодов цветов
        #task №10716 касается поддерки PyDoc css для расширения возможности кастомизации(запланировано для 3.8), css файл обладает нетривиальной структурой
        #PyDoc 3.3+ поддерживает css расширяя возможности настройки, но по умолчанию .css пуст
код цвета в hex #XXXXXX - определяет 3байтовое значение

        Sphinx
        #стронний инструмент;обогащенная документация для крупных проектов
        #мощнее PyDoc
        site:sphinx-doc.org
        #применяется стандартной документацией Python и другими проектами
        #использует простой язык разметки reStructuredText
        #поддерживает мн-во выходных форматов
            HTML
            Windows HTML Help
            LaTeX
        #поддерживает всесторонние и автоматические перекрестные ссылки
        #имеет иерархическую структуру с ссылками на связанные материалы
        #поддерживает отображение с помощью Pygments
Pygments
#инструмент подсветки синтаксиса
        Стандартный набор руководств
        #полное и наиболее актуальное описание Python;входит в стандартную поставку
            IDLE->help
            python.org
            #содержит руководства ориентированные на разные целевые аудитории
        #содержат tutorial менее подробный чем лутц
        #What's new содержит историю изменений по всем версиям 2.0+

</документация>
Python 2.0 появился в конце 2000г
#научный формат
    '%e' % (1/3.0) >> '3.333333e-01'



усекающее деление != деление с округлением в меньшую сторону == целочисленное 2.2+, позволяет легче предугадать результат
abs(<num>)
#возвращает модуль числа ~ абсолютное значение, по идее <num> должен иметь __abs__
sum(<iterableOfNumbers>[,start=0])
#возвращет сумму элтов <iterableObj> + start
min(<iterable>[,key=func])|min(a,b,c,...[,key=func])
#возвращает min элт <iterable>| min args
    min(open(path))     >> <строкаСminЗначением(строковым)>
max()
#~min
round(<num>[, ndigits=0])
#отбрасывает остаток округляя до ближайшего целого,ngigits = точность(может быть отрицательна), аргумент должен иметь метод __round__
    round(2.55,1)
    round(3.33,-2) >> 0.0
    round(3,-2) >> 0
math
#модуль,содержит большинство математических инструментов C
    .pi
    #константа float
    .e
    #константа float

    .sin()
    #синус

    .floor(<num>)
    #окрукление с понижением, результат меньше аргумента, аргумент по идее должен имет метод __floor__ действительное число
        math.floor(2.5) >> 2
        math.floor(-2.5) >> 3
    .trunc(<num>)
    #отбрасывание остатка, усечение в сторону нуля, аргумент по идее должен иметь метод __trunc__() - действительное число
    #~int() по действию(но принимает только числа)
        math.trunc(2.5) >> 2
        math.trunc(-2.5) >> -2
pow(x,y[,z])
#x**y % z, args - real, позволяет получить корень
x**y
#позволяет получить корень
#по идее перегруженный pow
интересно x**y % z будет работать медленнее pow? => уже проверил в timeit(по идее это очевидно ведь операторы перегружаются методами)
int
    .__abs__
    #по идее для abs
    .__add__
    #сумма?
    ...
    .__ceil__
    #?
    .__class__
    #
все встроенные obj находятся в стандартном библиотечном модуле builtins(3.x)|__builtin__(2.X) со стандартным именам __builtins__ предварительно установленном в большинстве глобальных NS в обоих ветках
#ручное импортирование может быть полезно для решения более сложных задач вроде настройки
    import builtins
    builtins.list() >> []
    #пример: настройка open(замена для КАЖДОГО модуля внутри процесса)
    #добавляет к встроенный fx вывод трассировки (возможно вложенного) вызова, методика может иметь и другие применения
        #меняет подсказку в idle на *pargs, **kargs
        import builtins
        def makeopen(id):
            original = builtins.open
            def custom(*pargs, **kargs):
                print('Custom open call %r:' % id , pargs, kargs)
                return original(*pargs, **kargs)
            builtins.open = custom
        path = r'c:\users\mk\desktop\test.txt'
        with open(path,'w') as fout:
            for char in 'abc':
                print(char,file=fout)		
        makeopen('isID')
        F = open(path)
        >> Custom open call 'isID': ('c:\\users\\mk\\desktop\\test.txt',) {}
        F
        >> <_io.TextIOWrapper name='c:\\users\\mk\\desktop\\test.txt' mode='r' encoding='cp1251'>
        #т.к. КАЖДЫЙ настроенный эземпляр запоминает open(теперь измененный) находя его в global => они могут вкладываться друг в друга
            #по сути запуск двух настроенных копий что недоступно в случае использования глобальных var вместо сохранения предыдущей копии в Enclosure
            makeopen('otherID')
            F = open(path)
            >> Custom open call 'otherID': ('c:\\users\\mk\\desktop\\test.txt',) {}
            >> Custom open call 'isID': ('c:\\users\\mk\\desktop\\test.txt',) {}
        #сохраняет подсказку open в idle
        import builtins
        def makeopen(id):
            original = builtins.open
            def custom(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None):
                print('Custom open call %r:' % id , file)
                return original(file=file,mode=mode,buffering=buffering, encoding=encoding,errors=errors,newline=newline,closefd=closefd,opener=opener)
            builtins.open = custom
        path = r'c:\users\mk\desktop\test.txt'
        makeopen('isID')
        #реализация с классами
        import builtins
        class makeopen:
            def __init__(self, id):
                self.id = id
                self.original = builtins.open
                builtins.open = self
            def __call__(self, *pargs, **kargs):
                print('Custom open call %r:' % self.id, pargs, kargs)
                return self.original(*pargs, **kargs)	
        makeopen('Class') >> <__main__.makeopen object at 0x03484530>
        path = r'c:\users\mk\desktop\test.txt'
        open(path)  >> Custom open call 'Class': ('c:\\users\\mk\\desktop\\test.txt',) {}
                    <_io.TextIOWrapper name='c:\\users\\mk\\desktop\\test.txt' mode='r' encoding='cp1251'>
        #но можно обойтись и без прямого импорта builtins => видимо практика устарела
            #использование __builtins__
            def Makeopen(id):
                original = open
                def custom(*args,**kwargs):
                    print('Custom open call %r:' % id)
                    return original(*args, **kwargs)
                __builtins__.open = custom
            Makeopen('hi')
            path = r'c:\users\mk\desktop\test.txt'
            open(path)      >> Custom open call 'hi':<_io.TextIOWrapper name='c:\\users\\mk\\desktop\\test.txt' mode='r' encoding='cp1251'>
            #создание open в global
            #но сохранение оригинала в Nonlocal => поведение идентично
            #экземпляры так-же могут вкладываться друг в друга
            def Makeopen(id):
                global open
                original = open
                def custom(*args, **kwargs):
                    print('Custom open call %r:' % id)
                    return original(*args, **kwargs)
                open = custom
        
кажется удаление стандартных модулей ничего не дает
    #но вот obj внутри них;кажется при импорте одни переменные заменяются другими и при их удалении доступ к ним утрачивается
        print(1)    >> 1
        import sys;del sys.stdout
        print()     >> RuntimeErr: lost sys.stdout
одиночные скобки ни на что не мешают
    ('a') + ('b') >> 'ab'
    ('a').capitalize() >> 'A'

напоминание:3.X неявные преобразования есть только для числовых типов
    'a' > 3 >> TypeErr
сложность типов
    bool -> int -> Fraction -> float -> complex
    кажется Decimal не взаимодействует с дробными|complex типами неявно
len(<container>)
#возврщает int, для ЛЮБОГО obj имеющего .__len__()
#какие obj кроме классов поддерживают наследование?
задача: все возможные перестановки
#можно получить используя рекурсию в форме построителя списка и генератора
    def permute1(seq):
        if not seq:
            return [seq]    #все комбинации в пустом списке
        else:
            
задача: вывести только принятые аргументы
    def f(a,b,c=0,*args,**kwargs):
        ...
    f(1,2)          >> 1,2
    f(1,2,0)         >> 1,2,0
    ...
задача: поcтроить квадратную матрицу
#~ задача:создать список int разбитых на группы
    matrix_size = 3
    matrix_data = range(1,matrix_size**2+1)
    M = [tuple(matrix_data[i:i+matrix_size]) for i in range(0,len(matrix_data),matrix_size)]
    for row in M: print(row)
    >>  (1,2,3)
       (4,5,6)
       (7,8,9)
    #распаковка + изменяемые строки + литералы
    [[*range(1,10)[i:i+3]] for i in range(0,9,3)]
задача: получить диагонали квадратной матрицы
    #генерация матрицы(задача: построить квадратную матрицу)
    #основная диагональ
        [M[i][i] for i in range(len(M))]    >> [1, 5, 9]
    #неглавная(?забыл термин) диагональ
    #эл-ты должны иметь следующие индексы
        [0][2]   [0][3-1]   
        [1][1] => [0][3-2]
        [2][0]   [0][3-3]
        #range выдает числа начиная с нуля значит нужно дополнительно отнимать по 1
        # 1-i вместо i - 1 для легкого улучшения читаемости
        [M[i][len(M) - 1 - i] for i in range(len(M))]   >> [3,5,7]
задача: перемножение матриц
    #включения
    #цикл
        multiply3.py
задача: изменение эл-тов матрицы
    M = [[*range(1,10)[i:i+3]] for i in range(0,9,3)]   #[[1,2,3],[4,5,6],[7,8,9]]
    #цикл
        for i in range(len(M)):
            for j in range(len(M)):
                M[i][j] *= -1
    #цикл с копией
        res = []
        for row in M:
            tmp = []
            for elt in row:
                tmp.append(-elt)
            res.append(tmp)
    #включения
        #итерация по строкам - внешний цикл
        #итерация по эл-там - exp - создает эл-ты списка
        М = [[-elt for elt in row] for row in M]
        #производство результатов в простом векторе
        M = [-elt for row in M for elt in row]
задача: переопределить obj(вроде fx без переписывания) без его полного переписывания
#звучит как начало bad practice
#например: я опдеделяю fx(из примера использования builtins для настройки open)
        def Makeopen(id):
            original = open
            def custom(*args,**kwargs):
                print('Custom open call %r:' % id)
                return original(*args, **kwargs)
            __builtins__.open = custom
        #затем я ее использую по назначению
        path = r'c:\users\mk\desktop\test.txt'
        Makeopen('hi')
        open(path)      >> Custom open call 'hi':<_io.TextIOWrapper name='c:\\users\\mk\\desktop\\test.txt' mode='r' encoding='cp1251'>
        #а затем хочу использовать тоже имя(например чтобы не переписывать код в другом месте) для слегка измененной версии
        def Makeopen(id):
            global open
            original = open
            def custom(*args,**kwargs):
                print('Custom open call %r:' % id)
                return original(*args, **kwargs)
            open = custom
        #дальнейшее использование
        Makeopen('global')
        open(path)          >> Custom open call 'global':
                           Custom open call 'hi':
                           <_io.TextIOWrapper name='c:\\users\\mk\\desktop\\test.txt' mode='r' encoding='cp1251'>
        #как избежать полного переписывания fx?
            декораторы
            #могут помощь в не настолько ебанутых случаях
            сохранять все данные в атрибутах fx
            #думаю это мягко говоря нехорошо
                def Makeopen(id):
                    Makeopen.original = open
                    def custom...                        
                    Makeopen.custom = custom
                def newCustom...
                Makeopen.custom = newCustom
                ...
            
Задача: вернуть только переданные параметры, при этом вывод в подсказке - аналогичен исходному obj
    #сделать это замыканиями/классами - проблематично => fx/метод которая будет принимать args,kwargs смотрит наружу и светит своими параметрами PyDoc
    def maker():
        def inner(*args):
            return sum(args)
    a = maker()
    a(      >> должно вывести a(x,y)
задача: пересечение последовательностей с повторами
    #тупой код, по идее возвращает разные результаты в зависимости от порядка аргументов
        A = 'aabcddabcdafklhjsfdkashf'
        B = 'asdfbk'
        def intersect(seq1,seq2):
            res = []
            for x in seq1:
                if x in seq2:
                    res.append(x)
            return res
        print(intersect(A,B),intersect(B,A),sep='\n')
        >> ['a', 'a', 'b', 'd', 'd', 'a', 'b', 'd', 'a', 'f', 'k', 's', 'f', 'd', 'k', 'a', 's', 'f']
        >> ['a', 's', 'd', 'f', 'b', 'k']
    #включение c постоянным результатом
        def intersect(seq1,seq2):
            if seq1 > seq2: seq1,seq2 = seq2,seq1   #больше результатов;seq1 <seq2 - меньше результатов
            return [x for x in seq1 if x in seq2]
    #set ломает порядок, сжирает дубли, но дает стабильный результат
        set(A) & set(B)
    #порядок в любом случае зависит от порядка передачи args
        A = 'ab'
        B = 'ba'    >> вернем либо 'ab' либо 'ba'
    #включение с полным упорядоченным результатом
        def intersect(seq1,seq2):
            A = [elt for elt in seq1 if elt in seq2]
            B = [elt for elt in seq2 if elt in seq1]
            print('Элементы из seq2 в seq1',A)
            print('Элементы из seq1 в seq2',B)
задача: вывести все позиции элемента в коллекции
    L = list('abcdabaa')
    j = 0
    for i in range(L.count('a')):
        print(L.index('a',j))
        j = L.index('a',j) + 1
    #включение с перебором всех
    [i for i, char in enumerate(L) if char == 'a']
    #перебор всех
    for pos,elt in enumerate(L):
        if elt == 'a':print(pos)
задача: развернуть односвязный список
#даже хз как его записать
задача: когда использовать комментарии,а когда docstring
    комментарии в тех случаях когдя я не считаю нужным видеть их в PyDoc
    комментарии для мелких блоков/операторов
    docstring для более крупных структур fx/модули
задача: как просмотреть строки документации
    help()
    .__doc__
    PyDoc -> HTML
    вручную
задача: получить список всех модулей доступных для import'а
    PyDoc
задача: сумма кодовых точек символов в строке
    sum(map(ord,s))
    sum([ord(char) for char in s])
задача: заменить элементы в списке на Fizz если кратно 3, Buzz если кратно 5 и FizzBuzz если кратно и 3 и 5
    for i in range(1,101): print(((not i%3)*'Fizz' + (not i%5)*Buzz) or i)
    #or
    [(not x%3)*'Fizz' + (not x%5)*'Buzz' + (not x%15)*'FizzBuzz' or x for x in range(1,101)]
    #or: значения в dict сохраняются в порядке записи(3.6/3.7+)
    def fizzbuzz(num):
        return {
            0: num,
            num % 3: 'Fizz',
            num % 5: 'Buzz',
            num % 15: 'FizzBuzz'}[0]
    #or
    for num in range(1,101):
        #*2 чтобы индекс был 2
        (num,'Fizz','Buzz','FizzBuzz')[(not num%3)+(not num%5)*2]
    #or
    fizzbuzz = [None,'Fizz','Buzz','FizzBuzz']
    for num in range(1,101):
        print(fizzbuzz[(num%3==0)+(num%5==0)*2] or num)
    #or
    L = list(range(1,101))
    for i in range(len(L)):
        if L[i] % 15==0: L[i] = 'FizzBuzz'
        elif L[i] % 3==0: L[i] = 'Fizz'
        elif L[i] % 5==0: L[i] = 'Buzz'
    #or
    ['FizzBuzz' if not(i%15) else 'Fizz' if not i%3 else 'Buzz' if not i%5 else i for i in range(1,101)]
    #or
    ['FizzBuzz' if i%15<1 else 'Fizz' if i%3<1 else 'Buzz' if i%5<1 else i for i in range(1,101)]
задача: реализовать множественное ветвление
    см множественное ветвление/switch
    if
задача: реализовать сложение числа и списка, if число прибавляется слева - в начало, иначе в конец
    #довольно ломанное решение на мой вгляд т.к. результат list, а не List() => сложности при использовании в сложных выражениях
    class List(list):
        def __add__(self, other):
            #для списков обычно поведение, для всего остального добавление в конец
            if isinstance(other,list):
                return super(List, self).__add__(other)
            else:
                return self + [other]
        def __radd__(self, other):
            if isinstance(other, list):
                return(other, list):
                    return other.__add__(self)
    99 + List([1,2,3]) >> [99,1,2,3]
    List([1,2,3]) + 99  >> [1,2,3,99]
задача: добавить элт в конец списка
    l =+ [other]
задача: реализовать оператор if в виде exp
    тернарная форма if
    bool exp(см задача: установить var значение в зависимости от значение другой var)
задача: получить послений элт списка
    b[-1:]
    b[-1] if b else None
задача: отфильтровать все True obj
    #filter
        list(filter(bool,l))
    #включения(эмуляция filter)
        [x for x in l if x]
задача: '''в чем отличие
            def a(**args):
            def a(*args):'''
      первая fx принимает именованные args
задача:Назвать итерационные контексты Python
    # любой obj использующий протокол итерации
    #присваивание {xn};распаковка;включения(и генератора?);циклы;любой obj требующий результат(print, конструкторы,map,in,.join,sorted,sum,any,all,...)
задача: сравнить вывод разных выражений/fx/etc на одном наборе даннных так чтобы результат был одиночный True/False
    см. задача: установить var...-> проверка
задача: установить var значение в зависимости от значение другой var
    #if/else
        x = True
        if x: a = y
        else: a = z
    #bool операции выражений
        #частичная замена тернарного if/else <2.5 (y if x else z)
        #полностью чинится подменой y при проверке, но конечно это наркомания
        #использовалась бывшими программистами-C
            (x and y) or z  #дает обратный результат для x,y,z = 1,0,1 => работает нормально if y != False(остальное не важно, т.к. x - Условие и оно по умолчанию должно быть True/False иначе это не имеет смысла)
            #можно починить используя булеву алгебру
                #некорректная форма без упрощений(возвращает True,z вместо y,y)
                    (not x and not y and z) or (not x and y and z) or (x and y and not z) or (x and y and z)
                #не корректная форма форма с упрощением(частично возвращает bool вместо исходного obj)
                    (x and y) or (not x and z)
                #упрощенная не корректная форма  CNF
                    (not x or y) and(x or z)    #возвращает 'x' вместо y
                    #проверка
                        b = [(x,y,z) for x in [[],'x'] for y in [(),'y'] for z in ['','z']] #разные формы False/True для полного сравнения поведения
                        res = True
                        for x,y,z in b:
                            res &= ((not x or y) and (x or z)) == (y if x else z)
                        res             >> False
                  #одна форма работает а другая нет т.к.
                    not 't' or [] >> #возвращает второй аргумент
                    not 't' and 't' >>#возвращает первый арг
        #index
            #bool нужен для преобразование в [0|1]
            #не полный эквивалент,т.к. Python не производит укороченную оценку, оценивает все 3 obj
            a = [z,y][bool(x)]
        #частный случай для
                if x: a = x
                else: a = z
            a = x or None
    #тернарный if
        a = Y if X else Z
задача: выбор первого непустого obj
    #распростроненная парадигма python
    x = a or b or default
задача: разрезать торт 3 разрезами на 8 равных частей
    если 2D >> 2 разреза;ставим в ряд; третий разрез
    если 3D >> 2 разреза никуда не делись;
        если верх/низ одинаковы >> порезать вдоль без перестановок
        или поставить их в ряд >> нужно много места
        или поставить их друг на друга >> что-то мне слегда противно
    резать медленно подставляя куски прямо под нож -> по идее можно управиться и в пару разрезов
    если число измерений ножа равно числу измерений торта, то по идее можно порезать его за один проход, например 3д торт и 3д нож из 8 лезвий
    одномерный торт(шкалу) можно порезать одномерным ножем(набор точек)
    порезать 3д торт 2д ножем реально, нужно давить единственной гранью на разрез
    порезать 2д торт 1d ножом - "режущая грань" не имеет площади => число разрезов будет стремится к \inf
    если число измерений ножа больше чем у торта - проблем не будет (пример: 1д торт и 2д нож), 2д торт и 3д нож
    ВЗЯТЬ РАЗРЕЗАННЫЙ ТОРТ -> 0 РАЗРЕЗОВ
задача: ведра 3 и 5 литров => набрать 4
    I:5/5,0/3=>2/5,3/3=>2/5,0/3=>0/5,2/3=>5/5,2/3=>4/5,3/3
    II:3/3,0/5=>0/3,3/5=>3/3,3/5=>1/3,5/5=>1/3,0/5=>0/3,1/5=>3/3,1/5=>0/3,4/5
    III:зачем эти 4 литра? если нужно их набрать и залить в какую-то другую 4х литровую емкость, не проще ли набрать все 5 литров и не париться?
задача: вывести список двоичных чисел
    #хреновое решение(доп код на каждый разряд), но может быть удобно для тестов т.к. результат сразу список
    [(x,y,z) for x in range(2) for y in range(2) for z in range(2)]
    #всяко лучше
        for i in range(x):bin(i)[2:]
задача: назвать 3 способа назначить 3м var одно значение?
    a = b = c = [1]            #один obj
    a,b,c = [[1] for i in range(3)] #Разные obj
задача: удалить дубли из последовательности с сохранением порядка?
        x = list('aabcdeezzx')
    #itertools.groupby()
    #работает только на предварительно отсортированом obj(можно заменить x на sorted(x)) но это еще большее расхождение с условием задачи
        list(itertools.groupby(x)) >> [('a', <itertools._grooper obj ad <adress>),('b',...]
        [el for el, _ in itertools.groupby(x)]
    #collections.OrderedDict.fromkeys
        list(collections.OrderedDict.fromkeys(x))
    #3.7+|PyPy 3.6+|CPython 3.6+|2.7+
    #dict(вроде быстрее всего)
        dict.fromkeys(x) >> {'a':None,'b':None,...'x':None}
        list(dict.fromkeys(x))
    #извращанный dict(по идее жрет больше mem) удаляет первые элты
        list(dict(zip(x,x))
    #еще более извращенный dict
        list(dict(zip(x,[None]*len(x))))
    #еще короче
        [*dict(zip(x,x))]
    #collections.Counter() не пашет в 3.5.3
        list(collections.Counter(x).keys())
    #pandas
    #numpy
задача: изменить кортеж (1,2,3)
    t = (1,2,3)
    (4,) + t[1:]
    #преобразование в список избыточно if известно что коллекцию не нужно будет менять
задача: пересечение obj в цикле
    думаю похоже на задачу создания obj
    или выполнить строку
        t = 'dict','set','list'
        code = 'res =' + ('& set(dir({}))'*len(t))[2:]
        exec(code)
        print(res)
tuple.__hash__ >> <slot wrapper '__hash__' of 'tuple' objects>
    wrapper?
unhashable obj имеют .__hash__ равный None
{1}.__hash__ >> None
наивный способ создания hashable mutable
    #возвращается по идее хеш не этого obj
    #по идее можно наследовать сразу от list и какого-нибудь <hashableObj> переопределив list.__hash__ на <hashableObj>.__hash__
    class hlist(list):
        def __hash__(self):
            return hash(tuple(self))
    hash(list()) >> typeErr
    hash(hlist()) >> <hash> #на первый взгляд работает весьма стабильно
    type(list(hlist())) >> <class 'list'> #может быть успешно преобразован в list
запуск скрипта из notepad++ через py сохраняет интерактиный сеанс открытым после завершения -> можно выполнять код(например пройтись по var's)
МЕТОДЫ ОБЩИЕ ДЛЯ ОСНОВНЫХ ТИПОВ
    set(dir(dict)) & set(dir(set)) & set(dir(list)) & set(dir(tuple)) & set(dir(int)) & set(dir(float)) & set(dir(complex)) & set(dir(Decimal(10))) & set(dir(Fraction(3,7)))
    >>{'__hash__', '__subclasshook__', '__str__', '__format__', '__new__', '__getattribute__', '__init__', '__delattr__', '__dir__', '__setattr__', '__doc__', '__eq__', '__ge__', '__gt__', '__class__', '__reduce__', '__repr__', '__ne__', '__le__', '__reduce_ex__', '__lt__', '__sizeof__'}
    походу __lt__,__eq__,__ge__,__ne__,__gt__,__le__ - методы сравнений
WIN+V журнал буфера обмена win10
can we have your liver then? перевод
РАСПАКОВКА
#~распаковывающее присвоение (кортежей)
#поддерживается любые коллекции
    [a,b] = [b,a]
#для неупорядоченных коллекций порядок присвоения = порядку вывода
#операция обратная zip
    a,_ = 1,2 #довольно удобно
    a = 1.1
    b = 1.1
    a is b >> False
    a,b = 1.1,1.1
    a is b >> True
некоторыe(все?) операции set используются в контексте объектов представлений словарей 3.X
isinstance(<obj>,class|<obj>,(class0,class1...))
#возвращает True if <obj> - инстанс класса (в чем отличие от type())
#или всех классов в кортеже(~isnstance(<obj>,<class0>) & isinstance(<obj>,<class1>) & ...)
# Examples
    # Сравнение со строкой 2.2(types ⊃ StringTypes для этой цели)
    from types import StringTypes
    if isinstance(obj, StringTypes):
        ...
    # Сравнение со строкой 2.3(str & unicode ⊃ общий базовый класс) 
    if isinstance(obj, basestring):
        ...
    
на мой взгляд это неплохо читается
    for _ in range(<int>):
        ...
запуск скрипта от админа без появления окна и предупреждения uac(мои бредни)
    при установке по выполнить .ps скрипт запуска доверенных скриптов(пользователю нужно будет выбрать Yes в ps(возможно это можно обойти?))
    запускать pythonw.exe из которого можно выполнить что-нибудь под админом


РАЗДЕЛЯЕМЫЕ ССЫЛКИ В КОЛЛЕКЦИЯХ
    требуется забота о разделяемых ссылках т.к. модификация одного имени может повлиять на другие имена иначе obj могут измеяться неявно
        L1 = [2,3,4]
        L2 = L1
        L1[0] = 0 #меняем компонент obj на который ссылаются оба имени
        L2[0] >> 0
        l = [0]
        m = [1,l]
        m[1] is l >> True
slice
[:[:]]
    #возвращает новый obj того-же типа, по идее просто выражение(a:b:c) перегруженное slice() и отправленное в [] перегруженное index
    #обобщенная форма индексации, индексация с помощью obj среза(важно при разботке классов с поддержкой index и slice одновременно)
        'abc'[slice(1,2)] >> 'ab' #индексация посредством slice obj
    #позволяет изменять фрагменты изменяемых {xn}, присвоение по срезу ~ удаление + вставка;размеры срезов могут различаться
        l = list(range(7))
        l[1:4] = ['I','II']
        del l[3:5]
        l >> [0,'I','II',6]
        open(path,'w').write('a\nb\nc')
        l[1:4] = open(path);l   >> [0,'a\n','b\n','c',6]
    #присвоение по срезу извлекает эл-ты из iterable(ожидает iterable) а затем присваивает их цели => присвоение допустимо только для iterable, конечно можно использовать разные типы(<list>[x:y] = <set>) но я не вижу в этом особого смысла(единооразие нравится мне гораздо больше(не считая нарушения порядка в упорядоченных коллекциях)
        l = list(range(5))
        l[2:4] = 1 >> TypeErr
        l[2:4] = 'z' >> [0,1,'z',4]
        #возможно,присвоение по срезу с пересечением нового и старого сегментов(сдвиг копии сегмента)
        l = list(range(10))
        l[2:5]=l[3:6] >> [0,1,3,4,5,5,6,7,8,9]
    #расширение {xn} и удаление эл-тов - нетипичный сценарий использования, и на мой взгляд читаемость падает
        l[1:1] = ['a'] #вставка - "заменяемый" срез пуст
        #удаление среза
        l[1:5] = []     #~del
        l[:0] = ['first'] #~insert()
        #if start > end => end автоматически масштабируется(end = start) [5:3] => [5:5] ("расходящиеся интервалы" результат пустое мн-во), но позиция вполне конкретная
            l = [0,1,2]
            l[1:0] = 'z' >> [0,'z',1,2] #курсор стоит на 1ом эл-те не включая его [1:1] - пустая точка вставки со смещением 1
        l[len(l):] = ['last'] #~extend()
        #в отличие от index может присваивать полюбому индексу без генерации outOfRange(автоматическое масштабирование срезов(в длинну{xn}|начало))
        l[99:] = ['last']
        l[:-99] = ['first']
    #шаг = страйд(stride)
    #при обратном порядке смысл <start> <stop> как-бы инвертируется(на самом деле if start < 0/end > len({xn}) => добавляем len({xn})*(start % len({xn})+1)(моя реализация - в исходники не смотрел)
    #принимат None(игнорирует)
        'abc'[None:] >> 'abc'
    #можно использовать в итераторах
    stride - большой шаг, брюки, шагать
    #позволяет индексировать пустые obj
        ''[-1]  >> IndexErr
        ''[-1:] >> ''
дерево можно реализовать как тупо вложенная структура данных
slice(stop=len(obj)|start=0,stop[,step=1])
#step 2.3+
#возвращает slice obj,~[:], None - Значение по умолчанию(игнорирует указание None)(позволяя указывать последующие позиционные args без указания предыдущих)
    'abc'[None:None] >> 'abc'
index(sub,[start[,end]])
#находится в классах поддерживающих индексирование
#строки поддерживают неограниченную вложенную индексацию т.к. строка это набор односимвольных строк, которая набор из односимвольной строки, которая ...
index
#по идее выражение перегруженное __getitem__
#интерпритатор извлекает ссылки на вложенный obj на каждом шаге
#к отрицательным значениям автоматически один раз добавляется длинна строки
#ассиметричен первый эл-т [0],первый с конца [-1], а не [-0] что очевидно
copy
#модуль для копирования obj
    .copy(x)
    #x - <obj>
    #обычно достаточно
    #shallow(поверхносная?неглубокая?) copy on arbitrary Python obj,~ .copy() в obj
        a = 1.1
        l = [a]
        l[:][0] is l[0] >> True
    copy.deepcopy(x,memo=None,_nil=[])
    #обычно не требуется
    #deep copy on arbitrary Python obj
    #создает глубокую для всех mutable obj копию(видимо рекурсивно переходя по ссылкам внутри каждого obj), умеет обрабатывать цикличные obj(одиночные или группы)
        a = 1.1
        l = [a]
        copy.deepcopy(l)[0] is l[0] >> False
КОПИИ ЦИКЛИЧНЫХ OBJ
    l         >> [1,2,[...]]
    l.copy()    >> [1,2,[1,2,[...]]] #в конце l.copy() все еще лежит указатель на l
    l.copy().copy >> [1,2,[1,2,[...]]] # не отличается
    l.copy() == l >> True #содержит указатели на одинаковые obj хотя выглядит по разному(просто показан еще один уровень вложенности), ведут себя одинаково
    copy.deepcopy(l) >> [1,2,[...]] # полное копирование цикличные obj обнаруживаются и указатель меняется на новый obj
        #по идее это простая задача, нужно просто добавлять встретившиеся указатели в словарь {<старыйУказатель>:<новыйУказатель>,<...>} и каждый раз при создании нового obj сверяться не создавали ли мы его уже(дубль(dict|set))(надеюсь используется структура быстрее dict)
    l0,l1 >> ([1,[2,[...]]],[2,[1,[...]]])
    l0.copy()[1] is l0[1] >> True
    copy.deepcopy(l0)[1] is l0[1] >> False
сходство буквы l и цифры 1 в начале имен var не проблема т.к. имя явно начинается не с цифры

list
#списковый тип поддерживающий позиционно упорядоченные коллекции произвольных Obj
    .copy()
    #3.3+(для list)
shallow - поверхностный? неглубокий? мель же!
arbitrary - eng - незанятый,выделенный?
_nil - ?
кажется большинство методов возвращают неглубокую копию obj(выяснить подробнее)
одиночный obj = не коллеция
анализ структуры ссылок может помочь в анализе ошибок
    например нежелательное изменение obj
        например при передаче в fx
все в Python взаимодействует через ссылки и их присваивание(args fx,модули,etc), копирование obj обычно нужно указывать явно(явное лучше неявного)
в Pyhton сущ только одна модель присваивания
модель присваивания кажется = модель типизации
присваивание - одна из основных концепций python
разобрать статическую типизацию для сравнения с моделью Python
set мн-во неизменяемых obj, frozenset неизменяемое мн-во
__new__ создает obj используя родительский конструктор(родительского класса?)
РОМБИЧЕСКОЕ НАСЛЕДОВАНИЕ
    класс наследуем от нескольких классов которые имеют общего предка, при переопределении метода в нескольких промежуточных классах, для определения какой вариант наследовать конечному классу используется С3 ЛИНЕАРИЗАЦИЯ
с3 линеаризация?
Метакласс - класс экземпляры которого - классы
@staticmethod - объявляет статический метод
возможно стоит убрать из docx конспекта вещи вроде маркеров списка и сделать его ближе к черновику-> маркеры разделяют строки, как здесь номера строк => тупо
str
#фундаментальный строковый тип
C не поддерживает индексацию отрицательными значениями
ИТЕРАЦИОННЫЕ ИНСТРУМЕНТЫ
#~итерационные средства, автоматизируют большую часть работы по проходу по коллекциям выполняемой вручную в языках более низкого уровня
#работают на любом iterable, просматривают obj слева направо
#все что производит итерирование - map,in,for,...
    ЦИКЛЫ
        ЦИКЛЫ С ПОДСЧЕТОМ
        #самая большая категория циклов
          функции вроде range,zip,enumerate,map,etc позволяют применять for где только возможно
          for
          #универсальный итератор, может проходить по пользовательским obj
          #обычно быстрее и проще(читабельнее) while => предпочтительнее
          #не пашет в одну строку с if
          for name in dir(sys):if name[:2] == name[-2:] == '__':print(name)
          #exp в заголовке ведь выполняется единожды не так ли?
                for i in <iterable>:
                    <code>
                else:
                    <еслиНеВстретилсяBreak(полный обход <iterable>)>
                    #i - курсор проходящий по <iterable>, переназначает одноименную var в текущей области видимости
                    #i цель/кортеж целей, присваивание распаковкой тоже пашет = автоматическая распаковка
                        for t in d.items():k,v = t  #ручная распаковка в теле цикла
                    #кортеж целей не особый случай
                        #3.x
                        for (a,*b,c) in [(1,2,3,4),...]:...
                        #2.x эмуляция поведения расширенной распаковки
                        for elt in [(1,2,3,4),...]:
                            a,b,c = elt[0],elt[1:-1],elt[-1]
                    #<iterable> - элементы цикла
                    #пустой <iterable> ~ невыполненному условию while
                        for i in []:print('for')
                        else:print('else')          >> 'else'
                ОТЛИЧИЯ ITERABLE ITERATOR
                итератор
                #по идее то что проходит по iterableObj, использующий протокол итерации
                #истощается, obj с одиночной итерацией(поддерживат одну активную итерацию)
                    #итерация по потоку результатов
                    I0 = iter('abc')
                    I1 = iter(I0)
                    next(I0)    >> 'a'
                    next(I1)    >> 'b'
                    I2 = iter(I0)
                    next(I2)    >> 'c'
                #итератор obj имеющего итератор - сам obj; obj с итератором = итератор(в том числе концептуально т.к. из него и берутся значения)
                    f = open(path)
                    f is iter(f)    >> True
                #паттерн для
                  #доступа к содержимому obj без раскрытия их структуры(инкапсуляция)
                  #предоставления единообразного интерфейса для обхода различных агрегированных структур
                  побочный эффект - коллекции упрощаются т.к. делегируют перебор эл-тов другой сущности
                    #итератор - obj приншимаемый next() или obj возвращающий self на вызов iter() в отличие от iterable obj, наличие .__next__ еще не делать obj итератором(см os.popen)
                        Z = zip((1,2,3),'abc')
                        I = iter(Z)
                        next(I) >> (1,'a')
                        next(Z) >> (2,'b')
                    #iterable не запоминает свое положение, содержит итератор(производят на вызов iter()) => итераторы разных obj имеют разную реализацию, но общий интерфейс
                    #итератор поддерживает только одну итерацию=> нельзя иметь мн-во итераторов на их результатах;истощается/расходуется => не имеет смысла создавать  отдельную var для собственных итераторов, кроме как ради читаемости
                        #что будет если попытаься пройти по итератору параллельно?
                            #думаю примерно это
                            I = iter([1,2,3])
                            [(i,j) for i in I for j in I]   >> [(0,1),(0,2),(0,3)]
                    #итератор - то что проходит по iterable, или ЛЮБОЙ obj поддерживающий протокол итерации например iterableObj
                    #лутц использует:iterableObj - поддерживает вызов iter
                        #iterator - то что возвращает iter(iterable)/то что поддерживает вызов next(iterator);или инструмент выполняющий итерацию
                        #итератор думаю вообще не связян с коллекциями
                    #итераторы написаны на C и работают с соответствующей скоростью в отличие например от while
                 #в ряде случаев iterator и iterable - один obj когда поддерживается одиночный просмотр(например fileobj)
                 #очевидно что там где требуется iterable подходит и iterator, но там где требуется iterator не подойдет iterable
                 #iterator часто временный obj использующийся итерационным инструментом/контекстом
                 #по идее может хранить содержимое local NS(как и генератор) но не нуждается в этом, ему нужно просто помнить на какой позиции в iterable он остановился
                 #некоторые obj одновременно инструмент контекста итерации и iterable - т.е. производят итерирование, и их резултаты итерируемы(map(3.x разве only?)/zip(3.x разве only?)/gen exp/...)
                 iterableObj поддерживают множество открытых итераций, находясь в разных позициях, т.к. итерирование происходит не по ним а по созданным из них итераторам
                 ВИДЫ ИТЕРАТОРОВ
                    ВНЕШНИЙ
                        классический pull-based, обход контролирует клиент(что это?) вызовом __next__
                        внутренний push-based получает callback fx, и уведомляет клиента о получении следующего эл-та

                    ВНУТРЕННИЙ
if итератор - obj СОДЕРЖАЩИЙ __next__ => итератор ПРИНАДЛЕЖИТ obj => цикл for - obj СОДЕРЖАЩИЙ __next__? => нихера, итератор это так-же инструмент
                #если цикл не выполнился ни разу(итерация по пустому obj) - var не инициализируется
                    for i in []:pass
                    i   >>  NameErr: i not defined
                #присваивание {xn} в for работает аналогично остальным контекстам
                    for ((a,b),c) in [([1,2],3),['xy',6]]: print(a,b,c) >> 1 2 3 >> x y 6
                #разумеется присвоение как обычно копирует ссылку, а не obj
                    a,b,c = [1],[2],[3]
                    for i in a,b,c:i.append('z')
                    a,b,c   >> [1,'z'],[2,'z'],[3,'z']
          включения
            dict
                #Пример
                {<exp for k>:<exp for v> for (k,v) in zip(keys,vals)}
            включение генератора
            #2.4+
            #генераторное выражение - iterableObj
            #возвращает генератор, т.к. тот возвращает генератор на iter и по нему можно проходить в итерационных контекстах его можно считать iterable
            #обладает преимуществами в плане написания кода
                #объединяет преимущества map и включений
                #~map в отличие от спискового включения в 3.X
                map(lambda x: x**2, (-1, -2, 3, 4))
                (x**2 for x in (-1, -2, 3, 4))
                #эффективен в случаях когда результаты все равно не сохраняются а используются временно, а данных много
                some_func(x**2 for i in range(10))
                ''.join(x * 2 for i in 'abc')
                #случай произвольго вложения
                    #создает два списка
                    #т.к. NS разные - логично использовать одно имя где это уместно, напр при последовательрных преобразованиях(объединении операций)
                    [x * 2 for x in [abs(x) for x in obj]
                    #выпускает только по одному val за раз
                    (x * 2 for x in (abs(x) for x in obj))
                    #создает только один список
                    [x * 2 for x in (abs(x) for x in obj)]
            #делают для iterable вроде map/filter в 3.X то что списковые включения для их вариантов в 2.X - предоставлят более общие кодовые структуры не опирающиеся на fx но откладывают результаты
            #не нуждается в лишних скобках if является единственный эл-том уже заключенным в круглые скобки
                i for i in range(3) >> SyntaxErr
                i for i in range(3),    >> SyntaxErr
                sorted(i for i in obj)      >> ok
                sorted(i for i in obj, reverse=True)    >>
                >> SyntaxErr,Generator expression must be parenthesized if not sole argument
            #возвращает <generator obj>, а не готовый obj
            #iterator/итерационный контекст
            #вместе с lambda заменяет генераторные fx(см.ГЕНЕРАЦИЯ ПЕРЕМЕШАННЫХ {xn})
истощение итератора/генератора
#по сути отсутствие простого способа вернуться назад(по крайней мере не с самописными)
генератор != итератор
          генераторы
          #генератор ПРИНАДЛЕЖИТ коллекциям?=> по идее нет - итератор это то что получается из коллекций
          #истощается как и итератор
          #obj - автоматически поддерживающий протокол итерации
          #выражение генератора = выражение возвращающее генератор
          #позволяют распределить вычисления по запросам результатов
      в чем отличие генератор/итератор?
        #генераторы - генерируют {xn} результатов при запросах
        #а итераторы просто выдают уже СУЩ
        #по идее можно сравнивать по методам >> судя по этому obj вроде map возвращают особые итераторы которые может быть и генераторы(короче легче не стало)
            I,G = iter([1]),(i for i in [1])
            set(dir(I)) - set(dir(G))   >> ({'__length_hint__', '__setstate__'}
            set(dir(G)) - set(dir(I))   >> {'gi_code', 'gi_frame', '__qualname__', '__del__', 'throw', 'send', 'gi_yieldfrom', 'close', 'gi_running', '__name__'})
        #поведение идентично
            G = (char.upper() for char in 'abc')
            I = iter('abc'.upper())
            next(I),next(G)         >> 'A','A'
            ...
            next(I)               >> StopIteration
            next(G)               >> StopIteration

думаю это bad
    for k in D: print(k,':',D[k])
    #вместо; явно выглядит лучше
    for k,v in D.items(): print(k,':',v)
итерируемые инструменты
#по идее то что подготавливает данные для дальнейшего итерирования по ним
    range
    zip
    ...
ПОВЕРХТНОСТНАЯ КОПИЯ
#~копия верхнего уровня - переходит по ссылке в var и копирует obj верхнего уровня со ссылками
#использование slice для копирования кажется мне гораздо менее читаемым вариантом чем .copy
        a,b = 1.1,1.1 #1.1 не кешируется
        l = [a,b]
        l[:][0] == l[0] >> True
        l[:][0] is l[0] >> True #тот-же obj
vars(obj)
#obj по умолчанию видимо текущая область видимости(__main__), кажется возвращает содержимое атрибута __dict__, словарь СОДЕРЖ все переменные в месте вызова
    a,*b = range(3)
    '%(a)s and %(b)s' % vars() >> '0 [1,2]'
область видимости var однозначно определяется местом присваивания,присваивания привязывают имена к области видимости,определяет где имя видимо для кода = лексическая область видимости(не зависящая от других факторов кроме места объявления)
в верхнем namespace vars() == globals() == locals() == dir(только ключи)
АРГУМЕНТЫ КЛЮЧИ
    передача None в качестве аргумента fx которая ожидает не None -> TypeErr
    open(path,None) >> Err
    slice(None) >> slice(None,None,None)
{xn}
#поля данных расположенные по фиксированным смещениям

string
    #первоначальный стандартный модуль строк, с 2.0 часть fx стали доступны как строковые методы, устарел, отсутствует в 3.x, сохранен в 2.X ради обратной совместимости. Не рекомендуется к использованию, использование ~ str в 3.X
    #отображает большинство вызовов на методы -> выполняет больше вызовов
        идет отдельным модулем
        длиннее в наборе при использовании отдельного namespace
        выполняется медленннее
    #3.x
        #содержит сис-му obj Template - "не вполне ясный" предшественник .format
            .template(<templateString>)
            #возвращает obj string.Template - шаблон в который можно подставлять значения аналогично '%s' % ()
            <string.Template>.substitute(*args,*kws)
            #подставляет значения в шаблон
                t = string.Template('$num = $title')
                t.substitute(num=7,title = 'string') >> '7 = string'
    #атрибуты
    .Formatter
    .ascii_letters
    .ascii_uppercase
    .ascii_lowercase
    .capwords()
    #~str.title()
    .digits
    .hexdigits
    .octdigits
    .printable
    .punctuation
    .whitespace >> ' \t\n\r\x0b\x0c'
*kws ~ *kwargs ?
substitute перевод?

.__format__()
#метод перегрузки операции форматирования(только выражение?)
obj одного типа поддерживают идентичный набор операций
    числа
    {xn}(конкатенация/размножение)
    отображения
    множества(не индексируются/не производят отображение)
в 3.X была предпринята попытка сгрупировать методы по категориям типов, но они все еще специфичнее операторов и fx
разнородность - способность содержать obj разных классов
collections
    .AsyncIterable
    #
    .AsyncIterator
    #
    .Awaitable
    #
    .ByteString
    #
    .Callable
    #
    .ChainMap
    #
    .Container
    #
    .Coroutine
    #
    .Counter
    #
    .Generator
    #
    .Hashable
    #
    .ItemsView
    #
    .Iterable
    #
    .Iterator
    #
    .KeysView
    #
    .Mapping
    #
    .MappingView
    #
    .MutableMapping
    #
    .MutableSequence
    #
    .MutableSet
    #
    .OrderedDict
    #
    .Sequence
    #
    .Set
    #
    .Sized
    #
    .UserDict
    #
    .UserList
    #
    .UserString
    #
    .ValuesView
    #
    .OrderedDict()
    #гибрид, хранит ключи в связном списке для поддержки операций над {xn}, потребляет больше mem, медленнее dict
    .namedtuple(typename,field_names,verbose=False,rename=False)
    #2.6+,3.X
    #может принимать **kwargs
    #организовывает доступ к эл-там(полям записи) по индексу и имени аттрибута(происходят из класса(указанные при создании) и не являются в точности словарными ключами - мне кажется это излишней формализацией - по сути имя тоже(очевидно что это разные obj), может быть преобразован в OrderedDict для доступа по ключу
    #именованные кортежи строят новые классы расширяющие тип tuple за счет вставки для КАЖДОГО именованного поля метода доступа property, отображащий имя эл-та на его позицию
    #гибрид tuple/class/dict с дополнительными шагами обработки
    #возвращает подкласс кортежа с именованными полями
        Point = namedtuple('point',['x','y'])
        #Rec = namedtuple('Rec',['name','age','jobs'])
        #bob = Rec('bob',35,{'google':['mgr','dev']})
        #bob.jobs['google'][0] = 'director'             #разумеется mutable типы внутри поддерживают изменение
        point.__doc__ >> 'Point(x,y)'
        dir(point) >> ... 'x','y'...
        #конструктор может одновременно принимать позиционные и ключевые args
        p = Point(11,y=22)
        p[0] >> 11                              #доступ по позиции
        p.x >> 11                               #доступ по имени attr
        p['x'] >> TypeErr
        d = p._asdict() >> OrderedDict([('x',11),('y',6)])
        d['x'] >> 11                            #доступ по ключу
        p = Point(**d)
        p.replace(x=100) >> Point(x=100,y=22)#p._replace(**kwds)
      ._fields
      #возвращает кортеж с именами полей obj
        Point = namedtuple('Point',['x','y'])
        p = Point(11,22)
        p._fields >> ('x','y')
      ._asdict()
      #возвращает collections.OrderedDict из collections.namedtuple
      #2.6
      #возвращает dict вместо OrderedDict(проверить)
      #zero args
обычно zero args подразумевает наличие self
    .deque
    #вроде уже было в любановиче
    .defaultdict(default_factory[,...])
    #dict c возможностью создавать obj по ключу
        collections.defaultdict() >> defaultdict(None,{})
связный список - "цепь" != list
raise
#генерация исключения(вызов "вручную")
    raise ValueError >> ValueErr
    #без аргумента вызывает RuntimeErr
поиск в неупорядоченных структурах быстрее
    d = dict(zip(string.printable,range(len(string.printable))))    #enumerate
    l = list(string.printable)
    s = set(string.printable)
    def f():
        'B' in <collections>
    timeit.repeat('for x in range(100):f()','from __main__ import f,<collections>',number=10000) #dict=0.22,list=1.51,set=0.22(явно видно что dict~set)
{x:x**2 for x in range(5)} #отображение одиночного потока значений на dict=> терминология Python
АННОТАЦИИ И ПСЕВДОНИМЫ ТИПОВ
#что-то не сработали аннотации типа (?проверить подробнее)
    #3.5+
    def add_two(x: Int) -> Int:return x + 2
    from typing import List
    Vector = List[float]
    Matrix = List[Vector]
    def add_matrix(a: Matrix, b: Matrix) -> Matrix:
        pass

=====статьяHABR_итераторы_генераторы====ДОДЕЛАТЬ(после банды 4х)
ИТЕРАТОР
    #паттерн
    #применение
        доступ к содержимому агреггированных obj без раскрытия внутреннего представления
        поддержка нескольки активных обходов одного агрегированного obj
        предоставление единообразного интерфейса для обхода различных агрегированных структур
    #результат
        унифицированный доступ к разным коллекциям
        коллекции становятся проще т.к. делегируют перебор своих эл-тов другой сущности
    #виды
       #внешний
        классический(pull-based) - процессом обхода явно управляет клиент(тот что выполняет запрос?) с помощью вызова Next
       #внутренний
        push-based, принимает callback fx, уведомляет клиента о получении следующего элта
БАНДА 4Х + МАККОНЕЛЛ ОБЯЗАТЕЛЬНЫ
=====\статьяHABR_итераторы_генераторы====
dbm
#интерфейс python к файлам DBM
    file = dbm.open('filename')
    file['key'] == 'data'
    file['key'] >> 'data'
DBM
#бд с доступом по ключу, похожая на dict
задача: возможна ли делегация и композиция в Python;почему да/нет;примеры
задача: if obj yt может ответить на сообщение возможно ли это обработать/перехватить;пример
задача: '''Будет ли создано две obj-fx 'm' при создании двух инстансов одного класса? а два объекта-метода?Почему равенство методов выдает false?'''
    class A(object):
        def m(self):
            pass
    a = A()
    b = A()
    a.m = b.m   >> False #по идее сравнение происходит рекурсивно, наверное сначала сравнятся obj которым принадлежат методы
задача: Возможны ли obj без классов?
    по идее нет
задача: Можно ли объявить obj-точку(с координатами x,y и методом .move) без объявления нового класса?
    модулем?
задача: чем грозит объявление def foo(a=[]):
    аргумент - ключевой и изменяемый, когда в теле мы изменим a, это значение будет сохранено до следующего вызова =>fx не будет работать ожидаемым образом - при каждом вызове без аргументов будет давать разный результат
задача: разнести оператор на несколько строк
    строка + exec
    скобки
    \
задача: каким образом функции test доступна локальная переменная z из foo
    def foo():
        z = 10
        def inner(x):
            print(x+z)
        return inner
    test = foo()
    test(5)     >> 15
        при создании test, test доступна переменная z т.к. inner - замыкание, => test запоминает лексический контекст inner(см. .__closure__)
задача: как вернуть параметр в исходное состояние на четвертый вызов(def(a=[]))
    передать ей значение вместо значения по умолчанию
задача: чем отличаются [x for x in range(10)] от (x for x in range(10))
    включение списка/генератора
что такое делегация?(передача полномочий?)
задача: построить список СОДЕРЖ 5 int нулей
    [0]*5
    [0,0,0,0,0]
    [0 for i in range(5)]
задача:создать список int разбитых на группы
    #на мой взгляд выглядит не очень
    l = [tuple(range(i,i+4)) for i in range(1,17,4)]
задача:построть {'a':0,'b':0}
    литерал
    {k:0 for k in 'ab'}
    defaultdict
    dict.fromkeys('ab',0)
задача: операции изменяющие dict на месте
    del
    присвоение
    .update
    .pop
    .popitem
ИТЕРАЦИОННЫЕ ИНСТРУМЕНТЫ
    включения
    #неявный цикл
    #может использоваться как альтернатива цепочке or;для выбора истинных значений из набора кандидатов неизвестных до момента выполнения возвращая все истинные, в отличие от or обычно возращает все истинные значения
    #более гибкий наследник map|filter, отображает выражение(вместо fx) на результаты(или наоборот - неважно)
    #были вдохновлены похожим инструментом из Haskell примерно в 2.0
вложенные циклы часто используются при работе с многомерными массивами
КЛАССИЧЕСКИЙ КОМПРОМИСС
#дополнительная функциональность(практичность) в обмен на необходимость написания добавочного кода и потерю производительности
property
#метод доступа, отображает имя на его позицию, использует форматированные строки кода вместо инструментов аннотирования классов
ИНСТРУМЕНТЫ АННОТИРОВАНИЯ КЛАССОВ
    метаклассы
    декораторы
итерационные контексты
#по идее контекст в котором происходит итерирование по obj(например в цикле)
#любые встроенные инструменты Python просматривающие эл-ты obj используют протокол итерации -> итерационные контексты/инструменты(.join/list/...)
банальный пример геттеров/сеттеров с wikipedia/Поле_класса
    class Foo(object):
	z = 0 #статический атрибут класса
	def __init__(self,x,y): #конструктор
		self._x = x 	#закрытый атрибут(на уровне соглашения между разработчиками)
		self.y = y 	#открытый атрибут
	def getx(self):return self._x #геттер - метод чтения(доступа)
	def setx(self,value):self._x = value #сеттер
	def delx(self):del self._x
	x = property(getx,setx,delx,"свойство 'x'.") #определение св-ва
нет смысла дублировать общие сво-ва в отдельный раздел(например поведение в exp сравнений), очевидно что св-ва и поведение obj определены в его классах
синтаксис операторов - способ кодирования логики обработки данных, правила определяющие структура оператора(obj)
синтаксис = синтаксический шаблон
пустые строки/пробелы игнорируются кроме
    завершения составного оператора в интерактивной подсказке -> делает невозможность вставки многострочного кода с составными операторами без их промежуточного выполнения
    когда находятся в строковых литералах
    применения для отступов
общая модель синтаксиса Python(синтаксическая модель операторов) применима ко всем операторам(составным?)
    <строка заголовка>:
        <code>
специальный случай синтаксиса составного оператора
    #по идее нарушает единообразие и усложняет поддержку
        ИСКЛЮЧЕНИЕ
            if exp: break
    #некоторые инструменты профилирования и покрытия кода могут не поддерживать такой синтаксис
    <строка заголовка>:<тело однострочного оператора>
по возможности используй >> 'first string' >> 'second string' >> ... в конспекте для записи многострочного вывода
оператор ;
    #разделитель операторов, удобен в интерпритаторе если нужно вывести результат работы операции
        L.sort();L
    #вывод нескольких print в одну строку
        print('first',end=' ');print('second') >> first second
    #обычно bad practice кажется адекватен при использовании пространств имен
        global x; x = 0
    #разделяет выражения которые должны находиться на разных строках)
        for i in range(10):i*=2;print(i) #bad practice
        #нельзя поместить несколько составных операторов в одну строку(без костылей вроде exec)
    #может стоять в конце строк ни на что не влияя - но очевидно что это bad practice
        x = 1;
        y
    #комментарии: октоторп экранирует ;, используй кавычки
        2**2;#or;2*2 >> 4
        2**2;'or';2*2  >> 4 >> 4
    #объединяет выражения в один блок(сохраняет уровень)
        x = 1
         x >> SytaxErr: unexpected indent
        x = 1;
          x >> ok
        x = 1   ;  print(x) >> ok
        for i in range(3): pass  ; print(i) >> #работает как обычно

    #альтернативы exec и включения/управл {xn}
        [exec(exp) for exp in ['for i in range(3):\n\tprint(i)']
чем обусловлено требование не начинать имена с цифр?
ПРИСВАИВАНИЕ КОРТЕЖАМ
    обмен значений в var
    #работает и со списками, но не с другими коллекциями, возможно класс должен иметь что-то что имеют tuple/list, например один из этих attr(хотя если слева не кортеж а цели возможно это не имеет смысла)
        (set(dir(tuple)) & set(dir(list))) - set(dir(set))
    #присвоение obj справа целям слева в соотв с их позициями(obj присваивается цели if их индексы равны)
    #цели слева не настоящий кортеж(так и не придумал как проверить)=> это очевидно - если бы это был кортеж - ничего бы не вышло - ведь он immutable
        a,b = ['a'],['b'];tuple((a,b)) = b,a >> Err:Can't assign to fx call
        #цели слева - не кортеж а независимые цели присваивания
    #эл-ты справа - настоящий кортеж распаковывающийся при присваивании, кортеж обеспечивает временное присваивание для достижения эффекта обмена(python создает временный кортеж хранящий значения срава во время выполнения присваивания)
    a,b = b,a
поведение var ~ поведению dict keys
    #должны быть инициализированы до вызова
    d = {}
    d['a'] >> err keyErr
    a   >> err,not defined
    #имена var можно обрабатывать как dict keys, т.к. они видимы в namespace модуля в словарях стекового фрейма(? то что возвращает locals()/globals())
ОПЕРАТОРЫ
    присваивание/операции неявно выполняющие присванивание = создание ссылок = связывание var c obj
    присваивание - просто оператор => в отличие от C - ничего не возвращает
        <цель присваивания> = <exp_создающее_obj>
            операции неявно выполняющие присваивание
                import
                def
                class
                переменные for
                аргументы fx
    вызовы и другие выражения(?)    выполнение fx
    for может применяться с else?
    pass
        #пустой заполнитель операторов,~None в объектах, явное отсутствие чего либо
        #может быть заменен любым exp
            def f():0
            f() >> None
        #применяется для:
          игнорирование exept перехватываемых try
          определение пустых классов ВКЛЮЧ attr с поведением подобным структурам/записям в других яп
            #бесконечный ничего не делающий цикл
            while True:pass
        #не прекращает выполнение
            for i in range(10):
                pass
                print(i)  >> #цикл работает как обычно
or в Erlang не ленив а жаден
ellipsis - троеточие, эллипс
...
#3.X+, создан для расширения срезов, используется например в NumPY
    #наивный пример для понимания
          def __getitem__(self, item):
              if item is Ellipsis:
                  return [self.a, self.b, self.c, self.d]
              else:
                  return getattr(self, item)
          x = MyClass(1,2,3,4)
          x[...]    >> [1,2,3,4]
#может находиться в ЛЮБОМ месте где разрешено выражение
    lambda:pass     >> SyntaxErr
    lambda:...      >> Ok
#замена pass/None/пустым obj
    #хотя на мой взгляд довольно хреновая(не равноценная)
        bool(...),bool(None),bool('')   >> True,False,False
        #or
        try:
            raise ValueError
        except: pass            >> #Ничего не возвращает
        try:
            raise ValueError
        except: ...             >> Ellipsis
#eliipsis, троеточие
#вроде не имеет каких-то особых attr
    type(...)   >> <class 'ellipsis'>
    ...       >> Ellipsis
#вполне рабочее значение
    [...,2,3].index(Ellipsis) >> 0
    [Ellipsis,2,3].index(...)   >> 0


ПРОСТРАНСТВА ИМЕН
#объявление имени в конкретной области видимости не обязательно означает инициализацию новым val, например global инициализирует имя в текущей области видимости ссылкой на уже СУЩ val
#области видимости != пространства имен ?(лутц)
#пространства имен делают obj более самодостаточными
#модули определяют глобальную область видимости(а fx(по идее как и классы) локальную), для включающего модуля глобальные var других модулей становятся также атрибутами
#модуль builtins определяет встроенную область видимости(Python), почти целиком из состоит из exept и fx
    import builtins
    dir(__builtins__) == dir(builtins)
    #это отдельное от global NS
        list = 1    #создаем var в global
        del list    #удаляем var из global
        list       >> <class 'list'>
        del list    >> NameErr
#области видимости объемлющих fx(nonlocal) может соответствовать несколько уровней namespace(при глубине вложенности fx более 2х)
#несмотря на название глобальное namespace охватывает только один файл - в Python нет настоящего всеобъемлюего глобального namespace основанной на файлах
    builtins(встроенные имена)
        global
            nonlocal
                local
область видимости=namespace
#место где определяются и ищутся и СУЩ var
#может предоставлять способ сохранения данных между вызовами fx
#в определенных ролях - альтернатива классов - замыкания
#мы может присваивать var из NS выше уровнем только вручную с исопльзованием конструкций вроде global
x = 'old'
def changeX():
	origin = x
	x = 'new'
changeX()       >> UnboundLocalError: local variable 'x' referenced before assignment #in origin = x
#нельзя сначала получить доступ к var c помощью legb а затем использовать объявление NS
x = 0
def f():
	y = x
	global x    >> SyntaxError: name 'x' is used prior to global declaration
def outer():
	x = 0
	def inner():
		y = x
		nonlocal x  >> SyntaxError: name 'x' is used prior to nonlocal declaration
#кроме LEGB СУЩ области видимости
    особые случаи
        временные var циклов включений
        #2.x временные var спискового(only) включения не локальны
            [i for i in [0]]
            i               >> 0
            {i for i in [1]}   >> 0
        #связываются с добавочной особой(чем?) областью видимости, в остальном следуют LEGB
            [i for i in [0]]
            i               >> NameErr
        var ссылок на exept обработчиков except
        #3.x уничтожаются при выходе из блока, даже if использовались ранее
            try:
                print(x)
            except NameError as e:
                pass
            e   >> NameErr
        #2.x не удаляются при выходе из блока
            try:
                print(x)
            except NameError as e:
                pass
            e           >> NameError("name 'z' is not defined")
    локальные области видимости в классах
    #подпадает под LEGB, local - NS класса(wft? а не наоборот?)
    #LEGB используется для распознавания имен на верхнем уровне класса и верхнем уровне его методов, но при поиске NS классы пропускаются - их var должны извлекаться как attr
        class Test():
            b = 1
            def __init__(self):
                print(b)
        x = Test()      >> NameErr
        class Test():
            b = 1
            def __init__(self):
                print(Test.b)
        x = Test()      >> 1
        class Test():
            b = 1
            def __init__(self):
                b = 2
                print(b)
        x = Test()      >> 2
        #вызов класса генерирует экземпляры со своей NS наследующие аттр класса
        class Test():
            b = 1
            def __init__(self):
                print(self.b)
        x = Test()          >> 1

#точечная нотация производит поиск в obj а не namespaces
#при импорте глобальное NS модуля становится NS атрибутов obj
    стандартное поведение
    #у каждого obj своя область видимости;ВСЕ var присваиваемые внутри fx - по умолчанию локальные;т.к. args передаются по присваиванию - они по сути не локальные, а параметры локальные
    #любые неуточненные(global/nonlocal) присваивания создают|изменяют локальные var
    #изменения на месте ищут var от local до builtins
    #при присваивании в global - локальная namespace совпадает с глобальной
        РАСПОЗНАВАНИЕ ИМЕН:ПРАВИЛО LEGB(LGB(<2.2),LNGB)
        #когда в fx указывается неуточненное имя(global/nonlocal) Python ищет его в L(ocal)/E(nclosing)/G(lobal)/B(uilt-in) namespaces останавливая поиск при первом совпадении(имена с нижних уровней отображаются на var в более верхних) или возвращая except
        #уровень enclosing 2.2+ - локальные области ВСЕХ объемлющих fx(каким было поведение до 2.2?)=>
            #в <2.2 вложенные fx ничего не делали в отношении областей видимости E => LGB
            x = 'global'
            def f1():
                x = 'nonlocal'
                def f2():
                    print(x)
                f2()
            f1()                >> 'global' #<2.2
        #enclosing = объемлющие области видимости = статически вложенные области видимости
        #enclosing часто используются lambda
        #поиск в Enclosing осуществляется аналогично(изнутри наружу)
            #изменение с nonlocal - аналогично
            def first():
                x = 'first'
                def second():
                    x = 'second'
                    def third():
                        print(x)
                    third()
                second()
            first()                 >> 'second'
    #переназначение стандарных obj в одном namespace не влияет на другие
        def f():
            list = ''
        f()
        list        >> <class 'list'>
    #локальная namespace и все obj(включая параметры) в fx создаются при вызове и удаляются при выходе, что облегчает работу с fx - большая часть obj используемых fx - создаются в самой fx
    #каждый активный вызов fx создает отдельную область видимости
    #fx позвляет вызывать саму себя =>
        def outer():
            x = 'old'       #nonlocal
            def inner():
                x='new'     #local
                print('inner',x)
            inner()
            print('outer',x)
        outer()
        try:
            print(x)        #global
        except NameError:
            print('X not in global')    >>  inner new
                                 >>  outer old
                                 >>  X not in global
    global
    #объявление NS,меняет правило поиска legb на gb;присваивание создает/изменяет var в global NS
        __name__ = 'global'
        def outer():
            __name__ = 'nonlocal'
            def inner():
                global __name__
                print(__name__)
            inner()
        outer()             >> global

    #как и global единственные инструменты напоминающие операторы объявления
    #отображает присвоенные имена на namespace модуля для их изменения/создания вне зависимости от того были-ли они присвоены, создает var ссылающийся на тот-же obj что и соответствующая global var(лутц:это вообще одна var-сомнительно,это же разные NS)
    #позволяет именять имена из модуля внешнего по отношению к fx(что за бред? для этого-же используется точечная нотация)
    #в отличие от nonlocal может создавать var
    #подход к управлению областью видимости
        global x
        x   >> NameErr: 'x' not defined
    #объявляет var уровня модуля предназначенные для присваивания
        x = 'old'
        def f():x = 'new';f();x >> 'old'
        def f():
            global x
            x = 'new'
        f();x >> 'new'
        global x = 'new' >> SyntaxErr
    #не создает имя без присваивания
        def f():
            global x
        f()
        x   >> NameErr
        def f():
            global x;x=0
        x   >> 0
    #позволяет изменять var в импортированном модуле(внешнем по отношении к fx)

    ЭМУЛЯЦИЯ GLOBAL
    #т.к. global var модуля - attr после импорта => можно эмулировать оператор global импортируя сам модуль и присвая его атрибуты()
    #global var ~ атрибуты модуля
        #создает заебанную рекурсию т.к. import выполняет весь код
        #thismod.py
        var = 0
        def glob0():
            import thismod
            thismod.var += 1
        #использование sys.modules
        def glob1():
            import sys
            glob = sys.modules['thismod'] #~sys.module[__name__]
            glob.var += 1
        def test():
            glob0()
            print('glob0>>',var)
            glob1()
            print('glob1>>',var)
        test()
        #thismod.py(v2)
        var = 0
        def glob0():
            import thismod
            thismod.var += 1
        def glob1():
            import sys
            glob = sys.modules[__name__]
            glob.var += 1
        def test():
            glob0()
            print(var, end=',')
            glob1()
            print(var)
        #main.py
        import thismod
        thismod.test()  >> 1,2
    nonlocal
    #~global => переписать участок сославшись на global
    #3.X объявление NS, что fx планирует изменение nonlocal var в ближайшей объемлющей fx содержащей соотв var(навязывает ограничение для поиска ссылок) что исключает ошибки ошибочной записи в global в случае например опечатки в именах => ищет var на этапе определения fx(т.к. это вполне логично)
        scam = 0
        def outer():
            spam = 0
            def inner():
                nonlocal scam;scam += 1
            return inner                >> SyntaxErr: no binding for nonlocal 'scam' found
    #может использоваться замыканием для предоставления изменяемой информации о состоянии
        def maker():
            N = 0
            def action(X):
                nonlocal N
                N += 1
                return X**N
            return action
        exp = maker()
        exp(2)  >>2
        exp.__closure__[0].cell_contents    >> 1
        exp(2)  >> 4
        exp.__closure__[0].cell_contents    >> 2
    #запятые - часть синтаксиса, не создают кортеж
        def f():
            nonlocal a,b,c  >> ok
        def f():
            nonlocal (a,b,c) >> SyntaxErr
    #как и global единственные инструменты напоминающие операторы объявления
    #подход к управлению областью видимости,отображает присвоенные имена на namespace объемлющей var для их изменения вне зависимости от того были-ли они присвоены
    #объявляет var объемлющей fx(по идее only) предназначенные для присваивания=> объемлющие fx могут сохранять состояния(информация сохраняемая между вызовами) без потребности в разделяемых глобальных именах(?)
        nonlocal x  >> SyntaxErr: nonlocal declaration not allowed at module level
        def outer():
            x = 'old'
            def inner():
                nonlocal x; x='new'
                print('inner',x)
            inner()
            print('outer',x)
        outer()
        try:
            print(x)
        except NameError:
            print('X not in global')    >> inner new
                                 >> outer new
                                 >> X not in global
    #
        class C():
            x = 0
            def meth():
                nonlocal x      >> SyntaxErr: no binding for nonlocal 'x' found
    #по идее получение доступа к obj выше уровнем, но не global=>объявляют имена
        x = 'old'
        def inner():
            nonlocal x;x='new'  >> SyntaxError: no binding for nonlocal 'x' found
            print('inner',x)
        inner()
    #требует наличие объемлющей fx и сооств присвоенных var еще до вызова(проверяются на этапе объявления) => не может динамически создавать var в отличие от global
        def outer():
            def inner():
                nonlocal x  >> SyntaxError: no binding for nonlocal 'x' found
    #область видимости объемлющей fx появилась в python позже для избавления от необходимости в передаче имен с помощью стандартных аргументов и т.к. чаще всего в enclosure лезли lambda - именно код с lamda выигал больше всего
        #особенно удобно для доступа к self
            class MyGui:
                def makewidgets(self):
                    Button(command=(lambda: self.onPress("spam")))
                def onPress(self, msg):
                    #using msg
    #в 2.X enclosure допускают только чтение но ИМЕЕТ альтернативы имеющие тот-же эффект с сохранением перезаписываемого состояния(эмуляция nonlocal)
    #более прямая и надежная реализация изменяемой информации о состоянии в контекстах где использьзование классов с attr/наследованием/мн-вом линий поведения избыточно
    #перенести этот кусок в варианты сохранения состояния?
аргументы по умолчанию = стандартные аргументы
        def outer():
            x = 'old'
            def inner():
                nonlocal x; x = 'new'
        #создание атрибута внешней fx ~ global var
        def outer(start):
            outer.state = start
            def inner(inc):
                outer.state += inc
                print(outer.state)
            return inner
        F = outer(0)
        F(10)       >> 10
        G = outer(40)
        F(10)       >> 50
        #изменяемые obj
        def outer():
            ns = {'x':'old'}
            def inner():
                ns['x'] = 'new'
                print('inner',ns['x'])
            inner()
            print('outer',ns['x'])
        outer()
        #сохранение данных в классе
        #в ряде контекстов использование классов может быть предпочтительнее nonlocal
        class Nonlocal(object):
            def __init__(self,**kwargs):
                self.__dict__.update(kwargs)
        def outer():
            nl = Nonlocal(x='old')
            def inner():
                nl.x = 'new'
                print('inner',nl.x)
            inner()
            print('outer',nl.x)
        outer()
            #сохранение состояния с помощью классов:явные attr
            #классы с attr делают доступ к информации о состоянии более явным чем legb
            #данные в экземпляре доступны извне(в отличие от nonlocal) как attr, которые по умолчанию доступны для изменения(м.б. недостатком)
            #определение inner/outer в классе явно регистрирующим состояние при создании obj
            class outer:
                def __init__(self,start):
                    self.state = start
                def inner(self,label):
                    print(label, self.state):
                    self.state += 1
            F = outer(0)
            F.inner('spam')                 >> spam 0
            dir(F)                       >> [...,'state']
            F.state                      >> 1
            #добавление __call__
                class outer:
                    def __init__(self,start):
                        self.state = start
                    def __call__(self,label):
                        print(label, self.state):
                        self.state +=  1
                F = outer(0)
                F('juice')                  >> juice 0
        #аргументы по умолчанию
        def outer(Nonlocal={}):
            Nonlocal[0] = 'old'
                def inner():
                    Nonlocal[0] = 'new'
                    print('inner',Nonlocal[0])
            inner()
            print('outer',Nonlocal[0])
        outer()
        #сохранение состояния с помощью mutable
        #по идее ~ args по умолчанию
        #еще менее очевидно, и старше чем атрибуты fx
        #опирается на то что изменение на месте не классифицирует имя как локальное
            def tester(start):
                def nested(label):
                    print(label, state[0])
                    state[0] += 1
                state = [start]
                return nested
            F = tester(0)
            'state' in dir(F)               >> False
            F('spam')                     >> spam 0
            G = tester(10)
            G('ham')                      >> ham 10
            F('spam')                     >> spam 1
        #использование глобальных var
        #требует объявление global в обеих fx(в данном случае для присвоения в outer и изменения в inner)
        #может конфликтовать с одноименнными var в global
        #допускает единственную разделяемую копию информации о состоянии
        def tester(start):
            global state
            state = start
            #этот кусок хер перепишешь на lambda т.к. присвоение
            def nested(label):
                global state
                print(label, state)
                #инкремент разделяемого глобального состояния
                state += 1
            return nested
        F = tester(0)
        F('spam')               >> spam 0
        G = tester(42)
        G('ham')                >> ham 42
        F('spam')               >> spam 43
        #сохранение в attr сгерерированной fx(см. Варианты сохранения состояния)
        #как и при использовании классов разрешает внешний доступ к состоянию и экономит строку кода(в случае если присать nonlocal x;x += 1 не принято в проекте)
        #inner - локальная var в NS outer => на нее можно ссылаться из inner
        def tester(start):
            def nested(label):
                print(label, nested.state)
                #изменение части obj != присваивание по имени var nested не изменяется => nonlocal не требуется(излишне формально)
                nested.state += 1
            #инициализация состояния должна быть вне inner т.к. иначе инициализация будет происходить при каждом ее вызове
            nested.state = start
            return nested
        F = tester(0)
        F('spam')       >> spam 0
        F('ham')        >> ham 1
        F.state         >> 2
PyChecker
#инструмент проверки кода
#выдает предупреждения при переопределении встроенных имен
PyLint
#инструмент проверки кода
#выдает предупреждения при переопределении встроенных имен
ПЕРЕОПРЕДЕЛЕНИЕ(экранирование) ВСТРОЕННЫХ ИМЕН
#следствие LEGB - var в нижнем NS могут переопределять(скрывать) var в более верхних NS для текущей области видимости(only), остальные NS ищут оригиналы в __builtin__
    #2.X
    True = False
    bool(0),bool(1)     >> (False,True)
#нет ничего неправильного(иногда даже желательно) в переопред встроенных имен, if исходная версия все равно не используется иначе более 150 var builtins трактовались бы как зарезервированные слова, например для расширения функционала встроенных типов или fx
#но обычно это опасная ошибка, т.к. при этом Python не выдает предупреждений в отличие от сторонних инструментов
#по всей видимости нельзя переопределять keywords
        #3.X
        False = True >> SyntaxErr: can't assign to keyword
        __builtins__.True = False >> SyntaxErr
        #2.x
        False = True    >> ok
РАЗРУШЕНИЕ МИРОЗДАНИЯ IDLE 2.X
    #переустановка bool для всего процесса Python
    #переводит IDLE в странное состояние паники сбрасывающее процесс пользовательского кода
    __builtins__.True = False   >> Traceback (most recent call last) >> RESTART: Shell
    import __builtin__;__builtin__.True = False #~__builtins__.True = False
    __builtins__.False = True   >> ok   #не сбрасывает процесс пользовательского кода
    #нормально работает вне IDLE, но по прежнему влияет только на текущуюю NS
        __builtins__.True = False
        bool(0),bool(1)     >> False,True
        
        
print = lambda s:print(s)
print('hi')             >> Traceback в рекурсии
ВАРИАНТЫ СОХРАНЕНИЯ(поддержки) СОСТОЯНИЯ
#используются для сохранения информации различающейся в зависимости от контекста между вызовами
#связаны с декораторами
#имеют дополнительные различающиеся характеристики вроде производительности
    замыкания
    #=нелокальное замыкание
        nonlocal
        #позволяет хранить в mem мн-во копий изменяемого состояния
        эмуляция nonlocal
            атрибуты 
                классов
                экземпляров классов
                fx
                #часто могут выполнять роль nonlocal более переносимо
                модулей
            var в объемлющей области видимости
            стандартные val аргументов fx
            изменяемые arg по умолчанию
                #стандартные val реализованы как одиночные obj присоединенные к fx => сохраняют состояние от вызова к вызову, инициализируясь лишь единожды
            глобальные var



    class
    #построение obj
    assert
    #отладочные проверки
        assert x > y, 'x too small'
        #не понял что за херня
            #походу выполняет выражение при False и пытается что-то сделать с возвращаемым значением, ничего не делает при True
            assert 4>3,'a';assert 4>3,print('a') >> ничего
            assert False,print('a') >> a >> AssertationError: None
            assert False,'a'    >> AssertationError: a
                #походу ничего не возвращает
                z = assert x>y,print('a') >> SyntaxErr:invalid syntax
del
#оператор удаления ссылок(obj удаляются gc)
#удаляет obj максимум в global, не может удалить obj из builtins
    del list    >> NameErr
    del __builtins__
    list        >> <class 'list'>
операторы
#=исполняемый код
    присваивания
        ФОРМЫ ОПЕРАТОРОВ ПРИСВАНИВАНИЯ
            базовая
            #наиболее распространенная, связывание var/компонента структуры данных с одиночным obj
            #по идее медленнее дополненого присваивания в соотв контекстах
                a = 1
            специальные необязательные формы
                последовательности(позиционное)
                #в недавних(каких?) версиях Python присваивание кортежей/списков были обобщены до присваивания {xn} - ЛЮБОЙ {xn} имен можно присваивать ЛЮБУЮ iterable значений равной длинны,т.е. под присваиванием {xn} подразумевается присваивание iterable
                #типы можно смешивать <tuple> = <str>, etc
                    присваивание кортежа
                        a,b = 1,2
                    присваивание списка
                        a,b = [1,2]
                    обобщенное присваивание {xn}(до любых iterable)
                        a,b = '12'
                        open(path,'w').write('first\nsecond')
                        a,b = open(path);a,b >>('first\n','second')
                        open(path,'w').write('first')
                        a,b = open(path) >> ValueErr: not enough values to unpack
                    присваивание вложенных iterable('{xn}')
                    #конечно работает и наоборот "т.к. цели справа не настоящий список"
                    #Python распакует {xn} согласно их формам(позиции) ожидаемым образом
                    #структуры {xn} должны совпадать
                        [a,b] = '1,2'
                        #может быть крайне полезно для выборки частей структур данных с известными формами
                            (a,b),c = s[:2],s[2:]
                            for (a,b),c in ([1,2], 3), ['XY',6]:print(a,b,c) >> 1 2 3 >> X Y 6
                    расширенная распаковка iterable ('{xn}') (3.X)
                        #может использоваться
                            выбор мн-ва стролбцов из строк данных(вложенных {xn})
                        #~распаковывающее присваивание {xn}
                            <otherTargets>,*b = <objs> ~ a,b[0],b[1],...,b[len(<objs>-len(<otherTargets>)]
                            #<otherTargets>,*b - более общий(обобщенный) набор имен
                        #всегда присваивает список элтов для помещенной цели вне зависимости от исходного типа iterable и колличества obj
                        #присваивает пустой список if все эл-ты были присвоены
                            a,b,c,*d = range(3);a,b,c,d >> 1,2,3,[]
                        #более простая альтернатива присваивания результатов slice
                        #*var помеченная цель, помещенной цели присваивается все данные не присвоенные другим var
                            a,b,*c = 'string';a,b,c >> ('s','t',['r','i','n','g'])
                            a,*b,c = 'string'   >>('s',['t','r','i','n'],'g')}
                        #помещеных целей должно быть не больше одной
                            a,*b,*c,d = range(4) >> SyntaxErr: two starred expression in assignment
                        #число var не должно быть больше значений
                            a,b,c,*d = range(2) >> ValueErr: not enough values to unpack
                        #помеченная цель должна ПРИНАДЛЕЖАТЬ {xn}
                            *a = range(3)   >> SyntaxErr: starred assignment target must be in a list or tuple
                            #альтернатива list()
                                *a, = range(3);a >> [0,1,2]
                                #кортеж
                                    *range(3), >> (0,1,2)
                                #список
                                    [*range(3)] >> [0,1,2]
                                #в вызовах
                                    print(*range(3)) >> 0 1 2
                        #разумеется расширенная распаковка вложенной {xn} просто меняет ее тип на тип коллекции в которой она находится
                            *['a','b','c'], >> ('a','b','c')
                        #расширенная распаковка применима к iterable
                            open(path,'w').write('a\nb')
                            *open(path),    >> ('a\n','b')
                        #расширенная распаковка в вызовах распаковывает коллекции в индивидуальные arg
                            open(path,'w').write('a\nb')
                            print(*open(path))  >> a
                                           >>  b
                        #развертывание сжатых кортежей(см zip())
                        #распаковка словаря возвращает ключи
                            [*d]    >> #~ list(d)
                        #расширенная распаковка возвращает тип соответствующий типу коллекции в которой она производится
                            L = list('abcdef')
                            {*L}            >> set
                            *L,             >> tuple
                            S = set(L)
                            *S,             >> tuple
starred - помеченное звездочкой/звезданутое:)?
кажется дополненное присваивание и присваивание {xn} несовместимы
#я чего-то не знаю?
    a,b += 1,1  >>SyntaxErr
    a,b += 1    >> SyntaxErr
#как и дополненное присваивание со сцепленными операторами
a = l += [2]    >> SyntaxErr
                групповое присваивание
                #присваивание ссылки на obj справа всем целям слева
                    a = b = list(range(3))
                    a is b >> True
                дополненное присваивание
                #отображаются на методы(перегруженны?)(по крайней мере часть из них) => позволяют смешивать типы(а это не нарушение строгой типизации?)
                #обычно выполняется быстрее даже для immutable(т.к. левый операнд(цель) оценивается только раз - особенно важно if это сложное выражение, хотя на мой взгляд это не важно т.к. в случае присвоения интерпритатору не нужно думать что за obj находится в цели, а сборщик мусора так и так уберет исходный obj)(лутц:конкатенация копирует obj слева, а затем справа(может по аналогии с обменом значений var?(копия данных сохраняется))) => оно таки реально быстрее на порядки
                    timeit.repeat('L = L + [0,1]','L = []', number = 30000) >> 12.17
                    timeit.repeat('t = t + (0,1)','t=()',number = 30000) >>  11.69 #immutable реально чуть-чуть быстрее, как минимум за счем меньшего размера и сложности
                    timeit.repeat('L[len(L):] = [0,1]','L=[]',number = 30000) >>
                    0.068 #гораздо менее читаемо и не очень-то и быстро
                    timeit.repeat('L += [0,1]','L = []', number = 30000) >> 0.035 #дополненное присваивание производит изменение на месте для mutable, якобы перегруженный extend, но выполняется даже быстрее
                    timeit.repeat('t += (0,1)', 't=()',number = 30000) >> 11.85 #для дополненного присваивания практически нет разницы
                    timeit.repeat('L.extend([0,1])','L=[]',number = 30000) >> 0.041
                    timeit.repeat('L.append(0);L.append(1)','L=[]',number=30000) >> 0.034

                #производит изменение на месте для mutable, и создает копию для immutable - не копирует лишний раз
                #новее базовой формы, меньший объем набора - всегда плюс
                #2.0+ дополнительный формат присваивания заимствованный из C, содержащий бинарную операцию и присваивание
                #работает для любого типа поддерживающего подразумевамую бинарную операцию

                    X += Y
                        #вызывает extend(отображается на extend) для конкатенации list
                    X -= Y
                    X *= Y
                    X /= Y
                    X //= Y
                    #2.2+
                    X **= Y
                    X %= Y
                    X &= Y
                    X |= Y
                    X ^= Y
                    X <<= Y
                    #операция сдвига влево x*2Y
                    X >>= Y
                    #операция сдвига вправо x/2Y
                #дополненное присваивание != базовому в различных контекстах
                    L = []; L += 'str';L >> ['s','t','r'] #отображается на .extend() который допускает iterable,изменяет obj
                    L = []; L = L + 'str' >> TypeErr
               #более подвержен эффектам разделяемых ссылок чем базовое присвоение(что по сути обычная ситуация - присваивание обычно создает ссылки)
                    m = l = [1,2]
                    l += [3,4]
                    m is l  >> True
               присваивание в выражениях
               #3.8+
                :=
    выражений

    вывода
альтернативы расширенной распаковки(работают и в 2.X)
    s = 'string'
    a,b,*c = s
    slice   <= отправить в slice
    #возврщате специфичный к типу результат(того же типа)
        #bad
            a,b = s[2:];c = s[2:]
        #good
            a,b,c = list(s[:2],s[2:])
            (a,b),c = s[:2],s[2:]
в other pl fx не возвращающие значение = процедура
ОПЕРАТОРЫ ВЫРАЖЕНИЙ
    операторы не могут использоваться в качестве exp(во избезжание ошибок(например записи присвоения вместо сравнения))
        if a=b:pass >> SyntaxErr
    => операторы не являющиеся так-же выражением должны находиться на отдельной строке(не могут вкладываться в более крупную синтаксическую структуру)
        например: операторы присваивания
    exp можно применять как оператор(на отдельной строке); т.к результат выражения не сохраняется - это имеет смысл только if выражение имеет побочные эффекты
        вызов fx/методов(не возращающие значения)
        отображение значений в интерактивном интерпритаторе
            #формально так-же являются операторами выражений - служат как сокращения для набора операторов print
    РАСПРОСТРАНЕННЫЕ ОПЕРАТОРЫ EXP
        вызовы fx/методов
        вывод(вызов) var в интерактивном интерпритаторе
      СПЕЦИАЛЬНЫЕ СЛУЧАИ
        #вывод результатов операций в 3.X
            print()
        #выдача val в операторах exp
            yield <exp>
составной оператор - оператор СОРЕРЖАЩИЙ другие операторы(обязательные/необязательные)
python позволяет {xn} компоновать операторы с произвольной глубиной
fx/методы принимают литеральные выражения результатом оценки которых являются obj
оценка = выполнение
вроде операторы изменения на месте(например методы list) возвращают None()(т.к. по всей видимости не имеют return)
аргументы = obj аргументов
командная строка интерактивной подсказки = интерактивный интерпритатор = модуль __main__ ~верхенему уровню файла модуля, но выводящий результаты и не сохраняющий свой код
используй оператор ';' в коде основного конспекта для сокращения
бинарная операция выражения - противоположность унарным операторам
оценка имени в obj = подстановка obj вместо имени =(по идее) следование по ссылке
не используй лишние скобки if уверен что они не нужны
    if (exp): #bad practice
в python конец строки(например \n) - конец оператора
один оператор - одна строка
отдельный блок кода определяется одинаковым набором отступов(tab/space)(их можно смешивать - bad), блок верхнего уровня в общем случае(есть исключения?) должен начинаться в начале строки
    x = 1       #блок 0
    if x:       #заголовок(блок 0)
        print(x) #блок 1
rubbery,shrubbery,nested - перевод?
блок кода = блок операторов = набор операторов
выравнивание часть синтаксиса python в отличие от C-like яп, решает проблему с разным стилем отступов у разных разрабов
    while (x>0) {
    x--;
        x--;}     #по идее будет работать в C т.к. блок кода
    #решает "проблему" с интерпритацией такого кода
        if (x)
            if (y)
                <code>
        else
            <code>
    #число tab|space должно быть идентично - последовательность не важно
    #формально табуляция - число пробелов кратное 8 (лутц) - в notepad так и есть
    #никогда не смешивай табы и пробелы(при разных настройках отображения tab/space - код будет нечитаем) (в любом яп)
        for i in obj:
        <tab><space>
        <space><tab>        #OK
        3.X
        #выдает исключение при использовании смешения tab/space if изменение ширины tab может сломать код
            #работает в 2.X
            for i in obj:
            <tab>
            <sp>*8     >> SyntaxErr: inconsistent use of tabs and spaces
    #-t флаг, при котором 2.X выдает предупреждения о использовании несогласованного смешивания tab/space перед выполнением
    #-tt флаг при котором 2.X ведет себя как 3.X и возвращает exept(TabError) при использовании несогласованного смешивания tab/space
несогласованное использование tab/space - использование их в одно блоке
Python - язык WYSIWYG(как это читается?)(what you see is what you get)
cmd/powershell умеет поиск по выводу по ctrl-f
продление exp(разнесение оператора/литерала на несколько строк)
    #/
    #eval/exec + строки
        eval('''2+
            1'''.replace('\n',''))
    #скобки(не только в литералах коллекций) продлевают выражения
    #[](){} -  ограничители операторов
        x+
        1   >> SyntaxErr
        [x+
        1]  >> ok
        #присвоение внутри структур недоступно
        [x=
        ]   >> SyntaxErr
        (1,
        2)  >> ok
        (1,2
        3)  >> SytaxErr
        [   i for
                i
        in      range(10)] >> ok
        ['asdf
        asdf']          >> SyntaxErr
        print('a',
        'b')        >> a b
        #отступы игнорируются
        (12   ,
            34 )   >> (12, 34)
        [def
        ]           >> SyntaxErr
        def f(
            a,b
            ):      >> ok
        ['first'
         'second']    >> ok
        print('first\n
             second')   >> ok
        if (a == b and c == d and
           d == e and e == f):
           print('a=f')
на первый взгляд простой код C можно довольно просто передодить на Python и обратно автоматически с помощью парсера
backspace - клавиша забоя:)
ПРОСТРАНСТВА ИМЕН
    #операторы не имеют отдельной области имен(решается например fx)
        for i in range(10):pass
        i   >> 9
        i = 'a'
        for i in range(10):pass
        i   >> 9

\ символ продолжения строк(операторов)
    #вроде наследие C
    #порождает больше ошибок
        #отслеживание \ сложнее скобок которые дополняются автоматом
        #после \ не должно быть отступов >> SyntaxErr: unexpected char after continuation character
        #при пропуске следующая строка может быть сочтена за отдельный оператор - усложняет отладку
            #если убрать \ => x==3 всесто 6 без вывода исключений
            x = 1 + 2 \
            + 3
        #вроде отголосок C где используется в макросах #define(я думал это инструкции препроцессора)
    #не используй!
    #более старая методика(bad practice) чем заключение в скобки
        for \
        in in \
        range(3):pass   >> ok
ТАБЫ ИЛИ ПРОБЕЛЫ
#по идее оптимально писать табами т.к. это сокращает ввод, а затем производить автоматическую замену на пробелы чтоб ни у кого не поехало
инкремент/декремент отсутствуют
    #для перегрузки ++ и -- возможно придется лезть в исходники Python и создавать свой форк
        #а может это есть в __future__? => хер
    #это нарушает логику унарных +/-
    #++/-- и их префиксная/постфиксная форма нарушают сразу несколько пунктов zen
        явное лучше неявного(префикстная/постфикстная,создание нового obj вместо изменения на месте)
        должен быть только один способ сделать это
    #++/-- в C в том числе был обусловлен компиляцией в асемблер
    #python не нуждается в нем(в C обычно используется в счетчиках) вместо этого есть for
    #дополненное присваивание позволяет использовать любой шаг
    #извращенные формы
        x -= -1
        x += -1
    #позволяет писать менее читаемый код
    #не вписываются в объектную модель, т.к. числа не поддерживают изменения на месте
пиши конспект так чтобы не критически важные детали можно было сворачивать
кажется idle и cpython могут иметь отличия реализации например with as 2.6+, IDLE 2.5+ (не проверял)
алгоритм - конечное число шагов т.к. иначе не будет достигнут результат(циклы - конечный набор)
а я вполне могу упрощать выражения без ручки
        x	y	z	*
        0	0	0	0
        0	0	1	1	notX*notY*z+
        0	1	0	0
        0	1	1	1	notX*Y*z
        1	0	0	0
        1	0	1	0
        1	1	0	1	x*y*notZ
        1	1	1	1	x*y*z
any(iterable,/) -> bool
#True если хоть один эл-т True и наоборот;True для пустых iterable т.к. ~ True or elt0 or...
#накопление значений истинности
all(iterable, /)
#True если все эл-ты True и наоборот;False для пустых iterable т.к. True and elt0 and ...
#накопление значений истинности
оператор цикла = циклическая конструкция
конструкция else циклов характерна только Python
    #предлагает явный синтаксис для распространенного кодового сценария (проверки принудительного выхода из цикла) без установки флага/проверки условия(if ...:b=True;break)
    while <проверка>:
        <code>
    else:                   #конструкция
        <еслиНеСработалBreak ВКЛЮЧ случаи когда цикл не выполнился ни разу>
        #примеры
            while False:pass
            else:print('else') >> else
            x = 0
            while x<10:x+=1
            else:print('else') >> else
else и break позволяют обойтись без флагов состояния поиска, например для случаев неудачного поиска
    не нужно проверять нашолся ли элт-> как только оно нашлось цикл завершится
        #проверка на простоту
            x = y // 2  #y > 1; // для исключения float
            while x > 2:
                x -= 1
                if y % x == 0:break
            else: l.append(y)
        #поиск эл-тов в цикле
            found = False
            while x and not found:
                if match(x[0]):found = True #match абстрактная fx
                else: x = x[1:]
            if not found:print('not found')
            #замена флага на else
            while x:
                if match(x[0]):
                    print('found!')
                    break
                x = x[1:]
            else:print('not found')
    #for/else обобенно удобна т.к. итерация по {xn} не находится под моим контролем(т.е.  я например не могу явно выбрать следующий эл-т)
эмуляция do...until
    #if/break
        while True:
            <code>
            if exitTest(): break
эмуляция C while
    #т.к. операторы не могут находится в местах где ожидается exp => распространенный кодовый шаблон:
        while ((x = next(obj) != NULL) {<обработка x>}
        #отсутствует в Python, не скажу что он прям таки сильно нужен, и это вроде не похоже на Python-style
      перенос присваивания в тело + break
      #наименее структурированный, но простой и часто встречающийся
        while True:
            x = next(iterator)
            if not x: break
            <обработка x>   #например проверка на простоту print(prime(x))
      перенос присваивания в цикл с проверкой, таким образом избавившись от break
        x = True
        while x:
            x = next(obj)
            if x:
                <обработка x>
      вынос первого присваивания из цикла
      x = next(obj)
      while x:
        <обработка x>
        x = next(obj)

      #конкретная реализация одного из вариантов эмуляции
        def match(y):
            x = y // 2
            while x > 2:
                x -= 1
                if y % x == 0: break
            else: return y
        l = (i for i in range(100,1,-1))
        try:
            while True:
                x = next(l)
                if match(x):res.append(x)
        except:pass
функции можно использовать как условие для управления циклом
эмуляция goto
  continue/if
    #bad собирает все недостатки goto  <- отправить в BAD
    x = 10
    while x: #goto
        x -= 1
        if x % 2 != 0: continue
        <code>
  #может использоваться для выхода из вложенных циклов
  эмуляция с помощью exept
  #по идее вызываешь exept при получении результа и переходишь в блок exept
      ограниченный путь
      структурированный путь
continue
#инициализирует переход в начало цикла, завершение текущей итерации и переход к следующей
break
#немедленный выход из цикла пропуская else
ОБЩЕЕ
    значение по умолчанию чтобы все False значения были False, а не например None
    #or даже не будет вычислен без необходимости
        <exp> or False
has factor - имеет сомножитель
production -? произведение
ИДЕИ
    онлайн торрент плейер кеширующийся на стороне клиента(может расширение?)
    онлайн сервис заметок на аудио
        аккаунт
        разпознавание речи
        убирание пауз
    составление рациона по параметрам
        рост/вес/заболевания/...
ПРИМЕРЫ КОДА
    наивный обход вложенной структуры(с заранее известной глубиной вложенности), повторами
        items = ['aaa',111,(4,5),2.01,(4,5)]
        tests = [(4,5),3.14]
        for key in tests:
            if key in items:        #чтоб не выдал exept
                p = items.index(key)
                for i in range(items.count(key)):
                    print(key, 'in', p)
                    p += 1
                    #довольно тупое решение т.к. число проходов заранее известно
                    try:
                        p = items.index(key,p)
                    except:pass
    наивный обход влоежнной структуры с простым определением наличия элта(с заранее известной глубиной)
        items = ['aaa',111,(4,5),2.01]
        tests = [(4,5), 3.14]
        for key in tests:
            for item in items:
                if item == key:
                    print(key,'was found')
                    break               #исключает поиск дублей
            else:
                print(key, 'not found')     >> (4,5) was found >> 3.14 not found
            #упрощение
                for key in tests:
                    if key in items:
                        print(key, 'was found')
                    else:
                        print(key, 'not found')
    обход вложенной структуры с заранее неизвестной глубиной
        рекурсия(с отдельной fx) + проверка на наличие вложенности
        #охуеть, я че сам допер?!
        #вне сомнений уебищное решение, лучше использовать с return, но лучше я позже разберусь
        items = ['aaa',111,(4,5),2.01,[list('key')]]
        l = []
        def extract(obj):
            for elt in obj:
                #отсутствует проверка например на словарь - можно легко добавить
                if '__iter__' in dir(elt) and not type(elt) == str: extract(elt)
                #return здесь остановит выполнение на первом же шаге, yield сожрет вложенные эл-ты(кстати почему=> неправильно применял?)
                else: l.append(elt)
        extract(items);l            >> ['aaa',111,4,5,2.01,'k','e','y']
        #набросок альтернативы
           if вложенный: extract(elt)
           иначе: return elt.extend(extract(следующий элемент)
   более медленная альтернатива map
        #list(map(lambda *args: sum(args),l0,l1))
        res = []
        for i in zip(iter0,iter1):res.append(fx(i))
   пересечение коллекций
        set(<obj0>) & set(<obj1>)
        #или
        res = []
        for x in <obj0>:
            if x in <obj1>:
                res.append(x)
        #или
        [x for x in <obj0> if x in <obj1>]
    пересечение произольного числа коллекций
    #проверяем наличие эл-тов из первой колекции в остальных, т.к. пересечение зависит от всех мн-в
        def intersect(*args):
            res = []
            for x in args[0]:
                if x in res:continue
                for other in args[1:]:
                    if x not in other: break
                else:
                    res.append(x)
            return res
        intersect('asdfbc','sadfb')             >> ['a', 's', 'd', 'f', 'b']
        #мои дебильные попытки подражать
            #не прерывает цикл if эл-та в одном из мн-в все-равно нет
                def intersect(*args):
                    res = []
                    for elt in args[0]:
                        if elt in res: continue
                        for other in args[1:]:
                          if elt in other:
                            res.append(elt)
                    return res
            #выполняет больше работы
                def intersect1(*args):
                    res = []
                    for elt in args[0]:
                        for collect in args[1:]:
                          if elt in collect:
                            res.append(elt)
                    return res
        #можно переписать на классе для расширения fx
    объединение произвольного числа коллекций
        def union(*args):
            res = []
            for seq in args:
                for x in seq:
                    if not x in res:
                        res.append(x)	#если еще нет в res
            return res
            #мои дебильные попытки подражать
                #работает только для списков т.к. res становится первой коллекцией
                    def union1(*args):
                        res = args[0]
                        for collection in args[1:]:
                            for elt in collection:
                                if elt not in res:
                                    res.append(elt)
                        return res
            #можно переписать на классе для расширения fx
    проверка работы fx в зависимости от порядка args
        def tester(func, *items, trace=True):
            for i in items:
                items = items[1:] + items[:1]
                if trace: print(items)
                print(sorted(func(*items)))
                #fx была бы проще if делегировать выполнение перестановки другой fx генерирующей/создающей комбинации args
scramble - перевод?
                    ГЕНЕРАЦИЯ ПЕРЕМЕШАННЫХ {xn}
                        def tester(func, items, trace=True):
                            for args in scramble(items):
                                ...
                    ПРОСТЫЕ FX
                    #см. методики написания циклов
                        #процесс добавления в пустой list явно намекает на возможность исользования yield|включений
                            def scramble(seq):
                                res = []
                                for i in seq:   #можно не париться о изменеии счетчки цикла т.к. его размер не меняется
                                    #присвоение в цикле мешает использовать включения
                                    seq = seq[1:] + seq[:1]
                                    res.append(seq)
                                return res
                            def scramble(seq):
                                res = []
                                for i in range(len(seq)):
                                    res.append(seq[i:] + seq[:i])
                                return res
                            scramble('spam')    >> ['spam', 'pams', 'amsp', 'mspa']
                        #используем включения
                            def scramble(seq):
                                return [seq[i:] + seq[:i] for i in range(len(seq))]
                    ГЕНЕРАТОРНЫЕ FX
                    #экономит mem и снижает задержки
                        #дает доступ к внутреннему генератору
                        def scramble(seq):
                            yield from (seq[i:] + seq[:i] for i in range(len(seq)))
                        def scramble(seq):
                            for i in range(len(seq)):
                                yield seq[i:] + seq[:i]
                        def scramble(seq):
                            for i in seq:
                                seq = seq[1:] + seq[:1]
                                yield seq
                        [*scramble(['a', 'b', 'c']]         >> [['b', 'c', 'a'], ['c', 'a', 'b'], ['a', 'b', 'c']]
                    ВКЛЮЧЕНИЯ ГЕНЕРАТОРА
                        seq = 'spam'
                        G = (S[i:] + S[:i] for i in range(len(S))
                    lambda + генераторные exp
                        scramble = lambda seq: (seq[i:] + seq[:i] for i in range(len(seq)))
                        G = scramble([1,2,3])
                        [i for i in G]      >> [[1,2,3],[2,3,1],[3,1,2]]
    проверка работы fx в зависимости от порядка args с генерацией результатов по запросу
        #scramble.py
        def scramble(seq):
            for i in range(len(seq)):
                yield seq[i:] + seq[:i]
        #inter2.py(дубль)
        def intersect(*args):
            res = []
            for elt in args[0]:
                if elt in res: continue
                for other in args[1:]:
                  if elt not in other: break
                else:
                  res.append(elt)
            return res
        def union(*args):
            res = []
            for collection in args:
                for elt in collection:
                    if elt not in res:
                        res.append(elt)
            return res
        #tester.py
        from scramble import scramble
        from inter2 import intersect, union
        def tester(func, items, trace=True):
            for args in scramble(items):
                if trace: print(args)
                print(sorted(func(*args)))
        tester(intersect,('aab', 'abcde', 'ababab'))
        tester(intersect, ([1,2], [2, 3, 4], [1, 6, 2, 7, 3]), False)
    проверка работы fx используя set и декоратор
        def scramble(seq):
            for i in range(len(seq)):
                yield seq[i:] + seq[:i]
        #передать параметр так по идее не выйдет(может и можно через некие костыли)
        def tester(func, trace=True):
            def decorated(*args):
                for items in scramble(args):
                    if trace: print(items)
                    print(sorted(func(*items)))
            return decorated
        #только для мн-в!
        @tester
        def intersect(*args):
            return set.intersection(*args)
        @tester
        def union(*args):
            return set.union(*args)
        a,b,c = set('123'),set('325'),set('5')
        union(a,b,c)
        intersect(a,b,c)

        
    посимвольное чтение файла
        #файл загружается в mem целиком, и по идее выполняется быстрее
        for char in f.read():...
        #файл читается посимвольно
        while True:
            char = file.read(1)
            if not char: break
            print(char)
        #чтение построчно
            #изврат, работает медленее т.к. выполняет байт-код в PVM вместо использования итератора(на C)
            while True:
                line = file.readline()
                if not line: break
                print(line.rstrip())    #для удаления \n в конце каждой строки
            #загрузка всего в mem - первоначальный старый, не очень надежный способ, по идее экономит время диска
            for line in f.readlines():...
    инверсия строк в файле
        for line in reversed(open(path).readlines()):
            <запись строк в другой файл>
        #readlines конечно запихает весь файл в mem
        #проще(и обычно быстрее) запихать весь файл в память, развернуть и записать обратно
        #иначе писать в другой файл через итератор и reversed
    чтение вывода из консоли
        import sys,os
        stdout_encoding = sys.stdout.encoding
        for (i,line) in enumerate(os.popen('systeminfo')):
            if i> 4:break
            print('%03d %s' % (i,line.encode(stdout_encoding).decode('866').rstrip()))
      узнать разрядность системы(извращенно)
            for line in os.popen('systeminfo'):
                line = line.encode('1251').decode('866')
                parts = line.split(':')
                #если parts не пустая, затем сравнение(по идее это быстрее -> проверить) ?
                if parts and parts[0].lower() == 'тип системы':
                    print(parts[1].strip())
    накопление результатов с map
        def accum(n,res):
            res += n
            return res
        M = map(accum,range(t))

как развернуть содержимое файла, не создавая новый файл(строки/все содержимое)? -> поломался на управляющих {xn} + мои решения были полным говном
    #возможно можно с использованием fileinput, но он вроде загружает в mem всю строку
        да по сути нет смысла, если файл не разряжен(?не увенен что верный термин) как например виртуальные диски=> ~ байтовых строк, для вставки придется перемещать последующие части файлов
            думаю имеет смысл разобрать это в C++/алгоритмах
регулярно перечитывай ZEN OF PYTHON
Многие задачи сложны - и их нельзя упростить просто сокращением кол-ва кода
    лаконичность зачастую притягательнее чем следовало бы
    код следует сохранять простым if он не обязан быть сложным
if требуется переписывать код чтобы его понять - он должен остаться в переписанном виде
KISS - Keep It Simple, Sir
    #исключение - повышение производительности(с сохранением читаемости) - иначе возможно следует использовать другой яп
как только конструкция перестает быть очевидной - она требует переписывания
использую встроенные высокоуровневые инструменты Python как можно чаща => код лаконичнее, короче и обычно быстрее
    if в цикле нужны и key и values => .items()
        if только values => .values()
    например in вместо ручного перебора структуры для определения наличия эл-та
    не следует заниматься ручным подсчетом чего-либо => используй итерационные средства
    включения
        #лаконичнее, быстрее циклов и создают отдельную область видимости
        #плохо читаемы для сложных конструкций
    for быстрее while, понятнее сложных включений
    встроенные методы обычно быстрее
        .startswith('str') вместо [:3] == 'str'
    методы зачастую читабельнее exp
        	ids = []
        	i = 1
        	ids += id(i)
        	i += 1
        	ids += ids(i)
        	#methods
        	ids = []
        	i = 1
        	ids.append(id(i))
        	i += 1
        	ids.append(id(i))
    разделяй эл-ты коллекций пробелами после ','
        print('first', 'second')
    используй enumerate когда нужен и элт и позиция
    наличие range обычно признак ошибки => стоит заглянуть в цикл
def vs lambda
#лаконичность выражения vs мощь оператора
    lambda - простые fx
    def   - сложные fx
использование трюков может приводить к ухудшению читаемости
    обход ограничений lambda
запутанный код = нечитабельный
_thread
#модуль standart lib реализующий поддержку многопоточности
thread
#2.X ~ _thread
threading
#модуль standart lib реализующий поддержку многопоточности
queue
#модуль standart lib реализующий поддержку многопоточности
МНОГОПОТОЧНОСТЬ
    #все потоковые fx exe в одном процессе - глобальные NS могут служить одной из форм разделяемой mem
    #потоки могут разделять global var и obj в mem процесса
    #используется для длительно выполняющихся задач в GUI для реализации неблокирующих операций и максимальной загрузки CPU
    #обеспечивает exe вызовов fx параллельно с останой программой
    использование генератоных fx
    #механизм многопоточной обработки для бедных - чередуют работу вызывающего кода с кодом fx - Но все это конечно в одном потоке управления(возможно процессорные оптимизации вроде hyperthreading ускоряют работу в данном случае)
    #проще в написании чем настоящаяя многопоточность
    #т.к. управление явно направляется на вызовы yield и next => генераторы не возвращаются к пред состоянию и имеют большее отношение к сопрограммам
    очередь
    #производители результатов выполняются независимо и отправляют результаты в очередь
в python для создания чего-то потенциально неправильного нужно писать добавочный код
информация о состоянии - используется fx при следующем вызове
    альтернативы допускают наличие мн-ва копий информации, но сложнее использования global vars

ПРОЭКТИРОВАНИЕ ПО
    чрезмерное использование глобальных var - в большинстве случаев bad practice => минимизируй
    #глобалные var наиболее прямолинейный способ сохранения разделяемой информации о состоянии
    #иногда сохраняются в отдельном модуле собирающем global vars
    #используются как коммуникационный механизм(разделяемая mem) при многопоточном взаимодействии fx выполняющихся в параллельных потоках
    ВЗАИМОДЕЙСТВИЕ fx
    #должно полагаться на аргументы и возвращаемые val вместо глобальных var(это часть fx парадигмы?)
        #дополнительный код(напр global)
        #делает fx взаимозависимыми через глобальную var
        #значения var зависимы от порядка вызова fx => код становится трудно читаемым и отлаживаемым и отличаются в различные моменты времени
            #по коду этого модуля нельзя понять каким будет x, т.к. после импорта fx могут вызываться в произвольном порядке -> усложняет отладку/понимание, придется отслеживать поток управления через несколько модулей/всю программу, и помнить ее структуру при модификации/использовании
            X = 99
            def func1():
                global X
                X = 88
            def func2():
                global X
                X = 77
    МИНИМИЗАЦИЯ КОЛЛИЧЕСТВА МЕЖФАЙЛОВЫХ ИЗМЕНЕНИЙ
    #не следует изменять var других модулей(через границы файлов)
        #first.py
        X = 'old'
        #second.py
        import first
        first.X = 'new'
    #такое поведение чрезмерно неявно - разработчик отвечающий за сопровождение first.py не знает что другой модуль изменяет first.py(ну и? если var вообще использутеся(как и модуль) изменения в нем все-равно могут нарушить совместимость)
    #делает связность модулей слишком тесной - оба зависимы от одного obj(без присваивания это все-равно было-бы так, разве нет?) - "понять/повторно использовать один файл без другого затруднительно"
    #создает негибкий код,или к ошибкам
    #СУЩ ПО где межфайловые изменения широко распространенная практика
        АЛЬТЕРНАТИВА
        использование взаимодействия fx(передача args/получение val)(интерфейсов)
            использование fx доступа для управления изменениями(сеттер)
            #делает внешние изменения явными, позволяет управлять доступом в одном месте
            #если имя | вся логика в first будет изменены - не придется переписывать остальные модули - сохранение инкапсулированности
            #устараняет эл-т неожиданности
                #first.py
                X = 'old'
                #разраб увидев это поймет что она входит в состав интерфейса, и будет ожидать изменения X в других модулях
                def setX(new):
                    global X
                    X = new
                #second.py
                import first
                first.setX('new')
МЕТОДИКИ НАПИСАНИЯ ЦИКЛОВ
    ПРОСМОТР ITERABLE
        for item in x:  #good
            print(x)
        #больше контроля на индексацией, может потребоваться в некоторых контектах
        i = 0
        while i < len(x):
            print(x[i])
            i += 1
        #ручная индексация в for
        for i in range(len(x)):
            print(x[i])
            #кодовый шаблон позволяющий реализовывать специальные виды обхода, например некоторые алгоритмы могут переупорядочивать {xn}
            #зачастую можно заменить на enumerate
                #генерация вариантов при поиске(?)
                #проверка эффекта от разного упорядочивания значений
                #etc
                    #такие случаи могут требовать смещения для разделения {xn} и ее повторного объединения
                    #распространеный кодовый шаблон, применяется для
                        #тестирования fx с разным порядком аргументов
                    s = 'spam'
                    #можно поменять строки местами для начала с 'spam'
                    #использование присваивания мешает использовать включения(без :=)
                    #bad practice!
                    for i in range(len(s)): #i счетчик повторений
                        s = s[1:] + s[:1]
                        print(s,end = ' ')  >>  pams amsp mspa spam
                        #good practice!
                        for i in s:
                            s = s[1:] + s[:1]
                            print(s)
                        
                    #конец + начало
                    for i in range(len(s)): #i позиция нарезания и счетчик
                        print(s[i:] + s[:i])   >> spam pams amsp  mspa
                    #альтернатива - рекурсия
    НЕПОЛНЫЙ ОБХОД
        #~пропуск эл-тов~обход в неполной манере
            #range/len менее читаем, потребляет меньше mem, bad
            s = 'abcdef'
            for i in range(0,len(s),2):print(s[i])
            #slice более читаем, потребляет больше mem, good
            for char in s[::2]: print(char)
    ИЗМЕНЕНИЕ MUTABLE
        a,b,c = [0],[1],[2]
        for i in a,b,c:i.append('z')
        a,b,c   >> [0,'z'],[1,'z'],[2,'z']
        #or
        #нельзя сделать это проще, т.к. итерирование по {xn} проходит по эл-там а не позициям; не рекомендован, больше кода чем во включении
        L = list(range(1,6))
        for i in range(len(L)):L[i] += 1
        #while - как обычно медленнее
        i = 0
        while i < len(L):
            L[i] += 1
            i += 1
        #включение самый быстрый вариант, но создает новый obj;короче, рекомендован
        #присвоение самому себе не обновит любые другие ссылки на исходный список
        L = M = list(range(10))
        L = [elt + 1 for elt in L]  >> #M без изменений
избегай вызовов range() в циклах => итерируйся сразу по iterable
    фиксированное число повторений
        for i in range(obj)     =>      for i in obj
    просморт смещений
        старайся обойтись
    пропуск элементов
        срезы
    etc


    ПАРАЛЛЕЛЬНЫЙ ОБХОД
    #параллельные итерации
        for (x,y) in zip(L1,L2):
            print(x,'+',y,'=',x+y)
        #while bad
        #обработка для выбора наименьшей xn, альтернатива - try
            if len(L1) < len(L2):
                count = len(L1)
            else:
                count = len(L2)
            i = 0
            while i < count:
                print(L1[i],'+',L2[i],'=',L1[i] + L2[i])
                i += 1
zip,map,etc возвращают генераторы значений = генераторы
ОШИБКИ
    C style
        if (x==1)   | if x
    использование while|range без крайней необходимости
    неверное использование разделяемых ссылок и изменения на месте
    модификация стандартных val изменяемых args
КОДИРОВКА
        #Несоответствие кодировок ведет к исключениям
            sys.getdefaultencoding()    >> 'utf-8'  #кодировка модуля sys по умолчанию,кажется кодировка системы
        sys.getfilesystemencoding() >> 'mbcs'   #хз
        #кодировка стандатных потоков
            sys.stdout.encoding     >> 'cp1251' #
            sys.stderr.encoding     >> 'cp1251'
            sys.stdin.encoding      >> 'cp1251'
            locale.getpreferredencoding >> 'cp1251' #кажется используется для графической части win
        + не забываем про кодировку файла

            #распространенный хак
            sys.setdefaultencoding(locale.getpreferredencoding()) #работает с print, ломается при выводе через logging
            s = ''’ҐЄгй\xa0п Є®¤®ў\xa0п бва\xa0\xadЁж\xa0: 866\n''
            s.encode('1251').decode('866')      >>ok
вместо задействования программ shell можно эмулировать их поведение = эмулятор с внутрипроцессным кодом(жутко формальная банальщина) - тупо код в моей программе вместо использования стронней программы
    #эмуляция функции Unix-утилиты awk по извлечению столбцов(седьмого) из текстового файла(с разделителями - пробелами)(разумеется есть еще куча вариантов реализации)
        #генерация такого файла
            with open(path,'w') as fout:
                for j in range(4):
                    for i in range(1,8):
                        print(i,end = ' ',file=fout)
                    print(file=fout)
    #смесь цикла и включения - а почему бы и нет?
    #генератор был бы еще круче экономя mem
    for val in [line.split()[6] for line in open(path)]:print(val)
urllib
    .request
        .urlopen()
        #предоставляет интерфейс подобный файлу к содержимому веб-страницы
        #содержит bytes
        #Возвращает <http.client.HTTPResponse object at 0x011431F0>
        #как будто истощается
ПРОТОКОЛ ИТЕРАЦИИ
    #концепция, модель на основе вызовов методов, полный протокол использует __next__ и __iter__(а может и __getitem__)
    #производит захват одного элемента на каждой итерации;автоматически применяется к итерационным инструментам/контекстам
    #по большей части состоит из интерфейса .__next__()/.next()(2.X)
    #3.X идентичен 2.X кроме имен методов
    #полный протокол итерации основан на двух obj - iterableObj,iterator
        итерационный инструмент/контекст дергает .__iter__(вызов верхнего уровня) -> выполняет внутренние шаги требующиеся для поддержки next() для данного obj
         , возвращает obj итератора(или тот-же obj), который генерирует значения в ответ на next()
    #большинство итерационных инструментов исползуют __next__ для получения следующего эл-та и перехватывают except StopIteration для прекращения итерирования
        s = 'abcd'
        for i in :print(i)
        #мой быдло код(этот код действительно плох?почему?)
        s = 'abcd'
        if type(s) == str: obj = str.__iter__(s)
        try:
            while True:
                print(obj.__next__())
        except:pass
        #лутц(чем это лучше моего быдло кода кроме next() и перехвата конкретного exept?)
        L = list('abcd')
        I = iter(L)
        while True:
            try:
                x = next(I) #универасально, ~ I.__next__() в 3.X
            except StopIteration:
                break
            print(x)
    практически вездесущ
        list(fileobj) >> ok
        ''.join(fileobj)    >> ok
    итерационные инструменты/контексты могут работать иначе вместо использования протокола итерации(стандартного) для пользовательских классов многократно индексируруя obj, но предпочитают протокол итерации if он используется
думаю односимвольные имена var не счетчиков/целей лучше писать в верхнем регистре, во избежание путаницы

elt*-1  => -elt

плоский код = flat code лучше вложенного
    def f1():
        x = 'f1'
        f2(x)
    def f2(x):
        print(x)
    f1()
    #вместо
        def f1():
            x = 'f1'
            def f2(x):
                print(x)
            f2(x)
        f1()
#удобно и на мой взгляд логично использовать идентичные имена имеющие схожий смысл на разных уровнях NS
    #acts в fx и global - список fx
    def makeActions():
        acts = []
        for i in range(5):
            acts.append(lambda x:i**x)
        return acts
    acts = makeActions()
походу все в Python взаимодействует через интерфейсы
    например итерирование через вызов __iter__/__next__
скорость кода зависит от кучи факторов:
    модели вызовов
    #лучше тестировать самому чем верить заявлениям
РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ
#\w{6}      >> #<Шесть алфавитно-цифровых символов>
setattr(obj, name, value, /)
#fx
    setattr(x, 'y', v)  # ~ x.y = v
URLS
    https://www.youtube.com/watch?v=I7TJTLSDNYA

сессия
	при каждом запросе отправляются куки



