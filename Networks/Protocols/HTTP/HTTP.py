HTTP
#hyperTextTransfer Protocol - протокол передачи гипертекста
#протокол передачи данных прикладного уровня изначально - в виде гипертекстовых документов формата HTML
#исп для передачи ∀ данных
#основан на клиент-серверной архитектуре -> предпологает ∃
	клиентов
	#инициализирует соединение и посылвает запрос
	сервер
	#ожидает соединение для получения запроса и произведя действия возвращают msg ⊃ результат
#исп больше p2p
#исп как "транспорт" для других протоколов app-уровня 
	SOAP
	XML-RPC
	WebDAV
	...
#осн obj манипуляций - ресурс на который указывает uri в запросе клиента
	#ресурс - обычно файл, но мб и логический? obj | абстрация
#особенность - возможность указать в запросе и ответе способ предоставления одного ресурса по раличным параметрам
	формат
	кодировка
	язык
	..
	#для этого исп HTTP-заголовок
	#благодаря возм указания способа кодирования msg можно обмениваться bin данными хотя протокол - текстовый
#~FTP|SMTP
#для идентификации исп глобальные URI 
#в отличие от многих других протоколов не сохраняет состояния -> компоненты исп http могут сами сохранять состояние(куки/сессии)
#браузер может отслеживать задержки ответов на запросы
#сервер может ⊃ ip-адреса и заголовки запросов последних клиентов
	#сам протокол не осведомлен о состоянии


	
СТРУКТУРА HTTP
∀ HTTP-msg ⊃
	ЗАПРОС
		Starting line
		#тип msg
		#различаются для запроса/ответа
			<Method> <URI> HTTP/<ver>
				<Method>
				#тип запроса
				<URI>
				#путь к документу
			#пример
				GET /wiki/HTTP HTTP/1.0
				Host: ru.wikipedia.org
		Headers
		#определяет тело, параметры передачи, etc
		Message Body
		#данные отделенные пустой стрококй
		#необязательно
	ОТВЕТ
		Starting line
			HTTP/<ver> <status_code> <Reason_Phrase>
			<status_code>
			#код состояния
			#3 цифры
			<Reason_Phrase>
			#краткое пояснение
			#не влияет на msg необязательно
		#пример
			HTTP/1.0 200 OK


ГРУППЫ ЗАГОЛОВКОВ
#именно в таком порядке рекомендуется посылать
#∀ осн для работы HTTP заголовки описаны в основных RFC
	General
	#могут включаться в ∀ msg
	
	
	Request
	#только запросы клиента
	
	
	Response
	#только ответы сервера
	
	
	Entity
	#?сопровождает ∀ сущность msg
#при нехватке ∃ -> можно создавать свои
		#традиционно к именуются с префиксом
			"X-"
			#для избежания конфликтов
			#примеры
				X-Powered-By
				X-Cache
			#некоторые разработчики исп свои префиксы
				Ms-Echo-Request
				Ms-Echo-Reply
				#введены MS для расширения WebDAV


ТЕЛО HTTP-msg
#message-body == payload(полезная нагрузка)
#if ∃ -> передает тело obj связанного с запросом|ответом
#отличается от тела obj(entity-body) only if применяется кодирование передачи что указывается полем заголовка Transfer-Encoding(см Transfer-Encoding)
#допустимость тела в msg
	запросы
	#тело может быть добавлено only if это допускает метод
	#отмечается присутствием полей
	
		Content-Length
		Transfer-Encoding
		
	ответы
	#включение тела зависит от
		метода
		#HEAD исключает тело
		кода состояния
		#∀ состояния ⊃ тело кроме
			1XX
			204
			304
			#даже if оно ⊃ нулевую длинну


ПОЛЯ ЗАГОЛОВКА
#?=ЗАГОЛОВКИ
	Transfer-Encoding
	#указывает исп кодирование передачи
	#причина отличия тело HTTP-msg от тела obj(entity-body)
		message-body = entity-body
		| <entity-body закодировано согласно
		Transfer-Encoding>
	#должно исп для указания ∀ кодирования передачи, исп app для гарантии правильной и безопасной передачи msg
	#свво msg, а не obj -> мб добавлено|удалено ∀ app в цепи запросов/ответов
	
	entity-header
	#поле заголовка obj?
	#заставляет поверить в присутствие obj
	
	Content-Length
	#указывает допустимость тела в запросе
	
	Content-Type:<тип/подтип>
	#указывает харки тела(тип данных ⊂ файлу данных)
		

ЗАГОЛОВКИ
#str ⊂ HTTP-msg вида <name(key)>:<val>
#формат соотв общему формату заголовков текстовых сетевых msg ARPA
#должны отделятся от msg min одной пустой строкой

	Last-Modified
	#видимо последнее Δ страницы для сверки с кешем?
		Last-Modified: Sat, 16 Jan 2010 21:16:42 GMT
		
		
	Allow
	#может ⊃ список поддерживаемых методов
	#вроде возвращается при 501, 405
	
	ETag
	#какой-то ключ?
		ETag: "56d-9989200-1132c580"
		
	Connection
	#управление соединением?
		close
		keep-alive
		#видимо поддерживать
		#видимо таймаут указывается в отдельном заголовке Keep-Alive
	
	Content-Disposition
	#параметры
		name
		#соотв attr html тегов (напр <input>, <textarea>)
		filename
		#имя файла
	#кажется исп для создания вложений в POST запрос(см POST)
	
		Content-Disposition: form-data; name="MessageTitle"
		
		
	Keep-Alive
	#видимо указывает таймаут соединения для Connection
	
	
	Accept-Ranges
	#информирует клиета что он может запрашивать фрагменты по смещению в байтах
	#при отсутствии докачать файл вероятно нельзя?
		Accept-Ranges: bytes
		
		
	Referer
	#указывает что файл запрошен с главной
	#без него сервер может ответить 403 if запросы с других сайтов запрещены
		Referer: http://example.org/
	
	Server
	#вроде указания ПО сервера
		версия
		яп
		архитектура
	#примеры
		Server: Apache/2.2.4
		Server: Apache/2.2.11 (Win32) PHP/5.3.0
	
	
	Location
	#вроде возвращается при 201
	#⊃ URI нового ресурса
		HTTP/1.x Moved Permanently
		Location: http://example.com/about.html#contacts
	#возвращается при 3XX
	
	
	Date
	#вроде текущая дата
		Date: Thu, 19 Feb 2009 11:08:01 GMT
		
		
	User-Agent
	#User-Agent
	
	
	Cache-Control
	#чистить ли кеш
		private
		#сообщает ∀ серверам(в первую очередь proxy) - ответ должен кешироваться только клиентом(иначе другие пользователи могут переходить на не подходящий им домен)
	
	Accept-Language
	#язык содержимого которое готов принять клиент?
		Accept-Language: ru, en-us;q=0.7,en;q=0.3
		
		
	Accept-Charset
	#кодировка содержимого которое готов принять клиент?
		Accept-Charset: windows-1251,utf-8;q=0.7,*;q=0.7
	

	Accept-Encoding
	#шифрование?
		
	Accept
	#то что клиент ожидает/готов принять в качестве ответа?
		Accept: text/html, application/xhtml+xml, application/xml;q=0.9,*/*;q=0.8
		
		applications/x-www-form-urlencoded
		#можно передавать данные в виде словаря
		
	
	Authorization
	#⊃ данные для авторизации
	#~пользовательского заголовка определенной службы
		
	Host
	#адрес хоста к которому осущ запрос?
		Host: example.com
		
	Content-Range
	#информация о диапазоне передаваемого содержимого
		<единицы_измерения> <начальный_байт>-<конечный_байт>/<суммарный_размер>
	#исп при докачке
		Content-Range: bytes 88080384-160993791/160993792
		
	Range
	#диапазон исп при фрагментарной загрузке
		<единицы_измерения>=<начальный_байт>_<конечный_байт>
	#
		Range: bytes=6439716-80496894
		
		
	Content-Type
	#тип содержимого тела?
		Content-Type: text/plain; charset=windows-1251
		Content-Type: video/x-msvideo
		
	Content-Length
	#без указания клиенту не может организовать фрагментарную загрузку(?не уверен)
	#длинна тела?
		Content-Length: 110
	#при докакачке при передаче нескольких фрагментов ⊃ Σ V ∀ фрагментов
	
	
	If-Modified-Since
	#реализует условный GET
	#дата

	Vary
	#исп при согласовании содержимого(см согласование содержимого)


HTTPS
#уровень по модели OSI прикладной, семейство TCP/IP
#создан 2000(?разработан Netscape Communications для Netscape Navigator в 1994)
	порт/id: 443/TCP
#расширение HTTP(не отдельный протокол)
#данные передаются поверх TLS|SSL
#защищает от 
	снифферских атак
	man-in-the-middle
	#if исп шифрование и доверенный сертификат сервера
#для подготовки сервера к обработке https-соединений админ должен поставить в сисму сертификат открытого & закрытого ключа для сервера
	#сертификат открытого ключа подтверждает принадлежность ключа владельцу сайта
	#сертификат открытого ключа и ключ отдаются клиенту при соединении
	#закрытый ключ исп для расшифровки сообщений клиента
	вроде как одним ключем очень просто шифровать ,но очень сложно расшифровать
#можно создать сертификат без центра сертификации
	самоподписанные сертификаты
	#self-signed
	#такие сертификаты подписываются этим же сертификатом
	#без проверки сертификата другим способом подвержено man-in-the-middle
#эта сисма также может исп для аутентификации 
	#админ обычно создает сертификаты ∀ пользователю и отдает их пользователям(по которым они авторизуются)
#для шифрования исп длинны ключа
	40бит(IE<4.0(экспортные ограничения США))(абсолютно ненадежна)
	56бит
	128бит
	256бит
	#многие браузеры не поддерживают длинны от 128 -> не поддерживаются сайтами
#обычно один IP - один https сайт
	#для работы нескольких с различными сертификатами исп SNI


ИДЕНТИФИКАЦИЯ В HTTPS
	СЕРВЕРА
	#https/tls запросы генерятся разыменованием URI -> хост становится известен клиенту
	#в начале общения сервер отдает свой сертификат -> клиент его идентифицирует для исключения man-in-the-middle
		#сертификат ⊃ URI сервера
		#согласование имени хоста и данных сертификата происходит в соотв RFC 2459
			#if имя сервера!=указанное в сертификате -> браузер сообщает пользователю
	
	КЛИЕНТА
	#обычно сервер !⊃ достаточной информации о клиенте, но для повышенной защиты исп two-way-authentificaton
	
УЯЗВИМОСТИ HTTPS
	СОВМЕСТНОЕ ИСП С HTTP
	#потенциальная дыра
	#пример
		основные страницы исп HTTPS, css и js по http
			при загрузке последних можно подкинуть свой код для получения данных html-страницы
			#может быть предотвращен HSTS
	АТАКИ С ИСП АНАЛИЗА ТРАФИКА
	
	
АТАКИ С АНАЛИЗОМ ТРАФФИКА
#вывод свв шифрованных данных по их размеру и времени передачи
#возможны тк SSL/TLS Δ содержимое, но почти не меняет размер/время передачи 


HSTS
#механизм
#закрывает уязвимость http+https принудительным исп https вместо http

two-way-authentification
#поле удостоверения сервера, он также запрашивает сертификат клиента


Server Name Indication
#SNI
#расширение TLS, для работы неск сайтов с разными сертификатами на одном IP
	

СНИФФИНГ
#атака основанная на прослушивании соединения

MAN-IN-THE-MIDDLE
#атака основанная на прослушивании соединения
#сервер https отправляет сертификат с отрытым ключом, if он не заслуживает доверия -> канал уязвим
#замена сертификата удостоверяющего сервер
#успешна if пользователь не проверяет сертификат дважды при предупреждении браузером
	#распространено среди user'ов часто сталкивающихся с самозаверенными сертификатами внутри частных сетей
#злоумышленник - шлюз между клиентом и сервером, через который идет ∀ трафик который он может перенаправлять
#алгоритм
	злоумышленник встраивается между клиентом и сервером
	пересылает ∀ msg без Δ
	перехватывает msg сервера посланных шлюзу по умолчанию
	создает самозаверенный сертификат и подменяет им сертификат сервера
	отправляет ложный сертификат клиенту
	if клиент подтвердит сертификат ->
		устанавливаются защищенные соединения клиент-шлюз и шлюз-сервер
		#теперь у него ∃ закрытый ключ которым от полностью дешифрует трафик



	
TLS
#криптографический протокол используемый HTTPS
#транспортный механизм
#исп ассиметричную(для выработки общего секретного ключа)&симметричную(обмен данными зашифрованных общим ключом) схемы шифрования




SSL
#криптографический протокол используемый HTTPS
#устарел в 2015
#транспортный механизм

	


МЕТОДЫ HTTP
#{xn} ∀ символов кроме управляющих и разделителей 
#указывает на осн операцию над ресурсом
#обычно короткое слово в UPPER
#сервер может исп ∀ методы(!∃ обязательных)

	GET
	#!Δ данные сервера -> считается безопасным
	#указывает что нужно извлечь данные из ресурса
	#запрос содержимого ресурса|начало какого-либо процесса(следует ⊃ информацию о ходе exe процесса)
		#параметры exe процесса можно передавать в URI целевого ресурса после "?"
			GET /path/resource?param1=value1&param2=value2 HTTP/1.1
	#согласно стандарту HTTP запросы - идемпотентны(сервер возвратит тот же результат if ресурс !Δ) - позволяет корретное кеширование
	#⊃ доп виды(порядок их exe определен стандартами отдельно)
		УСЛОВНЫЙ GET
		#⊃ заголовки
			If-Modified-Since
			If-Match
			If-Range
			...
		ЧАСТИЧНЫЙ GET
		#⊃ в запросе Range
		
		
	HEAD
	#!Δ данные сервера -> считается безопасным
	#~GET, но ответ сервера !⊃ тело
	#исп для 
		извлечения метаданных
		проверка наличия ресурса(валидация URL)
		проверка Δ с последнего обращения
	#могут кешироваться - при != метаданных ресурса с соотв информацией в кеше - копия помечается устаревшей
	
	
	POST
	#передача данных ресурсу
	#пример
		клиенты блога могут вводить комментарии в HTMl-форму которые передаются POST и сервер помещает их на страницу
		загрузка файлов на сервер
	#передаваемые данные ⊂ в тело запроса
	#не индепотентен
	#ответ не кешируется
	#ответ вроде может ⊃ 200/201
	#в фундаментальном отличии от PUT, предпологает что по указанному URI переданное содержимое будет обрабатываться
	#пример: страница отправки email ⊃ вложенные файлы(множественное содержимое) -> клиент формирует сообщение типа multipart/form-data интегрируя в него письмо и файлы
		POST /send-message.html HTTP/1.1
		Host: mail.eample.com
		Referer: http://mail.example.com/send-messag.html
		User-Agent: BrowserForDummies/4.67b
		Content-Type: multipart/form-data;  boundary="Asrf456BGe4h"
		Content-Length: <Σ V ⊃ дочерние заголовки>
		Connection: keep-alive
		Keep-Alive: 300
		</n>
		<?отсутствующая преабула>
		--Asrf456BGe4h
		Content-Disposition: form-data; name="DestAddress"
		</n>
		brutal-vasya@example.com
		--Asrf456BGe4h
		Content-Disposition: form-data; name="MessageTitle"
		</n>
		Я негодую
		--Asrf456BGe4h
		Content-Disposition: form-data;  name="MessageText"
		</n>
		Привет, Василий! Твой ручной лев, кторого ты оставил у меня
		на прошлой неделе, разодрал весь мой диван.
		Пожалуйста, забери его скорее!
		Во вложении две фотки с последствиями.
		--Asrf456BGe4h
		Content-Disposition: form-data; name="AttachedFile1"; filename="horror-photo-!.jpg"
		Content-Type: image/jpeg
		</n>
		<bin содержимое первого img>
		--Asrf456BGe4h
		Content-Disposition: form-data; name="AttachedFile2"; filename="horror-photo-2.jpg"
		Content-Type: image/jpeg
		</n>
		<bin содержимое второго img>
		--Asrf456BGe4h--
		<отсутствующий эпилог>
		
		
	OPTIONS
	#определение возможностей сервера|параметров соединения для конкретного ресурса
	#в ответ серверу следует ⊃ заголовок Allow ⊃ список поддерживаемых методов, также в заголовке ответа можно ⊃ поддерживаемые расширения
		#узнать возмножности ∀ сервера|проверка работоспособности(~ping)|проверка на поддержку HTTP/1.1
	#видимо HTTP/1.1+
	#результат не кешируется
	
	
	PUT
	#передача информации в теле
	#загрузка содержимого на указанный URI
	#if по указанному URI !∃ ресурс -> 201
	#if ресурс Δ		-> 200 | 204
	#сервер не должен игнорить некорректные заголовки Content-* ⊃ msg
	#в фундаментальном отличии от POST, исп PUT клиент предпологает что загружаемое содержимое соотв находящемуся по URI ресурсу
	#сообщ ответов не кешируются
	
	
	PATCH
	#~ PUT, но применяется только к фрагменту ресурса
	#передача данных в теле
	
	
	DELETE
	#удаляет указанный ресурс
	
	
	TRACE
	#возвращает полученный запрос так, что клиент может увидеть информацию добавленную/Δ прокси в запросе
	
	
	CONNECT
	#преобразует соединение запроса в прозрачный TCP/IP-туннель
	#обычно исп для содействия установлению защещенного SSL-соединения через нефифрованный прокси
	
	





ПО ДЛЯ РАБОТЫ С HTTP
#спеки http описывают поведение ∀ ролей
#одно по может одновременно exe fx ∀ ролей
	СЕРВЕРЫ
	#список:https://ru.wikipedia.org/wiki/Сравнение_веб-серверов/
		Apache
		IIS
		#Internet Information Servers
		nginx
		Google Web Server
		lighttpd
		...
	КЛИЕНТЫ
	#осн реализация - браузер(тк протокол разрабатывался именно для этого)
	ПРОКСИ
	#посредники для exe транспортных служб
	#список:https://ru.wikipedia.org/wiki/Сравнение_веб-серверов/
		Squid
		UserGate
		Multiproxy
		Naviscope
		nginx
для различия прокси/сервера в доках исп термин "origin server"



СЕССИИ
#серверный ~ кук



СИСМА ДОМЕННЫХ ИМЕН
#плохое решение навязывающее ресурсам иерархическую архитектуру не подходящую для гипертекстового веба

		



Transparent Content Negotiation
#независимая технология !⊂ HTTP
#TCN
#может исп с HTTP
#!= transparent negotiation
#transparent - доступность полного списка вариантов ресурса для ∀ участников процесса доставки данных


RFC
#документ?
	822
	#формат заголовков текстовых сетевых msg ARPA ⊃ формат заголовков HTTP msg
	1630
	#концепция uri
	#1998
	1867
	#формирование HTML-форм и вложение файлов
	2046
	#описывает общие правила работы с медиатипами multipart/*
		#if иное не определено конкретным медиатипом
	2295
	#описывает Transparent Content Negotiation(TCN)
	2396
	#новая версия uri, universan-> uniform
	2459
	#согласование имени хоста и данных сертификата
	2616
	#выделяет transparent negotiation
	2732
	#совместимость uri с ipv6
	#декабрь 99
	2818
	#HTTPS
	3305
	#анонс устаревания термина URL, приоритет URI
	#август 2002
	3986
	#январь 2005
	#текущая структура и синтаксис URI
		фрагмент
		#косвенно идентифицирует вторичный ресурс ссылкой на первичный с указанием доп информации
		#secondary мб ⊂ первичному/его представлением/другим ресурсмо
	#парсинг uri
	#нормализация url
	2718
	#процесс разработки новых схем URI
		схемы должны регистрироваться IANA
	2717
	#процедура регистрации схемы
	
	
ОСНОВНЫЕ МЕХАНИЗМЫ ПРОТОКОЛА

	ЧАСТИЧНЫЕ GET
	#запрос не ∀ содержимого ресурса, а указанный фрагмент
	#возм их exe не обязательна(желательна) для серверов
	#осн исп для 
		докачки
		многопоточной загрузки
		загрузки заголовка архива и для выборочного скачивания пользователем
	#клиент указывает в запросе Range с указанием диапазон	
		#if server не понимает его -> возвращет 200 как при обычном GET
		#else 206 ⊃ Content-Range
	#фрагменты могут передаваться 2мя способами:
		ответ ⊃ Content-Range с байтовым диапазоном в соотв с которым в тело {xn} помещаются фрагменты
		#Content-Length должен = Σ V ∀ фрагментов
		server указывает медиатип multipart/byteranges для основного содержимого и передает фрагменты указывая соотв Content-Range для ∀ элта
		

	УСЛОВНЫЕ GET
	#реализуется полем If-Modified-Sinse запроса
	#в ответ на условный GET тело передается только if ресурс менялся после указанной даты
		if статус ответа отличается от 200|дата в If-Modified-Since некорректна -> ответ ~ обычному GET
		if ресурс Δ после указанной даты	-> ответ как на обычный GET
		if ресурс !Δ	->	304
		

	СОГЛАСОВАНИЕ СОДЕРЖИМОГО
	#Content Negotiation
	#механизм авто определения нужного ресурса при ∃ нескольких разных версий
	#субьекты согласования
		ресурсы сервера
		возвращаемые страницы с err msg(403, 404, ...)
	#два основных типа согласования
	#мб исп одновременно/по отдельности
	#RFC 2616
	
	
		SERVER-DRIVEN
		#при ∃ неск версий ресурса сервер можен анализировать заголовки запроса для выдачи max подходящего по его мнению
		#в основном проверяются заголовки
			Accept
			Accept-Charset
			Accept-Encoding
			Accept-Languages
			User-Agent
		#желательно включать в ответ Vary ⊃ параметры по которым различается содержимое по URI
		#НЕДОСТАТКИ
			сервер лишь предпологает что нужно пользователю(ru|eng ...)
			заголовков Accept-* много, а ресурсов с неск версиями мало -> избыточная нагрузка на оборудование
			общему кэшу создается ограничение возможности выдавать один ответ на ~ запросы от разных пользователей(что очевидно)
			передача заголовков Accept лишает приватности
		
		
		AGENT-DRIVEN
		#клиентом
		#тип содержимого опред клиент
			#для этого сервер возвращает в ответе с кодом 300 | 406 ⊃ список вариантов для выбора
		#исп
			когда содержимое различается по max частым параметрам(язык, кодировка, ...) и исп публичный кеш
		#недостатки
			лишние запросы -> лишняя нагрузка
			
			
		transparent negotiation
		#предпочтительный способ исп agent-driven и server-driven
		#!=TCN
		#transparent- процесс не заменен(прозрачен) для клиента и сервера
		#исп общий кэш ⊃ список вариантов ~ agent-driven
			#if кэш понимает ∀ варианты -> сам сделает выбор
		#снижает нагрузки с сервера, исключает доп запрос клиента
		#подробно не описан в основных спеках HTTP
	
	
	МНОЖЕСТВЕННОЕ СОДЕРЖИМОЕ
	#MIME?(не уверен)
		ТИПЫ
			multipart
				/mixed
				#
				/byteranges
				#исп при запросах фрагментов в частичных GET
				/form-data
				#исп при отправке email ⊃ файлы(см POST), отправка фаилов через формы
		ПАРАМЕТРЫ
			boundry
			#разделитель между типами сообщений
			#пример: 
				#передаваемый из формы параметр DestAdress передает email, а след за ним AttachedFile1 отправляет bin содержимое .jpg		
	#HTTP поддерживает передачу неск сущностей в одном msg
		#сущности могут передаваться в виде
			одноуровневой {xn}
			иерархии с вложением элтов друг в друга
	#для обозначения исп медиатипы
		multipart/*
		#см RFC 2046
		#if получатель не знает типа - обрабатывает как multipart/mixed
	#server msg ⊃ множественное содержимое могут посылаться в ответ на частичные GET при запросе неск фрагментов ресурса -> исп multipart/byteranges
	#при отправке HTML-форм клиентом чаще исп POST
		#см POST


ОПРЕДЕЛЕНИЕ МЕСТОПОЛОЖЕНИЯ ПО IP
#ip зареган на конктретный город - эта инфа общедоступна, дальше может определить только пров


ОСОБЕННОСТИ HTTP
	устанавливает отдельную TCP-сессию на ∀ запрос
	#большинство протоколов предусматривают установление TCP-сессии(одна авторизация, с дальнейшими действиями в ее контексте)
		#в FTP|файловых протоколах тип ⊂ файле данных определяется по расширению
	#исп Content-Type позволяя однозначно определеить способ обработки полученных данных
		#особо важно при работе с CGI-скриптами, когда расширение файла указывает на необходимость запуска на сервере и отправки клиенту результатов exe программы в файле(при этом при разных args запроса и программы могут быть созданы ответы ∀ типов(напр img разных форматов)), а не на тип данных
	#в более поздник версиях можно делать неск запросов в одной TCP-сессии, но браузеры обычно запрашивают только страницу и ⊃ obj(img, css, ...) и сразу рвут сессию
	#для поддержки авторизованного доступа исп cookies
	#позволяет присылать на сервер параметры передаваемые CGI-скрипту(через формы)

cookies
#позволяют сохранить сессию даже при перезагрузках клиента/сервера