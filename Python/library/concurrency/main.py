в python < 3.4 использовались корутины основанные на герераторах

потоки
#не параллельны

GIL
    memory safety
    
    race conditions
#мьютексный(?) механизм предотвращающий одновременное exe нескольких потоков на Python obj
    #в ЛЮБОЙ момент времени exe only один поток
#упрощает обработку mem
#обеспечивает лучшую интеграцию с C
    #обеспечивает легкую интеграцию непотокобезопасных C libs -> СУЩ много high-perf С модулей
#интерпритатор переключается между потоками для достижения конкурентности
#обычно не мешает io


синхронные операции
# задачи exe {xn}
# блокирующие


конкурентность
#необязательно подразумевает параллелизм
#одновременность процессов не на физическом уровне(в отличие от параллелелизма), а на логическом
    #парадигма проектирования сис-м идентифицирующая процессы как независимые что в том числе позволяет исполнять их физически ||
        #но в первую очередь нацелено на написание многопоточных программ и повышение их устойчивости
#задачи конкурируют за ресурсы?
#задачи совместно используют одни данные

    async операции
    # не блокирующие
    # задачи могут exe независимо друг от друга и продолжать exe пока выполнение переходит к новой задаче
    # не блокируют другие операции
    # хотя "планирование задач" происходит {xn}
    # программа не ждет io


    параллелизм
    #подразумевает конкурентность
    #требует поддерки оборудования(больше одного исполнителя)
    #одновременность процессов на физическом уровне


потоки
#в python позволяют exe операции конкурентность